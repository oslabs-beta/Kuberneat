"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/popmotion";
exports.ids = ["vendor-chunks/popmotion"];
exports.modules = {

/***/ "(ssr)/./node_modules/popmotion/dist/popmotion.cjs.js":
/*!******************************************************!*\
  !*** ./node_modules/popmotion/dist/popmotion.cjs.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar tslib = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\nvar heyListen = __webpack_require__(/*! hey-listen */ \"(ssr)/./node_modules/hey-listen/dist/hey-listen.es.js\");\nvar styleValueTypes = __webpack_require__(/*! style-value-types */ \"(ssr)/./node_modules/style-value-types/dist/valueTypes.cjs.js\");\nvar sync = __webpack_require__(/*! framesync */ \"(ssr)/./node_modules/framesync/dist/framesync.cjs.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar sync__default = /*#__PURE__*/ _interopDefaultLegacy(sync);\nconst clamp = (min, max, v)=>Math.min(Math.max(v, min), max);\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {\n    let envelope;\n    let derivative;\n    heyListen.warning(duration <= maxDuration * 1000, \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n    duration = clamp(minDuration, maxDuration, duration / 1000);\n    if (dampingRatio < 1) {\n        envelope = (undampedFreq)=>{\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - a / b * c;\n        };\n        derivative = (undampedFreq)=>{\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return factor * ((d - e) * f) / g;\n        };\n    } else {\n        envelope = (undampedFreq)=>{\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq)=>{\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = duration * 1000;\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: 100,\n            damping: 10,\n            duration\n        };\n    } else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for(let i = 1; i < rootIterations; i++){\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\nconst durationKeys = [\n    \"duration\",\n    \"bounce\"\n];\nconst physicsKeys = [\n    \"stiffness\",\n    \"damping\",\n    \"mass\"\n];\nfunction isSpringType(options, keys) {\n    return keys.some((key)=>options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = Object.assign({\n        velocity: 0.0,\n        stiffness: 100,\n        damping: 10,\n        mass: 1.0,\n        isResolvedFromDuration: false\n    }, options);\n    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), {\n            velocity: 0.0,\n            mass: 1.0\n        });\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring(_a) {\n    var { from = 0.0, to = 1.0, restSpeed = 2, restDelta } = _a, options = tslib.__rest(_a, [\n        \"from\",\n        \"to\",\n        \"restSpeed\",\n        \"restDelta\"\n    ]);\n    const state = {\n        done: false,\n        value: from\n    };\n    let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);\n    let resolveSpring = zero;\n    let resolveVelocity = zero;\n    function createSpring() {\n        const initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n        const initialDelta = to - from;\n        const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n        const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n        if (restDelta === undefined) {\n            restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\n        }\n        if (dampingRatio < 1) {\n            const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n            resolveSpring = (t)=>{\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n            };\n            resolveVelocity = (t)=>{\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t)) - envelope * (Math.cos(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t));\n            };\n        } else if (dampingRatio === 1) {\n            resolveSpring = (t)=>to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n        } else {\n            const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n            resolveSpring = (t)=>{\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                const freqForT = Math.min(dampedAngularFreq * t, 300);\n                return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n            };\n        }\n    }\n    createSpring();\n    return {\n        next: (t)=>{\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                const currentVelocity = resolveVelocity(t) * 1000;\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n                state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            } else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? to : current;\n            return state;\n        },\n        flipTarget: ()=>{\n            velocity = -velocity;\n            [from, to] = [\n                to,\n                from\n            ];\n            createSpring();\n        }\n    };\n}\nspring.needsInterpolation = (a, b)=>typeof a === \"string\" || typeof b === \"string\";\nconst zero = (_t)=>0;\nconst progress = (from, to, value)=>{\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\nconst mix = (from, to, progress)=>-progress * from + progress * to + from;\nfunction hueToRgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    } else {\n        const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha\n    };\n}\nconst mixLinearColor = (from, to, v)=>{\n    const fromExpo = from * from;\n    const toExpo = to * to;\n    return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\n};\nconst colorTypes = [\n    styleValueTypes.hex,\n    styleValueTypes.rgba,\n    styleValueTypes.hsla\n];\nconst getColorType = (v)=>colorTypes.find((type)=>type.test(v));\nconst notAnimatable = (color)=>`'${color}' is not an animatable color. Use the equivalent color code instead.`;\nconst mixColor = (from, to)=>{\n    let fromColorType = getColorType(from);\n    let toColorType = getColorType(to);\n    heyListen.invariant(!!fromColorType, notAnimatable(from));\n    heyListen.invariant(!!toColorType, notAnimatable(to));\n    let fromColor = fromColorType.parse(from);\n    let toColor = toColorType.parse(to);\n    if (fromColorType === styleValueTypes.hsla) {\n        fromColor = hslaToRgba(fromColor);\n        fromColorType = styleValueTypes.rgba;\n    }\n    if (toColorType === styleValueTypes.hsla) {\n        toColor = hslaToRgba(toColor);\n        toColorType = styleValueTypes.rgba;\n    }\n    const blended = Object.assign({}, fromColor);\n    return (v)=>{\n        for(const key in blended){\n            if (key !== \"alpha\") {\n                blended[key] = mixLinearColor(fromColor[key], toColor[key], v);\n            }\n        }\n        blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n        return fromColorType.transform(blended);\n    };\n};\nconst zeroPoint = {\n    x: 0,\n    y: 0,\n    z: 0\n};\nconst isNum = (v)=>typeof v === \"number\";\nconst combineFunctions = (a, b)=>(v)=>b(a(v));\nconst pipe = (...transformers)=>transformers.reduce(combineFunctions);\nfunction getMixer(origin, target) {\n    if (isNum(origin)) {\n        return (v)=>mix(origin, target, v);\n    } else if (styleValueTypes.color.test(origin)) {\n        return mixColor(origin, target);\n    } else {\n        return mixComplex(origin, target);\n    }\n}\nconst mixArray = (from, to)=>{\n    const output = [\n        ...from\n    ];\n    const numValues = output.length;\n    const blendValue = from.map((fromThis, i)=>getMixer(fromThis, to[i]));\n    return (v)=>{\n        for(let i = 0; i < numValues; i++){\n            output[i] = blendValue[i](v);\n        }\n        return output;\n    };\n};\nconst mixObject = (origin, target)=>{\n    const output = Object.assign(Object.assign({}, origin), target);\n    const blendValue = {};\n    for(const key in output){\n        if (origin[key] !== undefined && target[key] !== undefined) {\n            blendValue[key] = getMixer(origin[key], target[key]);\n        }\n    }\n    return (v)=>{\n        for(const key in blendValue){\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n};\nfunction analyse(value) {\n    const parsed = styleValueTypes.complex.parse(value);\n    const numValues = parsed.length;\n    let numNumbers = 0;\n    let numRGB = 0;\n    let numHSL = 0;\n    for(let i = 0; i < numValues; i++){\n        if (numNumbers || typeof parsed[i] === \"number\") {\n            numNumbers++;\n        } else {\n            if (parsed[i].hue !== undefined) {\n                numHSL++;\n            } else {\n                numRGB++;\n            }\n        }\n    }\n    return {\n        parsed,\n        numNumbers,\n        numRGB,\n        numHSL\n    };\n}\nconst mixComplex = (origin, target)=>{\n    const template = styleValueTypes.complex.createTransformer(target);\n    const originStats = analyse(origin);\n    const targetStats = analyse(target);\n    const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;\n    if (canInterpolate) {\n        return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n    } else {\n        heyListen.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return (p)=>`${p > 0 ? target : origin}`;\n    }\n};\nconst mixNumber = (from, to)=>(p)=>mix(from, to, p);\nfunction detectMixerFactory(v) {\n    if (typeof v === \"number\") {\n        return mixNumber;\n    } else if (typeof v === \"string\") {\n        if (styleValueTypes.color.test(v)) {\n            return mixColor;\n        } else {\n            return mixComplex;\n        }\n    } else if (Array.isArray(v)) {\n        return mixArray;\n    } else if (typeof v === \"object\") {\n        return mixObject;\n    }\n}\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || detectMixerFactory(output[0]);\n    const numMixers = output.length - 1;\n    for(let i = 0; i < numMixers; i++){\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\nfunction fastInterpolate([from, to], [mixer]) {\n    return (v)=>mixer(progress(from, to, v));\n}\nfunction slowInterpolate(input, mixers) {\n    const inputLength = input.length;\n    const lastInputIndex = inputLength - 1;\n    return (v)=>{\n        let mixerIndex = 0;\n        let foundMixerIndex = false;\n        if (v <= input[0]) {\n            foundMixerIndex = true;\n        } else if (v >= input[lastInputIndex]) {\n            mixerIndex = lastInputIndex - 1;\n            foundMixerIndex = true;\n        }\n        if (!foundMixerIndex) {\n            let i = 1;\n            for(; i < inputLength; i++){\n                if (input[i] > v || i === lastInputIndex) {\n                    break;\n                }\n            }\n            mixerIndex = i - 1;\n        }\n        const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n        return mixers[mixerIndex](progressInRange);\n    };\n}\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    heyListen.invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n    heyListen.invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, \"Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.\");\n    if (input[0] > input[inputLength - 1]) {\n        input = [].concat(input);\n        output = [].concat(output);\n        input.reverse();\n        output.reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);\n    return isClamp ? (v)=>interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;\n}\nconst reverseEasing = (easing)=>(p)=>1 - easing(1 - p);\nconst mirrorEasing = (easing)=>(p)=>p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\nconst createExpoIn = (power)=>(p)=>Math.pow(p, power);\nconst createBackIn = (power)=>(p)=>p * p * ((power + 1) * p - power);\nconst createAnticipate = (power)=>{\n    const backEasing = createBackIn(power);\n    return (p)=>(p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n};\nconst DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nconst BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;\nconst BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;\nconst BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;\nconst linear = (p)=>p;\nconst easeIn = createExpoIn(2);\nconst easeOut = reverseEasing(easeIn);\nconst easeInOut = mirrorEasing(easeIn);\nconst circIn = (p)=>1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\nconst backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nconst backOut = reverseEasing(backIn);\nconst backInOut = mirrorEasing(backIn);\nconst anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\nconst ca = 4356.0 / 361.0;\nconst cb = 35442.0 / 1805.0;\nconst cc = 16061.0 / 1805.0;\nconst bounceOut = (p)=>{\n    if (p === 1 || p === 0) return p;\n    const p2 = p * p;\n    return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;\n};\nconst bounceIn = reverseEasing(bounceOut);\nconst bounceInOut = (p)=>p < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0)) : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;\nfunction defaultEasing(values, easing) {\n    return values.map(()=>easing || easeInOut).splice(0, values.length - 1);\n}\nfunction defaultOffset(values) {\n    const numValues = values.length;\n    return values.map((_value, i)=>i !== 0 ? i / (numValues - 1) : 0);\n}\nfunction convertOffsetToTimes(offset, duration) {\n    return offset.map((o)=>o * duration);\n}\nfunction keyframes({ from = 0, to = 1, ease, offset, duration = 300 }) {\n    const state = {\n        done: false,\n        value: from\n    };\n    const values = Array.isArray(to) ? to : [\n        from,\n        to\n    ];\n    const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);\n    function createInterpolator() {\n        return interpolate(times, values, {\n            ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)\n        });\n    }\n    let interpolator = createInterpolator();\n    return {\n        next: (t)=>{\n            state.value = interpolator(t);\n            state.done = t >= duration;\n            return state;\n        },\n        flipTarget: ()=>{\n            values.reverse();\n            interpolator = createInterpolator();\n        }\n    };\n}\nfunction decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {\n    const state = {\n        done: false,\n        value: from\n    };\n    let amplitude = power * velocity;\n    const ideal = from + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    if (target !== ideal) amplitude = target - from;\n    return {\n        next: (t)=>{\n            const delta = -amplitude * Math.exp(-t / timeConstant);\n            state.done = !(delta > restDelta || delta < -restDelta);\n            state.value = state.done ? target : target + delta;\n            return state;\n        },\n        flipTarget: ()=>{}\n    };\n}\nconst types = {\n    keyframes,\n    spring,\n    decay\n};\nfunction detectAnimationFromOptions(config) {\n    if (Array.isArray(config.to)) {\n        return keyframes;\n    } else if (types[config.type]) {\n        return types[config.type];\n    }\n    const keys = new Set(Object.keys(config));\n    if (keys.has(\"ease\") || keys.has(\"duration\") && !keys.has(\"dampingRatio\")) {\n        return keyframes;\n    } else if (keys.has(\"dampingRatio\") || keys.has(\"stiffness\") || keys.has(\"mass\") || keys.has(\"damping\") || keys.has(\"restSpeed\") || keys.has(\"restDelta\")) {\n        return spring;\n    }\n    return keyframes;\n}\nfunction loopElapsed(elapsed, duration, delay = 0) {\n    return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {\n    return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\nconst framesync = (update)=>{\n    const passTimestamp = ({ delta })=>update(delta);\n    return {\n        start: ()=>sync__default[\"default\"].update(passTimestamp, true),\n        stop: ()=>sync.cancelSync.update(passTimestamp)\n    };\n};\nfunction animate(_a) {\n    var _b, _c;\n    var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = tslib.__rest(_a, [\n        \"from\",\n        \"autoplay\",\n        \"driver\",\n        \"elapsed\",\n        \"repeat\",\n        \"repeatType\",\n        \"repeatDelay\",\n        \"onPlay\",\n        \"onStop\",\n        \"onComplete\",\n        \"onRepeat\",\n        \"onUpdate\"\n    ]);\n    let { to } = options;\n    let driverControls;\n    let repeatCount = 0;\n    let computedDuration = options.duration;\n    let latest;\n    let isComplete = false;\n    let isForwardPlayback = true;\n    let interpolateFromNumber;\n    const animator = detectAnimationFromOptions(options);\n    if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n        interpolateFromNumber = interpolate([\n            0,\n            100\n        ], [\n            from,\n            to\n        ], {\n            clamp: false\n        });\n        from = 0;\n        to = 100;\n    }\n    const animation = animator(Object.assign(Object.assign({}, options), {\n        from,\n        to\n    }));\n    function repeat() {\n        repeatCount++;\n        if (repeatType === \"reverse\") {\n            isForwardPlayback = repeatCount % 2 === 0;\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n        } else {\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n            if (repeatType === \"mirror\") animation.flipTarget();\n        }\n        isComplete = false;\n        onRepeat && onRepeat();\n    }\n    function complete() {\n        driverControls.stop();\n        onComplete && onComplete();\n    }\n    function update(delta) {\n        if (!isForwardPlayback) delta = -delta;\n        elapsed += delta;\n        if (!isComplete) {\n            const state = animation.next(Math.max(0, elapsed));\n            latest = state.value;\n            if (interpolateFromNumber) latest = interpolateFromNumber(latest);\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n        }\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n        if (isComplete) {\n            if (repeatCount === 0) computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;\n            if (repeatCount < repeatMax) {\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n            } else {\n                complete();\n            }\n        }\n    }\n    function play() {\n        onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n        driverControls = driver(update);\n        driverControls.start();\n    }\n    autoplay && play();\n    return {\n        stop: ()=>{\n            onStop === null || onStop === void 0 ? void 0 : onStop();\n            driverControls.stop();\n        }\n    };\n}\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\nfunction inertia({ from = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {\n    let currentAnimation;\n    function isOutOfBounds(v) {\n        return min !== undefined && v < min || max !== undefined && v > max;\n    }\n    function boundaryNearest(v) {\n        if (min === undefined) return max;\n        if (max === undefined) return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    }\n    function startAnimation(options) {\n        currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n        currentAnimation = animate(Object.assign(Object.assign({}, options), {\n            driver,\n            onUpdate: (v)=>{\n                var _a;\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n                (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n            },\n            onComplete,\n            onStop\n        }));\n    }\n    function startSpring(options) {\n        startAnimation(Object.assign({\n            type: \"spring\",\n            stiffness: bounceStiffness,\n            damping: bounceDamping,\n            restDelta\n        }, options));\n    }\n    if (isOutOfBounds(from)) {\n        startSpring({\n            from,\n            velocity,\n            to: boundaryNearest(from)\n        });\n    } else {\n        let target = power * velocity + from;\n        if (typeof modifyTarget !== \"undefined\") target = modifyTarget(target);\n        const boundary = boundaryNearest(target);\n        const heading = boundary === min ? -1 : 1;\n        let prev;\n        let current;\n        const checkBoundary = (v)=>{\n            prev = current;\n            current = v;\n            velocity = velocityPerSecond(v - prev, sync.getFrameData().delta);\n            if (heading === 1 && v > boundary || heading === -1 && v < boundary) {\n                startSpring({\n                    from: v,\n                    to: boundary,\n                    velocity\n                });\n            }\n        };\n        startAnimation({\n            type: \"decay\",\n            from,\n            velocity,\n            timeConstant,\n            power,\n            restDelta,\n            modifyTarget,\n            onUpdate: isOutOfBounds(target) ? checkBoundary : undefined\n        });\n    }\n    return {\n        stop: ()=>currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()\n    };\n}\nconst radiansToDegrees = (radians)=>radians * 180 / Math.PI;\nconst angle = (a, b = zeroPoint)=>radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\nconst applyOffset = (from, to)=>{\n    let hasReceivedFrom = true;\n    if (to === undefined) {\n        to = from;\n        hasReceivedFrom = false;\n    }\n    return (v)=>{\n        if (hasReceivedFrom) {\n            return v - from + to;\n        } else {\n            from = v;\n            hasReceivedFrom = true;\n            return to;\n        }\n    };\n};\nconst identity = (v)=>v;\nconst createAttractor = (alterDisplacement = identity)=>(constant, origin, v)=>{\n        const displacement = origin - v;\n        const springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));\n        return displacement <= 0 ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;\n    };\nconst attract = createAttractor();\nconst attractExpo = createAttractor(Math.sqrt);\nconst degreesToRadians = (degrees)=>degrees * Math.PI / 180;\nconst isPoint = (point)=>point.hasOwnProperty(\"x\") && point.hasOwnProperty(\"y\");\nconst isPoint3D = (point)=>isPoint(point) && point.hasOwnProperty(\"z\");\nconst distance1D = (a, b)=>Math.abs(a - b);\nfunction distance(a, b) {\n    if (isNum(a) && isNum(b)) {\n        return distance1D(a, b);\n    } else if (isPoint(a) && isPoint(b)) {\n        const xDelta = distance1D(a.x, b.x);\n        const yDelta = distance1D(a.y, b.y);\n        const zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;\n        return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n    }\n}\nconst pointFromVector = (origin, angle, distance)=>{\n    angle = degreesToRadians(angle);\n    return {\n        x: distance * Math.cos(angle) + origin.x,\n        y: distance * Math.sin(angle) + origin.y\n    };\n};\nconst toDecimal = (num, precision = 2)=>{\n    precision = Math.pow(10, precision);\n    return Math.round(num * precision) / precision;\n};\nconst smoothFrame = (prevValue, nextValue, duration, smoothing = 0)=>toDecimal(prevValue + duration * (nextValue - prevValue) / Math.max(smoothing, duration));\nconst smooth = (strength = 50)=>{\n    let previousValue = 0;\n    let lastUpdated = 0;\n    return (v)=>{\n        const currentFramestamp = sync.getFrameData().timestamp;\n        const timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;\n        const newValue = timeDelta ? smoothFrame(previousValue, v, timeDelta, strength) : previousValue;\n        lastUpdated = currentFramestamp;\n        previousValue = newValue;\n        return newValue;\n    };\n};\nconst snap = (points)=>{\n    if (typeof points === \"number\") {\n        return (v)=>Math.round(v / points) * points;\n    } else {\n        let i = 0;\n        const numPoints = points.length;\n        return (v)=>{\n            let lastDistance = Math.abs(points[0] - v);\n            for(i = 1; i < numPoints; i++){\n                const point = points[i];\n                const distance = Math.abs(point - v);\n                if (distance === 0) return point;\n                if (distance > lastDistance) return points[i - 1];\n                if (i === numPoints - 1) return point;\n                lastDistance = distance;\n            }\n        };\n    }\n};\nfunction velocityPerFrame(xps, frameDuration) {\n    return xps / (1000 / frameDuration);\n}\nconst wrap = (min, max, v)=>{\n    const rangeSize = max - min;\n    return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\nconst a = (a1, a2)=>1.0 - 3.0 * a2 + 3.0 * a1;\nconst b = (a1, a2)=>3.0 * a2 - 6.0 * a1;\nconst c = (a1)=>3.0 * a1;\nconst calcBezier = (t, a1, a2)=>((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\nconst getSlope = (t, a1, a2)=>3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 10;\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0.0) {\n            aB = currentT;\n        } else {\n            aA = currentT;\n        }\n    }while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n    return currentT;\n}\nconst newtonIterations = 8;\nconst newtonMinSlope = 0.001;\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n    for(let i = 0; i < newtonIterations; ++i){\n        const currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0) {\n            return aGuessT;\n        }\n        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    if (mX1 === mY1 && mX2 === mY2) return linear;\n    const sampleValues = new Float32Array(kSplineTableSize);\n    for(let i = 0; i < kSplineTableSize; ++i){\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n    function getTForX(aX) {\n        let intervalStart = 0.0;\n        let currentSample = 1;\n        const lastSample = kSplineTableSize - 1;\n        for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        const guessForT = intervalStart + dist * kSampleStepSize;\n        const initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= newtonMinSlope) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        } else if (initialSlope === 0.0) {\n            return guessForT;\n        } else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n        }\n    }\n    return (t)=>t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\nconst steps = (steps, direction = \"end\")=>(progress)=>{\n        progress = direction === \"end\" ? Math.min(progress, 0.999) : Math.max(progress, 0.001);\n        const expanded = progress * steps;\n        const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\n        return clamp(0, 1, rounded / steps);\n    };\nexports.angle = angle;\nexports.animate = animate;\nexports.anticipate = anticipate;\nexports.applyOffset = applyOffset;\nexports.attract = attract;\nexports.attractExpo = attractExpo;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.bounceIn = bounceIn;\nexports.bounceInOut = bounceInOut;\nexports.bounceOut = bounceOut;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.createAnticipate = createAnticipate;\nexports.createAttractor = createAttractor;\nexports.createBackIn = createBackIn;\nexports.createExpoIn = createExpoIn;\nexports.cubicBezier = cubicBezier;\nexports.decay = decay;\nexports.degreesToRadians = degreesToRadians;\nexports.distance = distance;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.inertia = inertia;\nexports.interpolate = interpolate;\nexports.isPoint = isPoint;\nexports.isPoint3D = isPoint3D;\nexports.keyframes = keyframes;\nexports.linear = linear;\nexports.mirrorEasing = mirrorEasing;\nexports.mix = mix;\nexports.mixColor = mixColor;\nexports.mixComplex = mixComplex;\nexports.pipe = pipe;\nexports.pointFromVector = pointFromVector;\nexports.progress = progress;\nexports.radiansToDegrees = radiansToDegrees;\nexports.reverseEasing = reverseEasing;\nexports.smooth = smooth;\nexports.smoothFrame = smoothFrame;\nexports.snap = snap;\nexports.spring = spring;\nexports.steps = steps;\nexports.toDecimal = toDecimal;\nexports.velocityPerFrame = velocityPerFrame;\nexports.velocityPerSecond = velocityPerSecond;\nexports.wrap = wrap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvcG9wbW90aW9uLmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxZQUFZRCxtQkFBT0EsQ0FBQztBQUN4QixJQUFJRSxrQkFBa0JGLG1CQUFPQSxDQUFDO0FBQzlCLElBQUlHLE9BQU9ILG1CQUFPQSxDQUFDO0FBRW5CLFNBQVNJLHNCQUF1QkMsQ0FBQztJQUFJLE9BQU9BLEtBQUssT0FBT0EsTUFBTSxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFBRSxXQUFXQTtJQUFFO0FBQUc7QUFFakgsSUFBSUMsZ0JBQWdCLFdBQVcsR0FBRUYsc0JBQXNCRDtBQUV2RCxNQUFNSSxRQUFRLENBQUNDLEtBQUtDLEtBQUtDLElBQU1DLEtBQUtILEdBQUcsQ0FBQ0csS0FBS0YsR0FBRyxDQUFDQyxHQUFHRixNQUFNQztBQUUxRCxNQUFNRyxVQUFVO0FBQ2hCLE1BQU1DLGNBQWM7QUFDcEIsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxhQUFhO0FBQ25CLE1BQU1DLGFBQWE7QUFDbkIsU0FBU0MsV0FBVyxFQUFFQyxXQUFXLEdBQUcsRUFBRUMsU0FBUyxJQUFJLEVBQUVDLFdBQVcsQ0FBQyxFQUFFQyxPQUFPLENBQUMsRUFBRztJQUMxRSxJQUFJQztJQUNKLElBQUlDO0lBQ0p0QixVQUFVdUIsT0FBTyxDQUFDTixZQUFZSixjQUFjLE1BQU07SUFDbEQsSUFBSVcsZUFBZSxJQUFJTjtJQUN2Qk0sZUFBZWxCLE1BQU1RLFlBQVlDLFlBQVlTO0lBQzdDUCxXQUFXWCxNQUFNTSxhQUFhQyxhQUFhSSxXQUFXO0lBQ3RELElBQUlPLGVBQWUsR0FBRztRQUNsQkgsV0FBVyxDQUFDSTtZQUNSLE1BQU1DLG1CQUFtQkQsZUFBZUQ7WUFDeEMsTUFBTUcsUUFBUUQsbUJBQW1CVDtZQUNqQyxNQUFN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O0FBQzNCdlQsZ0JBQWdCLEdBQUc4VDtBQUNuQjlULGNBQWMsR0FBRzZNO0FBQ2pCN00saUJBQWlCLEdBQUcrTTtBQUNwQi9NLGVBQWUsR0FBRzhNO0FBQ2xCOU0sZUFBZSxHQUFHMlI7QUFDbEIzUixtQkFBbUIsR0FBRzJMO0FBQ3RCM0wsZUFBZSxHQUFHeVQ7QUFDbEJ6VCxpQkFBaUIsR0FBRzRUO0FBQ3BCNVQsaUJBQWlCLEdBQUd1TztBQUNwQnZPLGNBQWMsR0FBRzRNO0FBQ2pCNU0sb0JBQW9CLEdBQUdrTTtBQUN2QmxNLFdBQVcsR0FBR21HO0FBQ2RuRyxnQkFBZ0IsR0FBRzZIO0FBQ25CN0gsa0JBQWtCLEdBQUdrSjtBQUNyQmxKLFlBQVksR0FBRzRJO0FBQ2Y1SSx1QkFBdUIsR0FBR2tVO0FBQzFCbFUsZ0JBQWdCLEdBQUdpRztBQUNuQmpHLHdCQUF3QixHQUFHd1M7QUFDM0J4UyxxQkFBcUIsR0FBR2dNO0FBQ3hCaE0sY0FBYyxHQUFHMFU7QUFDakIxVSxtQkFBbUIsR0FBR3NVO0FBQ3RCdFUsWUFBWSxHQUFHa1Y7QUFDZmxWLGNBQWMsR0FBR2dFO0FBQ2pCaEUsYUFBYSxHQUFHMlg7QUFDaEIzWCxpQkFBaUIsR0FBR21VO0FBQ3BCblUsd0JBQXdCLEdBQUdzVjtBQUMzQnRWLHlCQUF5QixHQUFHeVI7QUFDNUJ6UixZQUFZLEdBQUd3ViIsInNvdXJjZXMiOlsid2VicGFjazovL2t1YmVybmVhdC1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9wb3Btb3Rpb24uY2pzLmpzPzZjNzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xudmFyIGhleUxpc3RlbiA9IHJlcXVpcmUoJ2hleS1saXN0ZW4nKTtcbnZhciBzdHlsZVZhbHVlVHlwZXMgPSByZXF1aXJlKCdzdHlsZS12YWx1ZS10eXBlcycpO1xudmFyIHN5bmMgPSByZXF1aXJlKCdmcmFtZXN5bmMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBzeW5jX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShzeW5jKTtcblxuY29uc3QgY2xhbXAgPSAobWluLCBtYXgsIHYpID0+IE1hdGgubWluKE1hdGgubWF4KHYsIG1pbiksIG1heCk7XG5cbmNvbnN0IHNhZmVNaW4gPSAwLjAwMTtcbmNvbnN0IG1pbkR1cmF0aW9uID0gMC4wMTtcbmNvbnN0IG1heER1cmF0aW9uID0gMTAuMDtcbmNvbnN0IG1pbkRhbXBpbmcgPSAwLjA1O1xuY29uc3QgbWF4RGFtcGluZyA9IDE7XG5mdW5jdGlvbiBmaW5kU3ByaW5nKHsgZHVyYXRpb24gPSA4MDAsIGJvdW5jZSA9IDAuMjUsIHZlbG9jaXR5ID0gMCwgbWFzcyA9IDEsIH0pIHtcbiAgICBsZXQgZW52ZWxvcGU7XG4gICAgbGV0IGRlcml2YXRpdmU7XG4gICAgaGV5TGlzdGVuLndhcm5pbmcoZHVyYXRpb24gPD0gbWF4RHVyYXRpb24gKiAxMDAwLCBcIlNwcmluZyBkdXJhdGlvbiBtdXN0IGJlIDEwIHNlY29uZHMgb3IgbGVzc1wiKTtcbiAgICBsZXQgZGFtcGluZ1JhdGlvID0gMSAtIGJvdW5jZTtcbiAgICBkYW1waW5nUmF0aW8gPSBjbGFtcChtaW5EYW1waW5nLCBtYXhEYW1waW5nLCBkYW1waW5nUmF0aW8pO1xuICAgIGR1cmF0aW9uID0gY2xhbXAobWluRHVyYXRpb24sIG1heER1cmF0aW9uLCBkdXJhdGlvbiAvIDEwMDApO1xuICAgIGlmIChkYW1waW5nUmF0aW8gPCAxKSB7XG4gICAgICAgIGVudmVsb3BlID0gKHVuZGFtcGVkRnJlcSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhwb25lbnRpYWxEZWNheSA9IHVuZGFtcGVkRnJlcSAqIGRhbXBpbmdSYXRpbztcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZXhwb25lbnRpYWxEZWNheSAqIGR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgYSA9IGV4cG9uZW50aWFsRGVjYXkgLSB2ZWxvY2l0eTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBjYWxjQW5ndWxhckZyZXEodW5kYW1wZWRGcmVxLCBkYW1waW5nUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgYyA9IE1hdGguZXhwKC1kZWx0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2FmZU1pbiAtIChhIC8gYikgKiBjO1xuICAgICAgICB9O1xuICAgICAgICBkZXJpdmF0aXZlID0gKHVuZGFtcGVkRnJlcSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhwb25lbnRpYWxEZWNheSA9IHVuZGFtcGVkRnJlcSAqIGRhbXBpbmdSYXRpbztcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZXhwb25lbnRpYWxEZWNheSAqIGR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgZCA9IGRlbHRhICogdmVsb2NpdHkgKyB2ZWxvY2l0eTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBNYXRoLnBvdyhkYW1waW5nUmF0aW8sIDIpICogTWF0aC5wb3codW5kYW1wZWRGcmVxLCAyKSAqIGR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgZiA9IE1hdGguZXhwKC1kZWx0YSk7XG4gICAgICAgICAgICBjb25zdCBnID0gY2FsY0FuZ3VsYXJGcmVxKE1hdGgucG93KHVuZGFtcGVkRnJlcSwgMiksIGRhbXBpbmdSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IgPSAtZW52ZWxvcGUodW5kYW1wZWRGcmVxKSArIHNhZmVNaW4gPiAwID8gLTEgOiAxO1xuICAgICAgICAgICAgcmV0dXJuIChmYWN0b3IgKiAoKGQgLSBlKSAqIGYpKSAvIGc7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnZlbG9wZSA9ICh1bmRhbXBlZEZyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBNYXRoLmV4cCgtdW5kYW1wZWRGcmVxICogZHVyYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgYiA9ICh1bmRhbXBlZEZyZXEgLSB2ZWxvY2l0eSkgKiBkdXJhdGlvbiArIDE7XG4gICAgICAgICAgICByZXR1cm4gLXNhZmVNaW4gKyBhICogYjtcbiAgICAgICAgfTtcbiAgICAgICAgZGVyaXZhdGl2ZSA9ICh1bmRhbXBlZEZyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBNYXRoLmV4cCgtdW5kYW1wZWRGcmVxICogZHVyYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgYiA9ICh2ZWxvY2l0eSAtIHVuZGFtcGVkRnJlcSkgKiAoZHVyYXRpb24gKiBkdXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gYSAqIGI7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGluaXRpYWxHdWVzcyA9IDUgLyBkdXJhdGlvbjtcbiAgICBjb25zdCB1bmRhbXBlZEZyZXEgPSBhcHByb3hpbWF0ZVJvb3QoZW52ZWxvcGUsIGRlcml2YXRpdmUsIGluaXRpYWxHdWVzcyk7XG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbiAqIDEwMDA7XG4gICAgaWYgKGlzTmFOKHVuZGFtcGVkRnJlcSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0aWZmbmVzczogMTAwLFxuICAgICAgICAgICAgZGFtcGluZzogMTAsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHN0aWZmbmVzcyA9IE1hdGgucG93KHVuZGFtcGVkRnJlcSwgMikgKiBtYXNzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RpZmZuZXNzLFxuICAgICAgICAgICAgZGFtcGluZzogZGFtcGluZ1JhdGlvICogMiAqIE1hdGguc3FydChtYXNzICogc3RpZmZuZXNzKSxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmNvbnN0IHJvb3RJdGVyYXRpb25zID0gMTI7XG5mdW5jdGlvbiBhcHByb3hpbWF0ZVJvb3QoZW52ZWxvcGUsIGRlcml2YXRpdmUsIGluaXRpYWxHdWVzcykge1xuICAgIGxldCByZXN1bHQgPSBpbml0aWFsR3Vlc3M7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByb290SXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAtIGVudmVsb3BlKHJlc3VsdCkgLyBkZXJpdmF0aXZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjYWxjQW5ndWxhckZyZXEodW5kYW1wZWRGcmVxLCBkYW1waW5nUmF0aW8pIHtcbiAgICByZXR1cm4gdW5kYW1wZWRGcmVxICogTWF0aC5zcXJ0KDEgLSBkYW1waW5nUmF0aW8gKiBkYW1waW5nUmF0aW8pO1xufVxuXG5jb25zdCBkdXJhdGlvbktleXMgPSBbXCJkdXJhdGlvblwiLCBcImJvdW5jZVwiXTtcbmNvbnN0IHBoeXNpY3NLZXlzID0gW1wic3RpZmZuZXNzXCIsIFwiZGFtcGluZ1wiLCBcIm1hc3NcIl07XG5mdW5jdGlvbiBpc1NwcmluZ1R5cGUob3B0aW9ucywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnNvbWUoKGtleSkgPT4gb3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gZ2V0U3ByaW5nT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgbGV0IHNwcmluZ09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgdmVsb2NpdHk6IDAuMCwgc3RpZmZuZXNzOiAxMDAsIGRhbXBpbmc6IDEwLCBtYXNzOiAxLjAsIGlzUmVzb2x2ZWRGcm9tRHVyYXRpb246IGZhbHNlIH0sIG9wdGlvbnMpO1xuICAgIGlmICghaXNTcHJpbmdUeXBlKG9wdGlvbnMsIHBoeXNpY3NLZXlzKSAmJlxuICAgICAgICBpc1NwcmluZ1R5cGUob3B0aW9ucywgZHVyYXRpb25LZXlzKSkge1xuICAgICAgICBjb25zdCBkZXJpdmVkID0gZmluZFNwcmluZyhvcHRpb25zKTtcbiAgICAgICAgc3ByaW5nT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzcHJpbmdPcHRpb25zKSwgZGVyaXZlZCksIHsgdmVsb2NpdHk6IDAuMCwgbWFzczogMS4wIH0pO1xuICAgICAgICBzcHJpbmdPcHRpb25zLmlzUmVzb2x2ZWRGcm9tRHVyYXRpb24gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc3ByaW5nT3B0aW9ucztcbn1cbmZ1bmN0aW9uIHNwcmluZyhfYSkge1xuICAgIHZhciB7IGZyb20gPSAwLjAsIHRvID0gMS4wLCByZXN0U3BlZWQgPSAyLCByZXN0RGVsdGEgfSA9IF9hLCBvcHRpb25zID0gdHNsaWIuX19yZXN0KF9hLCBbXCJmcm9tXCIsIFwidG9cIiwgXCJyZXN0U3BlZWRcIiwgXCJyZXN0RGVsdGFcIl0pO1xuICAgIGNvbnN0IHN0YXRlID0geyBkb25lOiBmYWxzZSwgdmFsdWU6IGZyb20gfTtcbiAgICBsZXQgeyBzdGlmZm5lc3MsIGRhbXBpbmcsIG1hc3MsIHZlbG9jaXR5LCBkdXJhdGlvbiwgaXNSZXNvbHZlZEZyb21EdXJhdGlvbiwgfSA9IGdldFNwcmluZ09wdGlvbnMob3B0aW9ucyk7XG4gICAgbGV0IHJlc29sdmVTcHJpbmcgPSB6ZXJvO1xuICAgIGxldCByZXNvbHZlVmVsb2NpdHkgPSB6ZXJvO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVNwcmluZygpIHtcbiAgICAgICAgY29uc3QgaW5pdGlhbFZlbG9jaXR5ID0gdmVsb2NpdHkgPyAtKHZlbG9jaXR5IC8gMTAwMCkgOiAwLjA7XG4gICAgICAgIGNvbnN0IGluaXRpYWxEZWx0YSA9IHRvIC0gZnJvbTtcbiAgICAgICAgY29uc3QgZGFtcGluZ1JhdGlvID0gZGFtcGluZyAvICgyICogTWF0aC5zcXJ0KHN0aWZmbmVzcyAqIG1hc3MpKTtcbiAgICAgICAgY29uc3QgdW5kYW1wZWRBbmd1bGFyRnJlcSA9IE1hdGguc3FydChzdGlmZm5lc3MgLyBtYXNzKSAvIDEwMDA7XG4gICAgICAgIGlmIChyZXN0RGVsdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdERlbHRhID0gTWF0aC5taW4oTWF0aC5hYnModG8gLSBmcm9tKSAvIDEwMCwgMC40KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGFtcGluZ1JhdGlvIDwgMSkge1xuICAgICAgICAgICAgY29uc3QgYW5ndWxhckZyZXEgPSBjYWxjQW5ndWxhckZyZXEodW5kYW1wZWRBbmd1bGFyRnJlcSwgZGFtcGluZ1JhdGlvKTtcbiAgICAgICAgICAgIHJlc29sdmVTcHJpbmcgPSAodCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudmVsb3BlID0gTWF0aC5leHAoLWRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRvIC1cbiAgICAgICAgICAgICAgICAgICAgZW52ZWxvcGUgKlxuICAgICAgICAgICAgICAgICAgICAgICAgKCgoaW5pdGlhbFZlbG9jaXR5ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhckZyZXEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbihhbmd1bGFyRnJlcSAqIHQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsRGVsdGEgKiBNYXRoLmNvcyhhbmd1bGFyRnJlcSAqIHQpKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZVZlbG9jaXR5ID0gKHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnZlbG9wZSA9IE1hdGguZXhwKC1kYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkYW1waW5nUmF0aW8gKlxuICAgICAgICAgICAgICAgICAgICB1bmRhbXBlZEFuZ3VsYXJGcmVxICpcbiAgICAgICAgICAgICAgICAgICAgZW52ZWxvcGUgKlxuICAgICAgICAgICAgICAgICAgICAoKE1hdGguc2luKGFuZ3VsYXJGcmVxICogdCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgKGluaXRpYWxWZWxvY2l0eSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFtcGluZ1JhdGlvICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kYW1wZWRBbmd1bGFyRnJlcSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxEZWx0YSkpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXJGcmVxICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxEZWx0YSAqIE1hdGguY29zKGFuZ3VsYXJGcmVxICogdCkpIC1cbiAgICAgICAgICAgICAgICAgICAgZW52ZWxvcGUgKlxuICAgICAgICAgICAgICAgICAgICAgICAgKE1hdGguY29zKGFuZ3VsYXJGcmVxICogdCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbml0aWFsVmVsb2NpdHkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYW1waW5nUmF0aW8gKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kYW1wZWRBbmd1bGFyRnJlcSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsRGVsdGEpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyRnJlcSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxEZWx0YSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luKGFuZ3VsYXJGcmVxICogdCkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGFtcGluZ1JhdGlvID09PSAxKSB7XG4gICAgICAgICAgICByZXNvbHZlU3ByaW5nID0gKHQpID0+IHRvIC1cbiAgICAgICAgICAgICAgICBNYXRoLmV4cCgtdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpICpcbiAgICAgICAgICAgICAgICAgICAgKGluaXRpYWxEZWx0YSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoaW5pdGlhbFZlbG9jaXR5ICsgdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGFtcGVkQW5ndWxhckZyZXEgPSB1bmRhbXBlZEFuZ3VsYXJGcmVxICogTWF0aC5zcXJ0KGRhbXBpbmdSYXRpbyAqIGRhbXBpbmdSYXRpbyAtIDEpO1xuICAgICAgICAgICAgcmVzb2x2ZVNwcmluZyA9ICh0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW52ZWxvcGUgPSBNYXRoLmV4cCgtZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyZXFGb3JUID0gTWF0aC5taW4oZGFtcGVkQW5ndWxhckZyZXEgKiB0LCAzMDApO1xuICAgICAgICAgICAgICAgIHJldHVybiAodG8gLVxuICAgICAgICAgICAgICAgICAgICAoZW52ZWxvcGUgKlxuICAgICAgICAgICAgICAgICAgICAgICAgKChpbml0aWFsVmVsb2NpdHkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbmgoZnJlcUZvclQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYW1wZWRBbmd1bGFyRnJlcSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxEZWx0YSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY29zaChmcmVxRm9yVCkpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICBkYW1wZWRBbmd1bGFyRnJlcSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVNwcmluZygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6ICh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gcmVzb2x2ZVNwcmluZyh0KTtcbiAgICAgICAgICAgIGlmICghaXNSZXNvbHZlZEZyb21EdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWZWxvY2l0eSA9IHJlc29sdmVWZWxvY2l0eSh0KSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNCZWxvd1ZlbG9jaXR5VGhyZXNob2xkID0gTWF0aC5hYnMoY3VycmVudFZlbG9jaXR5KSA8PSByZXN0U3BlZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNCZWxvd0Rpc3BsYWNlbWVudFRocmVzaG9sZCA9IE1hdGguYWJzKHRvIC0gY3VycmVudCkgPD0gcmVzdERlbHRhO1xuICAgICAgICAgICAgICAgIHN0YXRlLmRvbmUgPVxuICAgICAgICAgICAgICAgICAgICBpc0JlbG93VmVsb2NpdHlUaHJlc2hvbGQgJiYgaXNCZWxvd0Rpc3BsYWNlbWVudFRocmVzaG9sZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLmRvbmUgPSB0ID49IGR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudmFsdWUgPSBzdGF0ZS5kb25lID8gdG8gOiBjdXJyZW50O1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBmbGlwVGFyZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IC12ZWxvY2l0eTtcbiAgICAgICAgICAgIFtmcm9tLCB0b10gPSBbdG8sIGZyb21dO1xuICAgICAgICAgICAgY3JlYXRlU3ByaW5nKCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbnNwcmluZy5uZWVkc0ludGVycG9sYXRpb24gPSAoYSwgYikgPT4gdHlwZW9mIGEgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGIgPT09IFwic3RyaW5nXCI7XG5jb25zdCB6ZXJvID0gKF90KSA9PiAwO1xuXG5jb25zdCBwcm9ncmVzcyA9IChmcm9tLCB0bywgdmFsdWUpID0+IHtcbiAgICBjb25zdCB0b0Zyb21EaWZmZXJlbmNlID0gdG8gLSBmcm9tO1xuICAgIHJldHVybiB0b0Zyb21EaWZmZXJlbmNlID09PSAwID8gMSA6ICh2YWx1ZSAtIGZyb20pIC8gdG9Gcm9tRGlmZmVyZW5jZTtcbn07XG5cbmNvbnN0IG1peCA9IChmcm9tLCB0bywgcHJvZ3Jlc3MpID0+IC1wcm9ncmVzcyAqIGZyb20gKyBwcm9ncmVzcyAqIHRvICsgZnJvbTtcblxuZnVuY3Rpb24gaHVlVG9SZ2IocCwgcSwgdCkge1xuICAgIGlmICh0IDwgMClcbiAgICAgICAgdCArPSAxO1xuICAgIGlmICh0ID4gMSlcbiAgICAgICAgdCAtPSAxO1xuICAgIGlmICh0IDwgMSAvIDYpXG4gICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgIGlmICh0IDwgMSAvIDIpXG4gICAgICAgIHJldHVybiBxO1xuICAgIGlmICh0IDwgMiAvIDMpXG4gICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGhzbGFUb1JnYmEoeyBodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcywgYWxwaGEgfSkge1xuICAgIGh1ZSAvPSAzNjA7XG4gICAgc2F0dXJhdGlvbiAvPSAxMDA7XG4gICAgbGlnaHRuZXNzIC89IDEwMDtcbiAgICBsZXQgcmVkID0gMDtcbiAgICBsZXQgZ3JlZW4gPSAwO1xuICAgIGxldCBibHVlID0gMDtcbiAgICBpZiAoIXNhdHVyYXRpb24pIHtcbiAgICAgICAgcmVkID0gZ3JlZW4gPSBibHVlID0gbGlnaHRuZXNzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcSA9IGxpZ2h0bmVzcyA8IDAuNVxuICAgICAgICAgICAgPyBsaWdodG5lc3MgKiAoMSArIHNhdHVyYXRpb24pXG4gICAgICAgICAgICA6IGxpZ2h0bmVzcyArIHNhdHVyYXRpb24gLSBsaWdodG5lc3MgKiBzYXR1cmF0aW9uO1xuICAgICAgICBjb25zdCBwID0gMiAqIGxpZ2h0bmVzcyAtIHE7XG4gICAgICAgIHJlZCA9IGh1ZVRvUmdiKHAsIHEsIGh1ZSArIDEgLyAzKTtcbiAgICAgICAgZ3JlZW4gPSBodWVUb1JnYihwLCBxLCBodWUpO1xuICAgICAgICBibHVlID0gaHVlVG9SZ2IocCwgcSwgaHVlIC0gMSAvIDMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZWQ6IE1hdGgucm91bmQocmVkICogMjU1KSxcbiAgICAgICAgZ3JlZW46IE1hdGgucm91bmQoZ3JlZW4gKiAyNTUpLFxuICAgICAgICBibHVlOiBNYXRoLnJvdW5kKGJsdWUgKiAyNTUpLFxuICAgICAgICBhbHBoYSxcbiAgICB9O1xufVxuXG5jb25zdCBtaXhMaW5lYXJDb2xvciA9IChmcm9tLCB0bywgdikgPT4ge1xuICAgIGNvbnN0IGZyb21FeHBvID0gZnJvbSAqIGZyb207XG4gICAgY29uc3QgdG9FeHBvID0gdG8gKiB0bztcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIHYgKiAodG9FeHBvIC0gZnJvbUV4cG8pICsgZnJvbUV4cG8pKTtcbn07XG5jb25zdCBjb2xvclR5cGVzID0gW3N0eWxlVmFsdWVUeXBlcy5oZXgsIHN0eWxlVmFsdWVUeXBlcy5yZ2JhLCBzdHlsZVZhbHVlVHlwZXMuaHNsYV07XG5jb25zdCBnZXRDb2xvclR5cGUgPSAodikgPT4gY29sb3JUeXBlcy5maW5kKCh0eXBlKSA9PiB0eXBlLnRlc3QodikpO1xuY29uc3Qgbm90QW5pbWF0YWJsZSA9IChjb2xvcikgPT4gYCcke2NvbG9yfScgaXMgbm90IGFuIGFuaW1hdGFibGUgY29sb3IuIFVzZSB0aGUgZXF1aXZhbGVudCBjb2xvciBjb2RlIGluc3RlYWQuYDtcbmNvbnN0IG1peENvbG9yID0gKGZyb20sIHRvKSA9PiB7XG4gICAgbGV0IGZyb21Db2xvclR5cGUgPSBnZXRDb2xvclR5cGUoZnJvbSk7XG4gICAgbGV0IHRvQ29sb3JUeXBlID0gZ2V0Q29sb3JUeXBlKHRvKTtcbiAgICBoZXlMaXN0ZW4uaW52YXJpYW50KCEhZnJvbUNvbG9yVHlwZSwgbm90QW5pbWF0YWJsZShmcm9tKSk7XG4gICAgaGV5TGlzdGVuLmludmFyaWFudCghIXRvQ29sb3JUeXBlLCBub3RBbmltYXRhYmxlKHRvKSk7XG4gICAgbGV0IGZyb21Db2xvciA9IGZyb21Db2xvclR5cGUucGFyc2UoZnJvbSk7XG4gICAgbGV0IHRvQ29sb3IgPSB0b0NvbG9yVHlwZS5wYXJzZSh0byk7XG4gICAgaWYgKGZyb21Db2xvclR5cGUgPT09IHN0eWxlVmFsdWVUeXBlcy5oc2xhKSB7XG4gICAgICAgIGZyb21Db2xvciA9IGhzbGFUb1JnYmEoZnJvbUNvbG9yKTtcbiAgICAgICAgZnJvbUNvbG9yVHlwZSA9IHN0eWxlVmFsdWVUeXBlcy5yZ2JhO1xuICAgIH1cbiAgICBpZiAodG9Db2xvclR5cGUgPT09IHN0eWxlVmFsdWVUeXBlcy5oc2xhKSB7XG4gICAgICAgIHRvQ29sb3IgPSBoc2xhVG9SZ2JhKHRvQ29sb3IpO1xuICAgICAgICB0b0NvbG9yVHlwZSA9IHN0eWxlVmFsdWVUeXBlcy5yZ2JhO1xuICAgIH1cbiAgICBjb25zdCBibGVuZGVkID0gT2JqZWN0LmFzc2lnbih7fSwgZnJvbUNvbG9yKTtcbiAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYmxlbmRlZCkge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJhbHBoYVwiKSB7XG4gICAgICAgICAgICAgICAgYmxlbmRlZFtrZXldID0gbWl4TGluZWFyQ29sb3IoZnJvbUNvbG9yW2tleV0sIHRvQ29sb3Jba2V5XSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmxlbmRlZC5hbHBoYSA9IG1peChmcm9tQ29sb3IuYWxwaGEsIHRvQ29sb3IuYWxwaGEsIHYpO1xuICAgICAgICByZXR1cm4gZnJvbUNvbG9yVHlwZS50cmFuc2Zvcm0oYmxlbmRlZCk7XG4gICAgfTtcbn07XG5cbmNvbnN0IHplcm9Qb2ludCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgejogMFxufTtcbmNvbnN0IGlzTnVtID0gKHYpID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJztcblxuY29uc3QgY29tYmluZUZ1bmN0aW9ucyA9IChhLCBiKSA9PiAodikgPT4gYihhKHYpKTtcbmNvbnN0IHBpcGUgPSAoLi4udHJhbnNmb3JtZXJzKSA9PiB0cmFuc2Zvcm1lcnMucmVkdWNlKGNvbWJpbmVGdW5jdGlvbnMpO1xuXG5mdW5jdGlvbiBnZXRNaXhlcihvcmlnaW4sIHRhcmdldCkge1xuICAgIGlmIChpc051bShvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiAodikgPT4gbWl4KG9yaWdpbiwgdGFyZ2V0LCB2KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3R5bGVWYWx1ZVR5cGVzLmNvbG9yLnRlc3Qob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gbWl4Q29sb3Iob3JpZ2luLCB0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1peENvbXBsZXgob3JpZ2luLCB0YXJnZXQpO1xuICAgIH1cbn1cbmNvbnN0IG1peEFycmF5ID0gKGZyb20sIHRvKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gWy4uLmZyb21dO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IG91dHB1dC5sZW5ndGg7XG4gICAgY29uc3QgYmxlbmRWYWx1ZSA9IGZyb20ubWFwKChmcm9tVGhpcywgaSkgPT4gZ2V0TWl4ZXIoZnJvbVRoaXMsIHRvW2ldKSk7XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmFsdWVzOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IGJsZW5kVmFsdWVbaV0odik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufTtcbmNvbnN0IG1peE9iamVjdCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luKSwgdGFyZ2V0KTtcbiAgICBjb25zdCBibGVuZFZhbHVlID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3V0cHV0KSB7XG4gICAgICAgIGlmIChvcmlnaW5ba2V5XSAhPT0gdW5kZWZpbmVkICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJsZW5kVmFsdWVba2V5XSA9IGdldE1peGVyKG9yaWdpbltrZXldLCB0YXJnZXRba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGJsZW5kVmFsdWUpIHtcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gYmxlbmRWYWx1ZVtrZXldKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn07XG5mdW5jdGlvbiBhbmFseXNlKHZhbHVlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3R5bGVWYWx1ZVR5cGVzLmNvbXBsZXgucGFyc2UodmFsdWUpO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IHBhcnNlZC5sZW5ndGg7XG4gICAgbGV0IG51bU51bWJlcnMgPSAwO1xuICAgIGxldCBudW1SR0IgPSAwO1xuICAgIGxldCBudW1IU0wgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmFsdWVzOyBpKyspIHtcbiAgICAgICAgaWYgKG51bU51bWJlcnMgfHwgdHlwZW9mIHBhcnNlZFtpXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbnVtTnVtYmVycysrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhcnNlZFtpXS5odWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG51bUhTTCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbnVtUkdCKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgcGFyc2VkLCBudW1OdW1iZXJzLCBudW1SR0IsIG51bUhTTCB9O1xufVxuY29uc3QgbWl4Q29tcGxleCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gc3R5bGVWYWx1ZVR5cGVzLmNvbXBsZXguY3JlYXRlVHJhbnNmb3JtZXIodGFyZ2V0KTtcbiAgICBjb25zdCBvcmlnaW5TdGF0cyA9IGFuYWx5c2Uob3JpZ2luKTtcbiAgICBjb25zdCB0YXJnZXRTdGF0cyA9IGFuYWx5c2UodGFyZ2V0KTtcbiAgICBjb25zdCBjYW5JbnRlcnBvbGF0ZSA9IG9yaWdpblN0YXRzLm51bUhTTCA9PT0gdGFyZ2V0U3RhdHMubnVtSFNMICYmXG4gICAgICAgIG9yaWdpblN0YXRzLm51bVJHQiA9PT0gdGFyZ2V0U3RhdHMubnVtUkdCICYmXG4gICAgICAgIG9yaWdpblN0YXRzLm51bU51bWJlcnMgPj0gdGFyZ2V0U3RhdHMubnVtTnVtYmVycztcbiAgICBpZiAoY2FuSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgcmV0dXJuIHBpcGUobWl4QXJyYXkob3JpZ2luU3RhdHMucGFyc2VkLCB0YXJnZXRTdGF0cy5wYXJzZWQpLCB0ZW1wbGF0ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoZXlMaXN0ZW4ud2FybmluZyh0cnVlLCBgQ29tcGxleCB2YWx1ZXMgJyR7b3JpZ2lufScgYW5kICcke3RhcmdldH0nIHRvbyBkaWZmZXJlbnQgdG8gbWl4LiBFbnN1cmUgYWxsIGNvbG9ycyBhcmUgb2YgdGhlIHNhbWUgdHlwZSwgYW5kIHRoYXQgZWFjaCBjb250YWlucyB0aGUgc2FtZSBxdWFudGl0eSBvZiBudW1iZXIgYW5kIGNvbG9yIHZhbHVlcy4gRmFsbGluZyBiYWNrIHRvIGluc3RhbnQgdHJhbnNpdGlvbi5gKTtcbiAgICAgICAgcmV0dXJuIChwKSA9PiBgJHtwID4gMCA/IHRhcmdldCA6IG9yaWdpbn1gO1xuICAgIH1cbn07XG5cbmNvbnN0IG1peE51bWJlciA9IChmcm9tLCB0bykgPT4gKHApID0+IG1peChmcm9tLCB0bywgcCk7XG5mdW5jdGlvbiBkZXRlY3RNaXhlckZhY3Rvcnkodikge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG1peE51bWJlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChzdHlsZVZhbHVlVHlwZXMuY29sb3IudGVzdCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIG1peENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1peENvbXBsZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICByZXR1cm4gbWl4QXJyYXk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbWl4T2JqZWN0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU1peGVycyhvdXRwdXQsIGVhc2UsIGN1c3RvbU1peGVyKSB7XG4gICAgY29uc3QgbWl4ZXJzID0gW107XG4gICAgY29uc3QgbWl4ZXJGYWN0b3J5ID0gY3VzdG9tTWl4ZXIgfHwgZGV0ZWN0TWl4ZXJGYWN0b3J5KG91dHB1dFswXSk7XG4gICAgY29uc3QgbnVtTWl4ZXJzID0gb3V0cHV0Lmxlbmd0aCAtIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1NaXhlcnM7IGkrKykge1xuICAgICAgICBsZXQgbWl4ZXIgPSBtaXhlckZhY3Rvcnkob3V0cHV0W2ldLCBvdXRwdXRbaSArIDFdKTtcbiAgICAgICAgaWYgKGVhc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGVhc2luZ0Z1bmN0aW9uID0gQXJyYXkuaXNBcnJheShlYXNlKSA/IGVhc2VbaV0gOiBlYXNlO1xuICAgICAgICAgICAgbWl4ZXIgPSBwaXBlKGVhc2luZ0Z1bmN0aW9uLCBtaXhlcik7XG4gICAgICAgIH1cbiAgICAgICAgbWl4ZXJzLnB1c2gobWl4ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbWl4ZXJzO1xufVxuZnVuY3Rpb24gZmFzdEludGVycG9sYXRlKFtmcm9tLCB0b10sIFttaXhlcl0pIHtcbiAgICByZXR1cm4gKHYpID0+IG1peGVyKHByb2dyZXNzKGZyb20sIHRvLCB2KSk7XG59XG5mdW5jdGlvbiBzbG93SW50ZXJwb2xhdGUoaW5wdXQsIG1peGVycykge1xuICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3RJbnB1dEluZGV4ID0gaW5wdXRMZW5ndGggLSAxO1xuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgICBsZXQgbWl4ZXJJbmRleCA9IDA7XG4gICAgICAgIGxldCBmb3VuZE1peGVySW5kZXggPSBmYWxzZTtcbiAgICAgICAgaWYgKHYgPD0gaW5wdXRbMF0pIHtcbiAgICAgICAgICAgIGZvdW5kTWl4ZXJJbmRleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA+PSBpbnB1dFtsYXN0SW5wdXRJbmRleF0pIHtcbiAgICAgICAgICAgIG1peGVySW5kZXggPSBsYXN0SW5wdXRJbmRleCAtIDE7XG4gICAgICAgICAgICBmb3VuZE1peGVySW5kZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm91bmRNaXhlckluZGV4KSB7XG4gICAgICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGlucHV0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRbaV0gPiB2IHx8IGkgPT09IGxhc3RJbnB1dEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1peGVySW5kZXggPSBpIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9ncmVzc0luUmFuZ2UgPSBwcm9ncmVzcyhpbnB1dFttaXhlckluZGV4XSwgaW5wdXRbbWl4ZXJJbmRleCArIDFdLCB2KTtcbiAgICAgICAgcmV0dXJuIG1peGVyc1ttaXhlckluZGV4XShwcm9ncmVzc0luUmFuZ2UpO1xuICAgIH07XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShpbnB1dCwgb3V0cHV0LCB7IGNsYW1wOiBpc0NsYW1wID0gdHJ1ZSwgZWFzZSwgbWl4ZXIgfSA9IHt9KSB7XG4gICAgY29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgaGV5TGlzdGVuLmludmFyaWFudChpbnB1dExlbmd0aCA9PT0gb3V0cHV0Lmxlbmd0aCwgJ0JvdGggaW5wdXQgYW5kIG91dHB1dCByYW5nZXMgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGgnKTtcbiAgICBoZXlMaXN0ZW4uaW52YXJpYW50KCFlYXNlIHx8ICFBcnJheS5pc0FycmF5KGVhc2UpIHx8IGVhc2UubGVuZ3RoID09PSBpbnB1dExlbmd0aCAtIDEsICdBcnJheSBvZiBlYXNpbmcgZnVuY3Rpb25zIG11c3QgYmUgb2YgbGVuZ3RoIGBpbnB1dC5sZW5ndGggLSAxYCwgYXMgaXQgYXBwbGllcyB0byB0aGUgdHJhbnNpdGlvbnMgKipiZXR3ZWVuKiogdGhlIGRlZmluZWQgdmFsdWVzLicpO1xuICAgIGlmIChpbnB1dFswXSA+IGlucHV0W2lucHV0TGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgaW5wdXQgPSBbXS5jb25jYXQoaW5wdXQpO1xuICAgICAgICBvdXRwdXQgPSBbXS5jb25jYXQob3V0cHV0KTtcbiAgICAgICAgaW5wdXQucmV2ZXJzZSgpO1xuICAgICAgICBvdXRwdXQucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBjb25zdCBtaXhlcnMgPSBjcmVhdGVNaXhlcnMob3V0cHV0LCBlYXNlLCBtaXhlcik7XG4gICAgY29uc3QgaW50ZXJwb2xhdG9yID0gaW5wdXRMZW5ndGggPT09IDJcbiAgICAgICAgPyBmYXN0SW50ZXJwb2xhdGUoaW5wdXQsIG1peGVycylcbiAgICAgICAgOiBzbG93SW50ZXJwb2xhdGUoaW5wdXQsIG1peGVycyk7XG4gICAgcmV0dXJuIGlzQ2xhbXBcbiAgICAgICAgPyAodikgPT4gaW50ZXJwb2xhdG9yKGNsYW1wKGlucHV0WzBdLCBpbnB1dFtpbnB1dExlbmd0aCAtIDFdLCB2KSlcbiAgICAgICAgOiBpbnRlcnBvbGF0b3I7XG59XG5cbmNvbnN0IHJldmVyc2VFYXNpbmcgPSBlYXNpbmcgPT4gcCA9PiAxIC0gZWFzaW5nKDEgLSBwKTtcbmNvbnN0IG1pcnJvckVhc2luZyA9IGVhc2luZyA9PiBwID0+IHAgPD0gMC41ID8gZWFzaW5nKDIgKiBwKSAvIDIgOiAoMiAtIGVhc2luZygyICogKDEgLSBwKSkpIC8gMjtcbmNvbnN0IGNyZWF0ZUV4cG9JbiA9IChwb3dlcikgPT4gcCA9PiBNYXRoLnBvdyhwLCBwb3dlcik7XG5jb25zdCBjcmVhdGVCYWNrSW4gPSAocG93ZXIpID0+IHAgPT4gcCAqIHAgKiAoKHBvd2VyICsgMSkgKiBwIC0gcG93ZXIpO1xuY29uc3QgY3JlYXRlQW50aWNpcGF0ZSA9IChwb3dlcikgPT4ge1xuICAgIGNvbnN0IGJhY2tFYXNpbmcgPSBjcmVhdGVCYWNrSW4ocG93ZXIpO1xuICAgIHJldHVybiBwID0+IChwICo9IDIpIDwgMVxuICAgICAgICA/IDAuNSAqIGJhY2tFYXNpbmcocClcbiAgICAgICAgOiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqIChwIC0gMSkpKTtcbn07XG5cbmNvbnN0IERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIID0gMS41MjU7XG5jb25zdCBCT1VOQ0VfRklSU1RfVEhSRVNIT0xEID0gNC4wIC8gMTEuMDtcbmNvbnN0IEJPVU5DRV9TRUNPTkRfVEhSRVNIT0xEID0gOC4wIC8gMTEuMDtcbmNvbnN0IEJPVU5DRV9USElSRF9USFJFU0hPTEQgPSA5LjAgLyAxMC4wO1xuY29uc3QgbGluZWFyID0gcCA9PiBwO1xuY29uc3QgZWFzZUluID0gY3JlYXRlRXhwb0luKDIpO1xuY29uc3QgZWFzZU91dCA9IHJldmVyc2VFYXNpbmcoZWFzZUluKTtcbmNvbnN0IGVhc2VJbk91dCA9IG1pcnJvckVhc2luZyhlYXNlSW4pO1xuY29uc3QgY2lyY0luID0gcCA9PiAxIC0gTWF0aC5zaW4oTWF0aC5hY29zKHApKTtcbmNvbnN0IGNpcmNPdXQgPSByZXZlcnNlRWFzaW5nKGNpcmNJbik7XG5jb25zdCBjaXJjSW5PdXQgPSBtaXJyb3JFYXNpbmcoY2lyY091dCk7XG5jb25zdCBiYWNrSW4gPSBjcmVhdGVCYWNrSW4oREVGQVVMVF9PVkVSU0hPT1RfU1RSRU5HVEgpO1xuY29uc3QgYmFja091dCA9IHJldmVyc2VFYXNpbmcoYmFja0luKTtcbmNvbnN0IGJhY2tJbk91dCA9IG1pcnJvckVhc2luZyhiYWNrSW4pO1xuY29uc3QgYW50aWNpcGF0ZSA9IGNyZWF0ZUFudGljaXBhdGUoREVGQVVMVF9PVkVSU0hPT1RfU1RSRU5HVEgpO1xuY29uc3QgY2EgPSA0MzU2LjAgLyAzNjEuMDtcbmNvbnN0IGNiID0gMzU0NDIuMCAvIDE4MDUuMDtcbmNvbnN0IGNjID0gMTYwNjEuMCAvIDE4MDUuMDtcbmNvbnN0IGJvdW5jZU91dCA9IChwKSA9PiB7XG4gICAgaWYgKHAgPT09IDEgfHwgcCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgY29uc3QgcDIgPSBwICogcDtcbiAgICByZXR1cm4gcCA8IEJPVU5DRV9GSVJTVF9USFJFU0hPTERcbiAgICAgICAgPyA3LjU2MjUgKiBwMlxuICAgICAgICA6IHAgPCBCT1VOQ0VfU0VDT05EX1RIUkVTSE9MRFxuICAgICAgICAgICAgPyA5LjA3NSAqIHAyIC0gOS45ICogcCArIDMuNFxuICAgICAgICAgICAgOiBwIDwgQk9VTkNFX1RISVJEX1RIUkVTSE9MRFxuICAgICAgICAgICAgICAgID8gY2EgKiBwMiAtIGNiICogcCArIGNjXG4gICAgICAgICAgICAgICAgOiAxMC44ICogcCAqIHAgLSAyMC41MiAqIHAgKyAxMC43Mjtcbn07XG5jb25zdCBib3VuY2VJbiA9IHJldmVyc2VFYXNpbmcoYm91bmNlT3V0KTtcbmNvbnN0IGJvdW5jZUluT3V0ID0gKHApID0+IHAgPCAwLjVcbiAgICA/IDAuNSAqICgxLjAgLSBib3VuY2VPdXQoMS4wIC0gcCAqIDIuMCkpXG4gICAgOiAwLjUgKiBib3VuY2VPdXQocCAqIDIuMCAtIDEuMCkgKyAwLjU7XG5cbmZ1bmN0aW9uIGRlZmF1bHRFYXNpbmcodmFsdWVzLCBlYXNpbmcpIHtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCgoKSA9PiBlYXNpbmcgfHwgZWFzZUluT3V0KS5zcGxpY2UoMCwgdmFsdWVzLmxlbmd0aCAtIDEpO1xufVxuZnVuY3Rpb24gZGVmYXVsdE9mZnNldCh2YWx1ZXMpIHtcbiAgICBjb25zdCBudW1WYWx1ZXMgPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHJldHVybiB2YWx1ZXMubWFwKChfdmFsdWUsIGkpID0+IGkgIT09IDAgPyBpIC8gKG51bVZhbHVlcyAtIDEpIDogMCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0VG9UaW1lcyhvZmZzZXQsIGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG9mZnNldC5tYXAoKG8pID0+IG8gKiBkdXJhdGlvbik7XG59XG5mdW5jdGlvbiBrZXlmcmFtZXMoeyBmcm9tID0gMCwgdG8gPSAxLCBlYXNlLCBvZmZzZXQsIGR1cmF0aW9uID0gMzAwLCB9KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogZnJvbSB9O1xuICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkodG8pID8gdG8gOiBbZnJvbSwgdG9dO1xuICAgIGNvbnN0IHRpbWVzID0gY29udmVydE9mZnNldFRvVGltZXMob2Zmc2V0ICYmIG9mZnNldC5sZW5ndGggPT09IHZhbHVlcy5sZW5ndGhcbiAgICAgICAgPyBvZmZzZXRcbiAgICAgICAgOiBkZWZhdWx0T2Zmc2V0KHZhbHVlcyksIGR1cmF0aW9uKTtcbiAgICBmdW5jdGlvbiBjcmVhdGVJbnRlcnBvbGF0b3IoKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZSh0aW1lcywgdmFsdWVzLCB7XG4gICAgICAgICAgICBlYXNlOiBBcnJheS5pc0FycmF5KGVhc2UpID8gZWFzZSA6IGRlZmF1bHRFYXNpbmcodmFsdWVzLCBlYXNlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBpbnRlcnBvbGF0b3IgPSBjcmVhdGVJbnRlcnBvbGF0b3IoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiAodCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUudmFsdWUgPSBpbnRlcnBvbGF0b3IodCk7XG4gICAgICAgICAgICBzdGF0ZS5kb25lID0gdCA+PSBkdXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxpcFRhcmdldDogKCkgPT4ge1xuICAgICAgICAgICAgdmFsdWVzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGludGVycG9sYXRvciA9IGNyZWF0ZUludGVycG9sYXRvcigpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGRlY2F5KHsgdmVsb2NpdHkgPSAwLCBmcm9tID0gMCwgcG93ZXIgPSAwLjgsIHRpbWVDb25zdGFudCA9IDM1MCwgcmVzdERlbHRhID0gMC41LCBtb2RpZnlUYXJnZXQsIH0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBmcm9tIH07XG4gICAgbGV0IGFtcGxpdHVkZSA9IHBvd2VyICogdmVsb2NpdHk7XG4gICAgY29uc3QgaWRlYWwgPSBmcm9tICsgYW1wbGl0dWRlO1xuICAgIGNvbnN0IHRhcmdldCA9IG1vZGlmeVRhcmdldCA9PT0gdW5kZWZpbmVkID8gaWRlYWwgOiBtb2RpZnlUYXJnZXQoaWRlYWwpO1xuICAgIGlmICh0YXJnZXQgIT09IGlkZWFsKVxuICAgICAgICBhbXBsaXR1ZGUgPSB0YXJnZXQgLSBmcm9tO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6ICh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IC1hbXBsaXR1ZGUgKiBNYXRoLmV4cCgtdCAvIHRpbWVDb25zdGFudCk7XG4gICAgICAgICAgICBzdGF0ZS5kb25lID0gIShkZWx0YSA+IHJlc3REZWx0YSB8fCBkZWx0YSA8IC1yZXN0RGVsdGEpO1xuICAgICAgICAgICAgc3RhdGUudmFsdWUgPSBzdGF0ZS5kb25lID8gdGFyZ2V0IDogdGFyZ2V0ICsgZGVsdGE7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGZsaXBUYXJnZXQ6ICgpID0+IHsgfSxcbiAgICB9O1xufVxuXG5jb25zdCB0eXBlcyA9IHsga2V5ZnJhbWVzLCBzcHJpbmcsIGRlY2F5IH07XG5mdW5jdGlvbiBkZXRlY3RBbmltYXRpb25Gcm9tT3B0aW9ucyhjb25maWcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcudG8pKSB7XG4gICAgICAgIHJldHVybiBrZXlmcmFtZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVzW2NvbmZpZy50eXBlXSkge1xuICAgICAgICByZXR1cm4gdHlwZXNbY29uZmlnLnR5cGVdO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhjb25maWcpKTtcbiAgICBpZiAoa2V5cy5oYXMoXCJlYXNlXCIpIHx8XG4gICAgICAgIChrZXlzLmhhcyhcImR1cmF0aW9uXCIpICYmICFrZXlzLmhhcyhcImRhbXBpbmdSYXRpb1wiKSkpIHtcbiAgICAgICAgcmV0dXJuIGtleWZyYW1lcztcbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5cy5oYXMoXCJkYW1waW5nUmF0aW9cIikgfHxcbiAgICAgICAga2V5cy5oYXMoXCJzdGlmZm5lc3NcIikgfHxcbiAgICAgICAga2V5cy5oYXMoXCJtYXNzXCIpIHx8XG4gICAgICAgIGtleXMuaGFzKFwiZGFtcGluZ1wiKSB8fFxuICAgICAgICBrZXlzLmhhcyhcInJlc3RTcGVlZFwiKSB8fFxuICAgICAgICBrZXlzLmhhcyhcInJlc3REZWx0YVwiKSkge1xuICAgICAgICByZXR1cm4gc3ByaW5nO1xuICAgIH1cbiAgICByZXR1cm4ga2V5ZnJhbWVzO1xufVxuXG5mdW5jdGlvbiBsb29wRWxhcHNlZChlbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkgPSAwKSB7XG4gICAgcmV0dXJuIGVsYXBzZWQgLSBkdXJhdGlvbiAtIGRlbGF5O1xufVxuZnVuY3Rpb24gcmV2ZXJzZUVsYXBzZWQoZWxhcHNlZCwgZHVyYXRpb24sIGRlbGF5ID0gMCwgaXNGb3J3YXJkUGxheWJhY2sgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGlzRm9yd2FyZFBsYXliYWNrXG4gICAgICAgID8gbG9vcEVsYXBzZWQoZHVyYXRpb24gKyAtZWxhcHNlZCwgZHVyYXRpb24sIGRlbGF5KVxuICAgICAgICA6IGR1cmF0aW9uIC0gKGVsYXBzZWQgLSBkdXJhdGlvbikgKyBkZWxheTtcbn1cbmZ1bmN0aW9uIGhhc1JlcGVhdERlbGF5RWxhcHNlZChlbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXksIGlzRm9yd2FyZFBsYXliYWNrKSB7XG4gICAgcmV0dXJuIGlzRm9yd2FyZFBsYXliYWNrID8gZWxhcHNlZCA+PSBkdXJhdGlvbiArIGRlbGF5IDogZWxhcHNlZCA8PSAtZGVsYXk7XG59XG5cbmNvbnN0IGZyYW1lc3luYyA9ICh1cGRhdGUpID0+IHtcbiAgICBjb25zdCBwYXNzVGltZXN0YW1wID0gKHsgZGVsdGEgfSkgPT4gdXBkYXRlKGRlbHRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogKCkgPT4gc3luY19fZGVmYXVsdFtcImRlZmF1bHRcIl0udXBkYXRlKHBhc3NUaW1lc3RhbXAsIHRydWUpLFxuICAgICAgICBzdG9wOiAoKSA9PiBzeW5jLmNhbmNlbFN5bmMudXBkYXRlKHBhc3NUaW1lc3RhbXApLFxuICAgIH07XG59O1xuZnVuY3Rpb24gYW5pbWF0ZShfYSkge1xuICAgIHZhciBfYiwgX2M7XG4gICAgdmFyIHsgZnJvbSwgYXV0b3BsYXkgPSB0cnVlLCBkcml2ZXIgPSBmcmFtZXN5bmMsIGVsYXBzZWQgPSAwLCByZXBlYXQ6IHJlcGVhdE1heCA9IDAsIHJlcGVhdFR5cGUgPSBcImxvb3BcIiwgcmVwZWF0RGVsYXkgPSAwLCBvblBsYXksIG9uU3RvcCwgb25Db21wbGV0ZSwgb25SZXBlYXQsIG9uVXBkYXRlIH0gPSBfYSwgb3B0aW9ucyA9IHRzbGliLl9fcmVzdChfYSwgW1wiZnJvbVwiLCBcImF1dG9wbGF5XCIsIFwiZHJpdmVyXCIsIFwiZWxhcHNlZFwiLCBcInJlcGVhdFwiLCBcInJlcGVhdFR5cGVcIiwgXCJyZXBlYXREZWxheVwiLCBcIm9uUGxheVwiLCBcIm9uU3RvcFwiLCBcIm9uQ29tcGxldGVcIiwgXCJvblJlcGVhdFwiLCBcIm9uVXBkYXRlXCJdKTtcbiAgICBsZXQgeyB0byB9ID0gb3B0aW9ucztcbiAgICBsZXQgZHJpdmVyQ29udHJvbHM7XG4gICAgbGV0IHJlcGVhdENvdW50ID0gMDtcbiAgICBsZXQgY29tcHV0ZWREdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG4gICAgbGV0IGxhdGVzdDtcbiAgICBsZXQgaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIGxldCBpc0ZvcndhcmRQbGF5YmFjayA9IHRydWU7XG4gICAgbGV0IGludGVycG9sYXRlRnJvbU51bWJlcjtcbiAgICBjb25zdCBhbmltYXRvciA9IGRldGVjdEFuaW1hdGlvbkZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgIGlmICgoX2MgPSAoX2IgPSBhbmltYXRvcikubmVlZHNJbnRlcnBvbGF0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgZnJvbSwgdG8pKSB7XG4gICAgICAgIGludGVycG9sYXRlRnJvbU51bWJlciA9IGludGVycG9sYXRlKFswLCAxMDBdLCBbZnJvbSwgdG9dLCB7XG4gICAgICAgICAgICBjbGFtcDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgdG8gPSAxMDA7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbiA9IGFuaW1hdG9yKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZnJvbSwgdG8gfSkpO1xuICAgIGZ1bmN0aW9uIHJlcGVhdCgpIHtcbiAgICAgICAgcmVwZWF0Q291bnQrKztcbiAgICAgICAgaWYgKHJlcGVhdFR5cGUgPT09IFwicmV2ZXJzZVwiKSB7XG4gICAgICAgICAgICBpc0ZvcndhcmRQbGF5YmFjayA9IHJlcGVhdENvdW50ICUgMiA9PT0gMDtcbiAgICAgICAgICAgIGVsYXBzZWQgPSByZXZlcnNlRWxhcHNlZChlbGFwc2VkLCBjb21wdXRlZER1cmF0aW9uLCByZXBlYXREZWxheSwgaXNGb3J3YXJkUGxheWJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxhcHNlZCA9IGxvb3BFbGFwc2VkKGVsYXBzZWQsIGNvbXB1dGVkRHVyYXRpb24sIHJlcGVhdERlbGF5KTtcbiAgICAgICAgICAgIGlmIChyZXBlYXRUeXBlID09PSBcIm1pcnJvclwiKVxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5mbGlwVGFyZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICBvblJlcGVhdCAmJiBvblJlcGVhdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgZHJpdmVyQ29udHJvbHMuc3RvcCgpO1xuICAgICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlKGRlbHRhKSB7XG4gICAgICAgIGlmICghaXNGb3J3YXJkUGxheWJhY2spXG4gICAgICAgICAgICBkZWx0YSA9IC1kZWx0YTtcbiAgICAgICAgZWxhcHNlZCArPSBkZWx0YTtcbiAgICAgICAgaWYgKCFpc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGFuaW1hdGlvbi5uZXh0KE1hdGgubWF4KDAsIGVsYXBzZWQpKTtcbiAgICAgICAgICAgIGxhdGVzdCA9IHN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGludGVycG9sYXRlRnJvbU51bWJlcilcbiAgICAgICAgICAgICAgICBsYXRlc3QgPSBpbnRlcnBvbGF0ZUZyb21OdW1iZXIobGF0ZXN0KTtcbiAgICAgICAgICAgIGlzQ29tcGxldGUgPSBpc0ZvcndhcmRQbGF5YmFjayA/IHN0YXRlLmRvbmUgOiBlbGFwc2VkIDw9IDA7XG4gICAgICAgIH1cbiAgICAgICAgb25VcGRhdGUgPT09IG51bGwgfHwgb25VcGRhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVXBkYXRlKGxhdGVzdCk7XG4gICAgICAgIGlmIChpc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICBpZiAocmVwZWF0Q291bnQgPT09IDApXG4gICAgICAgICAgICAgICAgY29tcHV0ZWREdXJhdGlvbiAhPT0gbnVsbCAmJiBjb21wdXRlZER1cmF0aW9uICE9PSB2b2lkIDAgPyBjb21wdXRlZER1cmF0aW9uIDogKGNvbXB1dGVkRHVyYXRpb24gPSBlbGFwc2VkKTtcbiAgICAgICAgICAgIGlmIChyZXBlYXRDb3VudCA8IHJlcGVhdE1heCkge1xuICAgICAgICAgICAgICAgIGhhc1JlcGVhdERlbGF5RWxhcHNlZChlbGFwc2VkLCBjb21wdXRlZER1cmF0aW9uLCByZXBlYXREZWxheSwgaXNGb3J3YXJkUGxheWJhY2spICYmIHJlcGVhdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgICBvblBsYXkgPT09IG51bGwgfHwgb25QbGF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblBsYXkoKTtcbiAgICAgICAgZHJpdmVyQ29udHJvbHMgPSBkcml2ZXIodXBkYXRlKTtcbiAgICAgICAgZHJpdmVyQ29udHJvbHMuc3RhcnQoKTtcbiAgICB9XG4gICAgYXV0b3BsYXkgJiYgcGxheSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0b3A6ICgpID0+IHtcbiAgICAgICAgICAgIG9uU3RvcCA9PT0gbnVsbCB8fCBvblN0b3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uU3RvcCgpO1xuICAgICAgICAgICAgZHJpdmVyQ29udHJvbHMuc3RvcCgpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHZlbG9jaXR5UGVyU2Vjb25kKHZlbG9jaXR5LCBmcmFtZUR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIGZyYW1lRHVyYXRpb24gPyB2ZWxvY2l0eSAqICgxMDAwIC8gZnJhbWVEdXJhdGlvbikgOiAwO1xufVxuXG5mdW5jdGlvbiBpbmVydGlhKHsgZnJvbSA9IDAsIHZlbG9jaXR5ID0gMCwgbWluLCBtYXgsIHBvd2VyID0gMC44LCB0aW1lQ29uc3RhbnQgPSA3NTAsIGJvdW5jZVN0aWZmbmVzcyA9IDUwMCwgYm91bmNlRGFtcGluZyA9IDEwLCByZXN0RGVsdGEgPSAxLCBtb2RpZnlUYXJnZXQsIGRyaXZlciwgb25VcGRhdGUsIG9uQ29tcGxldGUsIG9uU3RvcCwgfSkge1xuICAgIGxldCBjdXJyZW50QW5pbWF0aW9uO1xuICAgIGZ1bmN0aW9uIGlzT3V0T2ZCb3VuZHModikge1xuICAgICAgICByZXR1cm4gKG1pbiAhPT0gdW5kZWZpbmVkICYmIHYgPCBtaW4pIHx8IChtYXggIT09IHVuZGVmaW5lZCAmJiB2ID4gbWF4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm91bmRhcnlOZWFyZXN0KHYpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKG1pbiAtIHYpIDwgTWF0aC5hYnMobWF4IC0gdikgPyBtaW4gOiBtYXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgY3VycmVudEFuaW1hdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50QW5pbWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50QW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgICAgY3VycmVudEFuaW1hdGlvbiA9IGFuaW1hdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBkcml2ZXIsIG9uVXBkYXRlOiAodikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBvblVwZGF0ZSA9PT0gbnVsbCB8fCBvblVwZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25VcGRhdGUodik7XG4gICAgICAgICAgICAgICAgKF9hID0gb3B0aW9ucy5vblVwZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgdik7XG4gICAgICAgICAgICB9LCBvbkNvbXBsZXRlLFxuICAgICAgICAgICAgb25TdG9wIH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRTcHJpbmcob3B0aW9ucykge1xuICAgICAgICBzdGFydEFuaW1hdGlvbihPYmplY3QuYXNzaWduKHsgdHlwZTogXCJzcHJpbmdcIiwgc3RpZmZuZXNzOiBib3VuY2VTdGlmZm5lc3MsIGRhbXBpbmc6IGJvdW5jZURhbXBpbmcsIHJlc3REZWx0YSB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChpc091dE9mQm91bmRzKGZyb20pKSB7XG4gICAgICAgIHN0YXJ0U3ByaW5nKHsgZnJvbSwgdmVsb2NpdHksIHRvOiBib3VuZGFyeU5lYXJlc3QoZnJvbSkgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgdGFyZ2V0ID0gcG93ZXIgKiB2ZWxvY2l0eSArIGZyb207XG4gICAgICAgIGlmICh0eXBlb2YgbW9kaWZ5VGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgdGFyZ2V0ID0gbW9kaWZ5VGFyZ2V0KHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGJvdW5kYXJ5ID0gYm91bmRhcnlOZWFyZXN0KHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGhlYWRpbmcgPSBib3VuZGFyeSA9PT0gbWluID8gLTEgOiAxO1xuICAgICAgICBsZXQgcHJldjtcbiAgICAgICAgbGV0IGN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IGNoZWNrQm91bmRhcnkgPSAodikgPT4ge1xuICAgICAgICAgICAgcHJldiA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBjdXJyZW50ID0gdjtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gdmVsb2NpdHlQZXJTZWNvbmQodiAtIHByZXYsIHN5bmMuZ2V0RnJhbWVEYXRhKCkuZGVsdGEpO1xuICAgICAgICAgICAgaWYgKChoZWFkaW5nID09PSAxICYmIHYgPiBib3VuZGFyeSkgfHxcbiAgICAgICAgICAgICAgICAoaGVhZGluZyA9PT0gLTEgJiYgdiA8IGJvdW5kYXJ5KSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0U3ByaW5nKHsgZnJvbTogdiwgdG86IGJvdW5kYXJ5LCB2ZWxvY2l0eSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc3RhcnRBbmltYXRpb24oe1xuICAgICAgICAgICAgdHlwZTogXCJkZWNheVwiLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHZlbG9jaXR5LFxuICAgICAgICAgICAgdGltZUNvbnN0YW50LFxuICAgICAgICAgICAgcG93ZXIsXG4gICAgICAgICAgICByZXN0RGVsdGEsXG4gICAgICAgICAgICBtb2RpZnlUYXJnZXQsXG4gICAgICAgICAgICBvblVwZGF0ZTogaXNPdXRPZkJvdW5kcyh0YXJnZXQpID8gY2hlY2tCb3VuZGFyeSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0b3A6ICgpID0+IGN1cnJlbnRBbmltYXRpb24gPT09IG51bGwgfHwgY3VycmVudEFuaW1hdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEFuaW1hdGlvbi5zdG9wKCksXG4gICAgfTtcbn1cblxuY29uc3QgcmFkaWFuc1RvRGVncmVlcyA9IChyYWRpYW5zKSA9PiAocmFkaWFucyAqIDE4MCkgLyBNYXRoLlBJO1xuXG5jb25zdCBhbmdsZSA9IChhLCBiID0gemVyb1BvaW50KSA9PiByYWRpYW5zVG9EZWdyZWVzKE1hdGguYXRhbjIoYi55IC0gYS55LCBiLnggLSBhLngpKTtcblxuY29uc3QgYXBwbHlPZmZzZXQgPSAoZnJvbSwgdG8pID0+IHtcbiAgICBsZXQgaGFzUmVjZWl2ZWRGcm9tID0gdHJ1ZTtcbiAgICBpZiAodG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0byA9IGZyb207XG4gICAgICAgIGhhc1JlY2VpdmVkRnJvbSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgICAgaWYgKGhhc1JlY2VpdmVkRnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIHYgLSBmcm9tICsgdG87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gdjtcbiAgICAgICAgICAgIGhhc1JlY2VpdmVkRnJvbSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdG87XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuY29uc3QgaWRlbnRpdHkgPSAodikgPT4gdjtcbmNvbnN0IGNyZWF0ZUF0dHJhY3RvciA9IChhbHRlckRpc3BsYWNlbWVudCA9IGlkZW50aXR5KSA9PiAoY29uc3RhbnQsIG9yaWdpbiwgdikgPT4ge1xuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IG9yaWdpbiAtIHY7XG4gICAgY29uc3Qgc3ByaW5nTW9kaWZpZWREaXNwbGFjZW1lbnQgPSAtKDAgLSBjb25zdGFudCArIDEpICogKDAgLSBhbHRlckRpc3BsYWNlbWVudChNYXRoLmFicyhkaXNwbGFjZW1lbnQpKSk7XG4gICAgcmV0dXJuIGRpc3BsYWNlbWVudCA8PSAwXG4gICAgICAgID8gb3JpZ2luICsgc3ByaW5nTW9kaWZpZWREaXNwbGFjZW1lbnRcbiAgICAgICAgOiBvcmlnaW4gLSBzcHJpbmdNb2RpZmllZERpc3BsYWNlbWVudDtcbn07XG5jb25zdCBhdHRyYWN0ID0gY3JlYXRlQXR0cmFjdG9yKCk7XG5jb25zdCBhdHRyYWN0RXhwbyA9IGNyZWF0ZUF0dHJhY3RvcihNYXRoLnNxcnQpO1xuXG5jb25zdCBkZWdyZWVzVG9SYWRpYW5zID0gKGRlZ3JlZXMpID0+IChkZWdyZWVzICogTWF0aC5QSSkgLyAxODA7XG5cbmNvbnN0IGlzUG9pbnQgPSAocG9pbnQpID0+IHBvaW50Lmhhc093blByb3BlcnR5KCd4JykgJiYgcG9pbnQuaGFzT3duUHJvcGVydHkoJ3knKTtcblxuY29uc3QgaXNQb2ludDNEID0gKHBvaW50KSA9PiBpc1BvaW50KHBvaW50KSAmJiBwb2ludC5oYXNPd25Qcm9wZXJ0eSgneicpO1xuXG5jb25zdCBkaXN0YW5jZTFEID0gKGEsIGIpID0+IE1hdGguYWJzKGEgLSBiKTtcbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgICBpZiAoaXNOdW0oYSkgJiYgaXNOdW0oYikpIHtcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlMUQoYSwgYik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUG9pbnQoYSkgJiYgaXNQb2ludChiKSkge1xuICAgICAgICBjb25zdCB4RGVsdGEgPSBkaXN0YW5jZTFEKGEueCwgYi54KTtcbiAgICAgICAgY29uc3QgeURlbHRhID0gZGlzdGFuY2UxRChhLnksIGIueSk7XG4gICAgICAgIGNvbnN0IHpEZWx0YSA9IGlzUG9pbnQzRChhKSAmJiBpc1BvaW50M0QoYikgPyBkaXN0YW5jZTFEKGEueiwgYi56KSA6IDA7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeERlbHRhLCAyKSArIE1hdGgucG93KHlEZWx0YSwgMikgKyBNYXRoLnBvdyh6RGVsdGEsIDIpKTtcbiAgICB9XG59XG5cbmNvbnN0IHBvaW50RnJvbVZlY3RvciA9IChvcmlnaW4sIGFuZ2xlLCBkaXN0YW5jZSkgPT4ge1xuICAgIGFuZ2xlID0gZGVncmVlc1RvUmFkaWFucyhhbmdsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZGlzdGFuY2UgKiBNYXRoLmNvcyhhbmdsZSkgKyBvcmlnaW4ueCxcbiAgICAgICAgeTogZGlzdGFuY2UgKiBNYXRoLnNpbihhbmdsZSkgKyBvcmlnaW4ueVxuICAgIH07XG59O1xuXG5jb25zdCB0b0RlY2ltYWwgPSAobnVtLCBwcmVjaXNpb24gPSAyKSA9PiB7XG4gICAgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobnVtICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbn07XG5cbmNvbnN0IHNtb290aEZyYW1lID0gKHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBkdXJhdGlvbiwgc21vb3RoaW5nID0gMCkgPT4gdG9EZWNpbWFsKHByZXZWYWx1ZSArXG4gICAgKGR1cmF0aW9uICogKG5leHRWYWx1ZSAtIHByZXZWYWx1ZSkpIC8gTWF0aC5tYXgoc21vb3RoaW5nLCBkdXJhdGlvbikpO1xuXG5jb25zdCBzbW9vdGggPSAoc3RyZW5ndGggPSA1MCkgPT4ge1xuICAgIGxldCBwcmV2aW91c1ZhbHVlID0gMDtcbiAgICBsZXQgbGFzdFVwZGF0ZWQgPSAwO1xuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50RnJhbWVzdGFtcCA9IHN5bmMuZ2V0RnJhbWVEYXRhKCkudGltZXN0YW1wO1xuICAgICAgICBjb25zdCB0aW1lRGVsdGEgPSBjdXJyZW50RnJhbWVzdGFtcCAhPT0gbGFzdFVwZGF0ZWQgPyBjdXJyZW50RnJhbWVzdGFtcCAtIGxhc3RVcGRhdGVkIDogMDtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aW1lRGVsdGFcbiAgICAgICAgICAgID8gc21vb3RoRnJhbWUocHJldmlvdXNWYWx1ZSwgdiwgdGltZURlbHRhLCBzdHJlbmd0aClcbiAgICAgICAgICAgIDogcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgbGFzdFVwZGF0ZWQgPSBjdXJyZW50RnJhbWVzdGFtcDtcbiAgICAgICAgcHJldmlvdXNWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgfTtcbn07XG5cbmNvbnN0IHNuYXAgPSAocG9pbnRzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwb2ludHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiAodikgPT4gTWF0aC5yb3VuZCh2IC8gcG9pbnRzKSAqIHBvaW50cztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICAgICAgICBsZXQgbGFzdERpc3RhbmNlID0gTWF0aC5hYnMocG9pbnRzWzBdIC0gdik7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguYWJzKHBvaW50IC0gdik7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gbGFzdERpc3RhbmNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbnVtUG9pbnRzIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICAgICAgICAgIGxhc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHZlbG9jaXR5UGVyRnJhbWUoeHBzLCBmcmFtZUR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHhwcyAvICgxMDAwIC8gZnJhbWVEdXJhdGlvbik7XG59XG5cbmNvbnN0IHdyYXAgPSAobWluLCBtYXgsIHYpID0+IHtcbiAgICBjb25zdCByYW5nZVNpemUgPSBtYXggLSBtaW47XG4gICAgcmV0dXJuICgoKCh2IC0gbWluKSAlIHJhbmdlU2l6ZSkgKyByYW5nZVNpemUpICUgcmFuZ2VTaXplKSArIG1pbjtcbn07XG5cbmNvbnN0IGEgPSAoYTEsIGEyKSA9PiAxLjAgLSAzLjAgKiBhMiArIDMuMCAqIGExO1xuY29uc3QgYiA9IChhMSwgYTIpID0+IDMuMCAqIGEyIC0gNi4wICogYTE7XG5jb25zdCBjID0gKGExKSA9PiAzLjAgKiBhMTtcbmNvbnN0IGNhbGNCZXppZXIgPSAodCwgYTEsIGEyKSA9PiAoKGEoYTEsIGEyKSAqIHQgKyBiKGExLCBhMikpICogdCArIGMoYTEpKSAqIHQ7XG5jb25zdCBnZXRTbG9wZSA9ICh0LCBhMSwgYTIpID0+IDMuMCAqIGEoYTEsIGEyKSAqIHQgKiB0ICsgMi4wICogYihhMSwgYTIpICogdCArIGMoYTEpO1xuY29uc3Qgc3ViZGl2aXNpb25QcmVjaXNpb24gPSAwLjAwMDAwMDE7XG5jb25zdCBzdWJkaXZpc2lvbk1heEl0ZXJhdGlvbnMgPSAxMDtcbmZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZShhWCwgYUEsIGFCLCBtWDEsIG1YMikge1xuICAgIGxldCBjdXJyZW50WDtcbiAgICBsZXQgY3VycmVudFQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIGRvIHtcbiAgICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XG4gICAgICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IHN1YmRpdmlzaW9uUHJlY2lzaW9uICYmXG4gICAgICAgICsraSA8IHN1YmRpdmlzaW9uTWF4SXRlcmF0aW9ucyk7XG4gICAgcmV0dXJuIGN1cnJlbnRUO1xufVxuY29uc3QgbmV3dG9uSXRlcmF0aW9ucyA9IDg7XG5jb25zdCBuZXd0b25NaW5TbG9wZSA9IDAuMDAxO1xuZnVuY3Rpb24gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGFHdWVzc1QsIG1YMSwgbVgyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXd0b25JdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgICB9XG4gICAgcmV0dXJuIGFHdWVzc1Q7XG59XG5jb25zdCBrU3BsaW5lVGFibGVTaXplID0gMTE7XG5jb25zdCBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCk7XG5mdW5jdGlvbiBjdWJpY0JlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpXG4gICAgICAgIHJldHVybiBsaW5lYXI7XG4gICAgY29uc3Qgc2FtcGxlVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgICAgICBzYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcbiAgICAgICAgbGV0IGludGVydmFsU3RhcnQgPSAwLjA7XG4gICAgICAgIGxldCBjdXJyZW50U2FtcGxlID0gMTtcbiAgICAgICAgY29uc3QgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuICAgICAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLS1jdXJyZW50U2FtcGxlO1xuICAgICAgICBjb25zdCBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvXG4gICAgICAgICAgICAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgICAgIGNvbnN0IGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplO1xuICAgICAgICBjb25zdCBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICAgICAgaWYgKGluaXRpYWxTbG9wZSA+PSBuZXd0b25NaW5TbG9wZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHQpID0+IHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiBjYWxjQmV6aWVyKGdldFRGb3JYKHQpLCBtWTEsIG1ZMik7XG59XG5cbmNvbnN0IHN0ZXBzID0gKHN0ZXBzLCBkaXJlY3Rpb24gPSAnZW5kJykgPT4gKHByb2dyZXNzKSA9PiB7XG4gICAgcHJvZ3Jlc3MgPVxuICAgICAgICBkaXJlY3Rpb24gPT09ICdlbmQnID8gTWF0aC5taW4ocHJvZ3Jlc3MsIDAuOTk5KSA6IE1hdGgubWF4KHByb2dyZXNzLCAwLjAwMSk7XG4gICAgY29uc3QgZXhwYW5kZWQgPSBwcm9ncmVzcyAqIHN0ZXBzO1xuICAgIGNvbnN0IHJvdW5kZWQgPSBkaXJlY3Rpb24gPT09ICdlbmQnID8gTWF0aC5mbG9vcihleHBhbmRlZCkgOiBNYXRoLmNlaWwoZXhwYW5kZWQpO1xuICAgIHJldHVybiBjbGFtcCgwLCAxLCByb3VuZGVkIC8gc3RlcHMpO1xufTtcblxuZXhwb3J0cy5hbmdsZSA9IGFuZ2xlO1xuZXhwb3J0cy5hbmltYXRlID0gYW5pbWF0ZTtcbmV4cG9ydHMuYW50aWNpcGF0ZSA9IGFudGljaXBhdGU7XG5leHBvcnRzLmFwcGx5T2Zmc2V0ID0gYXBwbHlPZmZzZXQ7XG5leHBvcnRzLmF0dHJhY3QgPSBhdHRyYWN0O1xuZXhwb3J0cy5hdHRyYWN0RXhwbyA9IGF0dHJhY3RFeHBvO1xuZXhwb3J0cy5iYWNrSW4gPSBiYWNrSW47XG5leHBvcnRzLmJhY2tJbk91dCA9IGJhY2tJbk91dDtcbmV4cG9ydHMuYmFja091dCA9IGJhY2tPdXQ7XG5leHBvcnRzLmJvdW5jZUluID0gYm91bmNlSW47XG5leHBvcnRzLmJvdW5jZUluT3V0ID0gYm91bmNlSW5PdXQ7XG5leHBvcnRzLmJvdW5jZU91dCA9IGJvdW5jZU91dDtcbmV4cG9ydHMuY2lyY0luID0gY2lyY0luO1xuZXhwb3J0cy5jaXJjSW5PdXQgPSBjaXJjSW5PdXQ7XG5leHBvcnRzLmNpcmNPdXQgPSBjaXJjT3V0O1xuZXhwb3J0cy5jbGFtcCA9IGNsYW1wO1xuZXhwb3J0cy5jcmVhdGVBbnRpY2lwYXRlID0gY3JlYXRlQW50aWNpcGF0ZTtcbmV4cG9ydHMuY3JlYXRlQXR0cmFjdG9yID0gY3JlYXRlQXR0cmFjdG9yO1xuZXhwb3J0cy5jcmVhdGVCYWNrSW4gPSBjcmVhdGVCYWNrSW47XG5leHBvcnRzLmNyZWF0ZUV4cG9JbiA9IGNyZWF0ZUV4cG9JbjtcbmV4cG9ydHMuY3ViaWNCZXppZXIgPSBjdWJpY0JlemllcjtcbmV4cG9ydHMuZGVjYXkgPSBkZWNheTtcbmV4cG9ydHMuZGVncmVlc1RvUmFkaWFucyA9IGRlZ3JlZXNUb1JhZGlhbnM7XG5leHBvcnRzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLmVhc2VJbiA9IGVhc2VJbjtcbmV4cG9ydHMuZWFzZUluT3V0ID0gZWFzZUluT3V0O1xuZXhwb3J0cy5lYXNlT3V0ID0gZWFzZU91dDtcbmV4cG9ydHMuaW5lcnRpYSA9IGluZXJ0aWE7XG5leHBvcnRzLmludGVycG9sYXRlID0gaW50ZXJwb2xhdGU7XG5leHBvcnRzLmlzUG9pbnQgPSBpc1BvaW50O1xuZXhwb3J0cy5pc1BvaW50M0QgPSBpc1BvaW50M0Q7XG5leHBvcnRzLmtleWZyYW1lcyA9IGtleWZyYW1lcztcbmV4cG9ydHMubGluZWFyID0gbGluZWFyO1xuZXhwb3J0cy5taXJyb3JFYXNpbmcgPSBtaXJyb3JFYXNpbmc7XG5leHBvcnRzLm1peCA9IG1peDtcbmV4cG9ydHMubWl4Q29sb3IgPSBtaXhDb2xvcjtcbmV4cG9ydHMubWl4Q29tcGxleCA9IG1peENvbXBsZXg7XG5leHBvcnRzLnBpcGUgPSBwaXBlO1xuZXhwb3J0cy5wb2ludEZyb21WZWN0b3IgPSBwb2ludEZyb21WZWN0b3I7XG5leHBvcnRzLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5leHBvcnRzLnJhZGlhbnNUb0RlZ3JlZXMgPSByYWRpYW5zVG9EZWdyZWVzO1xuZXhwb3J0cy5yZXZlcnNlRWFzaW5nID0gcmV2ZXJzZUVhc2luZztcbmV4cG9ydHMuc21vb3RoID0gc21vb3RoO1xuZXhwb3J0cy5zbW9vdGhGcmFtZSA9IHNtb290aEZyYW1lO1xuZXhwb3J0cy5zbmFwID0gc25hcDtcbmV4cG9ydHMuc3ByaW5nID0gc3ByaW5nO1xuZXhwb3J0cy5zdGVwcyA9IHN0ZXBzO1xuZXhwb3J0cy50b0RlY2ltYWwgPSB0b0RlY2ltYWw7XG5leHBvcnRzLnZlbG9jaXR5UGVyRnJhbWUgPSB2ZWxvY2l0eVBlckZyYW1lO1xuZXhwb3J0cy52ZWxvY2l0eVBlclNlY29uZCA9IHZlbG9jaXR5UGVyU2Vjb25kO1xuZXhwb3J0cy53cmFwID0gd3JhcDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRzbGliIiwicmVxdWlyZSIsImhleUxpc3RlbiIsInN0eWxlVmFsdWVUeXBlcyIsInN5bmMiLCJfaW50ZXJvcERlZmF1bHRMZWdhY3kiLCJlIiwic3luY19fZGVmYXVsdCIsImNsYW1wIiwibWluIiwibWF4IiwidiIsIk1hdGgiLCJzYWZlTWluIiwibWluRHVyYXRpb24iLCJtYXhEdXJhdGlvbiIsIm1pbkRhbXBpbmciLCJtYXhEYW1waW5nIiwiZmluZFNwcmluZyIsImR1cmF0aW9uIiwiYm91bmNlIiwidmVsb2NpdHkiLCJtYXNzIiwiZW52ZWxvcGUiLCJkZXJpdmF0aXZlIiwid2FybmluZyIsImRhbXBpbmdSYXRpbyIsInVuZGFtcGVkRnJlcSIsImV4cG9uZW50aWFsRGVjYXkiLCJkZWx0YSIsImEiLCJiIiwiY2FsY0FuZ3VsYXJGcmVxIiwiYyIsImV4cCIsImQiLCJwb3ciLCJmIiwiZyIsImZhY3RvciIsImluaXRpYWxHdWVzcyIsImFwcHJveGltYXRlUm9vdCIsImlzTmFOIiwic3RpZmZuZXNzIiwiZGFtcGluZyIsInNxcnQiLCJyb290SXRlcmF0aW9ucyIsInJlc3VsdCIsImkiLCJkdXJhdGlvbktleXMiLCJwaHlzaWNzS2V5cyIsImlzU3ByaW5nVHlwZSIsIm9wdGlvbnMiLCJrZXlzIiwic29tZSIsImtleSIsInVuZGVmaW5lZCIsImdldFNwcmluZ09wdGlvbnMiLCJzcHJpbmdPcHRpb25zIiwiYXNzaWduIiwiaXNSZXNvbHZlZEZyb21EdXJhdGlvbiIsImRlcml2ZWQiLCJzcHJpbmciLCJfYSIsImZyb20iLCJ0byIsInJlc3RTcGVlZCIsInJlc3REZWx0YSIsIl9fcmVzdCIsInN0YXRlIiwiZG9uZSIsInJlc29sdmVTcHJpbmciLCJ6ZXJvIiwicmVzb2x2ZVZlbG9jaXR5IiwiY3JlYXRlU3ByaW5nIiwiaW5pdGlhbFZlbG9jaXR5IiwiaW5pdGlhbERlbHRhIiwidW5kYW1wZWRBbmd1bGFyRnJlcSIsImFicyIsImFuZ3VsYXJGcmVxIiwidCIsInNpbiIsImNvcyIsImRhbXBlZEFuZ3VsYXJGcmVxIiwiZnJlcUZvclQiLCJzaW5oIiwiY29zaCIsIm5leHQiLCJjdXJyZW50IiwiY3VycmVudFZlbG9jaXR5IiwiaXNCZWxvd1ZlbG9jaXR5VGhyZXNob2xkIiwiaXNCZWxvd0Rpc3BsYWNlbWVudFRocmVzaG9sZCIsImZsaXBUYXJnZXQiLCJuZWVkc0ludGVycG9sYXRpb24iLCJfdCIsInByb2dyZXNzIiwidG9Gcm9tRGlmZmVyZW5jZSIsIm1peCIsImh1ZVRvUmdiIiwicCIsInEiLCJoc2xhVG9SZ2JhIiwiaHVlIiwic2F0dXJhdGlvbiIsImxpZ2h0bmVzcyIsImFscGhhIiwicmVkIiwiZ3JlZW4iLCJibHVlIiwicm91bmQiLCJtaXhMaW5lYXJDb2xvciIsImZyb21FeHBvIiwidG9FeHBvIiwiY29sb3JUeXBlcyIsImhleCIsInJnYmEiLCJoc2xhIiwiZ2V0Q29sb3JUeXBlIiwiZmluZCIsInR5cGUiLCJ0ZXN0Iiwibm90QW5pbWF0YWJsZSIsImNvbG9yIiwibWl4Q29sb3IiLCJmcm9tQ29sb3JUeXBlIiwidG9Db2xvclR5cGUiLCJpbnZhcmlhbnQiLCJmcm9tQ29sb3IiLCJwYXJzZSIsInRvQ29sb3IiLCJibGVuZGVkIiwidHJhbnNmb3JtIiwiemVyb1BvaW50IiwieCIsInkiLCJ6IiwiaXNOdW0iLCJjb21iaW5lRnVuY3Rpb25zIiwicGlwZSIsInRyYW5zZm9ybWVycyIsInJlZHVjZSIsImdldE1peGVyIiwib3JpZ2luIiwidGFyZ2V0IiwibWl4Q29tcGxleCIsIm1peEFycmF5Iiwib3V0cHV0IiwibnVtVmFsdWVzIiwibGVuZ3RoIiwiYmxlbmRWYWx1ZSIsIm1hcCIsImZyb21UaGlzIiwibWl4T2JqZWN0IiwiYW5hbHlzZSIsInBhcnNlZCIsImNvbXBsZXgiLCJudW1OdW1iZXJzIiwibnVtUkdCIiwibnVtSFNMIiwidGVtcGxhdGUiLCJjcmVhdGVUcmFuc2Zvcm1lciIsIm9yaWdpblN0YXRzIiwidGFyZ2V0U3RhdHMiLCJjYW5JbnRlcnBvbGF0ZSIsIm1peE51bWJlciIsImRldGVjdE1peGVyRmFjdG9yeSIsIkFycmF5IiwiaXNBcnJheSIsImNyZWF0ZU1peGVycyIsImVhc2UiLCJjdXN0b21NaXhlciIsIm1peGVycyIsIm1peGVyRmFjdG9yeSIsIm51bU1peGVycyIsIm1peGVyIiwiZWFzaW5nRnVuY3Rpb24iLCJwdXNoIiwiZmFzdEludGVycG9sYXRlIiwic2xvd0ludGVycG9sYXRlIiwiaW5wdXQiLCJpbnB1dExlbmd0aCIsImxhc3RJbnB1dEluZGV4IiwibWl4ZXJJbmRleCIsImZvdW5kTWl4ZXJJbmRleCIsInByb2dyZXNzSW5SYW5nZSIsImludGVycG9sYXRlIiwiaXNDbGFtcCIsImNvbmNhdCIsInJldmVyc2UiLCJpbnRlcnBvbGF0b3IiLCJyZXZlcnNlRWFzaW5nIiwiZWFzaW5nIiwibWlycm9yRWFzaW5nIiwiY3JlYXRlRXhwb0luIiwicG93ZXIiLCJjcmVhdGVCYWNrSW4iLCJjcmVhdGVBbnRpY2lwYXRlIiwiYmFja0Vhc2luZyIsIkRFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIIiwiQk9VTkNFX0ZJUlNUX1RIUkVTSE9MRCIsIkJPVU5DRV9TRUNPTkRfVEhSRVNIT0xEIiwiQk9VTkNFX1RISVJEX1RIUkVTSE9MRCIsImxpbmVhciIsImVhc2VJbiIsImVhc2VPdXQiLCJlYXNlSW5PdXQiLCJjaXJjSW4iLCJhY29zIiwiY2lyY091dCIsImNpcmNJbk91dCIsImJhY2tJbiIsImJhY2tPdXQiLCJiYWNrSW5PdXQiLCJhbnRpY2lwYXRlIiwiY2EiLCJjYiIsImNjIiwiYm91bmNlT3V0IiwicDIiLCJib3VuY2VJbiIsImJvdW5jZUluT3V0IiwiZGVmYXVsdEVhc2luZyIsInZhbHVlcyIsInNwbGljZSIsImRlZmF1bHRPZmZzZXQiLCJfdmFsdWUiLCJjb252ZXJ0T2Zmc2V0VG9UaW1lcyIsIm9mZnNldCIsIm8iLCJrZXlmcmFtZXMiLCJ0aW1lcyIsImNyZWF0ZUludGVycG9sYXRvciIsImRlY2F5IiwidGltZUNvbnN0YW50IiwibW9kaWZ5VGFyZ2V0IiwiYW1wbGl0dWRlIiwiaWRlYWwiLCJ0eXBlcyIsImRldGVjdEFuaW1hdGlvbkZyb21PcHRpb25zIiwiY29uZmlnIiwiU2V0IiwiaGFzIiwibG9vcEVsYXBzZWQiLCJlbGFwc2VkIiwiZGVsYXkiLCJyZXZlcnNlRWxhcHNlZCIsImlzRm9yd2FyZFBsYXliYWNrIiwiaGFzUmVwZWF0RGVsYXlFbGFwc2VkIiwiZnJhbWVzeW5jIiwidXBkYXRlIiwicGFzc1RpbWVzdGFtcCIsInN0YXJ0Iiwic3RvcCIsImNhbmNlbFN5bmMiLCJhbmltYXRlIiwiX2IiLCJfYyIsImF1dG9wbGF5IiwiZHJpdmVyIiwicmVwZWF0IiwicmVwZWF0TWF4IiwicmVwZWF0VHlwZSIsInJlcGVhdERlbGF5Iiwib25QbGF5Iiwib25TdG9wIiwib25Db21wbGV0ZSIsIm9uUmVwZWF0Iiwib25VcGRhdGUiLCJkcml2ZXJDb250cm9scyIsInJlcGVhdENvdW50IiwiY29tcHV0ZWREdXJhdGlvbiIsImxhdGVzdCIsImlzQ29tcGxldGUiLCJpbnRlcnBvbGF0ZUZyb21OdW1iZXIiLCJhbmltYXRvciIsImNhbGwiLCJhbmltYXRpb24iLCJjb21wbGV0ZSIsInBsYXkiLCJ2ZWxvY2l0eVBlclNlY29uZCIsImZyYW1lRHVyYXRpb24iLCJpbmVydGlhIiwiYm91bmNlU3RpZmZuZXNzIiwiYm91bmNlRGFtcGluZyIsImN1cnJlbnRBbmltYXRpb24iLCJpc091dE9mQm91bmRzIiwiYm91bmRhcnlOZWFyZXN0Iiwic3RhcnRBbmltYXRpb24iLCJzdGFydFNwcmluZyIsImJvdW5kYXJ5IiwiaGVhZGluZyIsInByZXYiLCJjaGVja0JvdW5kYXJ5IiwiZ2V0RnJhbWVEYXRhIiwicmFkaWFuc1RvRGVncmVlcyIsInJhZGlhbnMiLCJQSSIsImFuZ2xlIiwiYXRhbjIiLCJhcHBseU9mZnNldCIsImhhc1JlY2VpdmVkRnJvbSIsImlkZW50aXR5IiwiY3JlYXRlQXR0cmFjdG9yIiwiYWx0ZXJEaXNwbGFjZW1lbnQiLCJjb25zdGFudCIsImRpc3BsYWNlbWVudCIsInNwcmluZ01vZGlmaWVkRGlzcGxhY2VtZW50IiwiYXR0cmFjdCIsImF0dHJhY3RFeHBvIiwiZGVncmVlc1RvUmFkaWFucyIsImRlZ3JlZXMiLCJpc1BvaW50IiwicG9pbnQiLCJoYXNPd25Qcm9wZXJ0eSIsImlzUG9pbnQzRCIsImRpc3RhbmNlMUQiLCJkaXN0YW5jZSIsInhEZWx0YSIsInlEZWx0YSIsInpEZWx0YSIsInBvaW50RnJvbVZlY3RvciIsInRvRGVjaW1hbCIsIm51bSIsInByZWNpc2lvbiIsInNtb290aEZyYW1lIiwicHJldlZhbHVlIiwibmV4dFZhbHVlIiwic21vb3RoaW5nIiwic21vb3RoIiwic3RyZW5ndGgiLCJwcmV2aW91c1ZhbHVlIiwibGFzdFVwZGF0ZWQiLCJjdXJyZW50RnJhbWVzdGFtcCIsInRpbWVzdGFtcCIsInRpbWVEZWx0YSIsIm5ld1ZhbHVlIiwic25hcCIsInBvaW50cyIsIm51bVBvaW50cyIsImxhc3REaXN0YW5jZSIsInZlbG9jaXR5UGVyRnJhbWUiLCJ4cHMiLCJ3cmFwIiwicmFuZ2VTaXplIiwiYTEiLCJhMiIsImNhbGNCZXppZXIiLCJnZXRTbG9wZSIsInN1YmRpdmlzaW9uUHJlY2lzaW9uIiwic3ViZGl2aXNpb25NYXhJdGVyYXRpb25zIiwiYmluYXJ5U3ViZGl2aWRlIiwiYVgiLCJhQSIsImFCIiwibVgxIiwibVgyIiwiY3VycmVudFgiLCJjdXJyZW50VCIsIm5ld3Rvbkl0ZXJhdGlvbnMiLCJuZXd0b25NaW5TbG9wZSIsIm5ld3RvblJhcGhzb25JdGVyYXRlIiwiYUd1ZXNzVCIsImN1cnJlbnRTbG9wZSIsImtTcGxpbmVUYWJsZVNpemUiLCJrU2FtcGxlU3RlcFNpemUiLCJjdWJpY0JlemllciIsIm1ZMSIsIm1ZMiIsInNhbXBsZVZhbHVlcyIsIkZsb2F0MzJBcnJheSIsImdldFRGb3JYIiwiaW50ZXJ2YWxTdGFydCIsImN1cnJlbnRTYW1wbGUiLCJsYXN0U2FtcGxlIiwiZGlzdCIsImd1ZXNzRm9yVCIsImluaXRpYWxTbG9wZSIsInN0ZXBzIiwiZGlyZWN0aW9uIiwiZXhwYW5kZWQiLCJyb3VuZGVkIiwiZmxvb3IiLCJjZWlsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/popmotion/dist/popmotion.cjs.js\n");

/***/ })

};
;