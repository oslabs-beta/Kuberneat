"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-stately";
exports.ids = ["vendor-chunks/@react-stately"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-stately/collections/dist/import.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@react-stately/collections/dist/import.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollectionBuilder: () => (/* binding */ $eb2240fc39a57fa5$export$bf788dd355e3a401),\n/* harmony export */   Item: () => (/* binding */ $c1d7fb2ec91bae71$export$6d08773d2e66f8f2),\n/* harmony export */   Section: () => (/* binding */ $9fc4852771d079eb$export$6e2c8f0811a474ce),\n/* harmony export */   compareNodeOrder: () => (/* binding */ $c5a24bc478652b5f$export$8c434b3a7a4dad6),\n/* harmony export */   getChildNodes: () => (/* binding */ $c5a24bc478652b5f$export$1005530eda016c13),\n/* harmony export */   getFirstItem: () => (/* binding */ $c5a24bc478652b5f$export$fbdeaa6a76694f71),\n/* harmony export */   getItemCount: () => (/* binding */ $453cc9f0df89c0a5$export$77d5aafae4e095b2),\n/* harmony export */   getLastItem: () => (/* binding */ $c5a24bc478652b5f$export$7475b2c64539e4cf),\n/* harmony export */   getNthItem: () => (/* binding */ $c5a24bc478652b5f$export$5f3398f8733f90e2),\n/* harmony export */   useCollection: () => (/* binding */ $7613b1592d41b092$export$6cd28814d92fa9c9)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c1d7fb2ec91bae71$var$Item(props) {\n    return null;\n}\n$c1d7fb2ec91bae71$var$Item.getCollectionNode = function* getCollectionNode(props, context) {\n    let { childItems: childItems, title: title, children: children } = props;\n    let rendered = props.title || props.children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"] || \"\";\n    // suppressTextValueWarning is used in components like Tabs, which don't have type to select support.\n    if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning)) console.warn(\"<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.\");\n    yield {\n        type: \"item\",\n        props: props,\n        rendered: rendered,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: $c1d7fb2ec91bae71$var$hasChildItems(props),\n        *childNodes () {\n            if (childItems) for (let child of childItems)yield {\n                type: \"item\",\n                value: child\n            };\n            else if (title) {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    items.push({\n                        type: \"item\",\n                        element: child\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\nfunction $c1d7fb2ec91bae71$var$hasChildItems(props) {\n    if (props.hasChildItems != null) return props.hasChildItems;\n    if (props.childItems) return true;\n    if (props.title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(props.children) > 0) return true;\n    return false;\n}\n// We don't want getCollectionNode to show up in the type definition\nlet $c1d7fb2ec91bae71$export$6d08773d2e66f8f2 = $c1d7fb2ec91bae71$var$Item;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $9fc4852771d079eb$var$Section(props) {\n    return null;\n}\n$9fc4852771d079eb$var$Section.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, title: title, items: items } = props;\n    yield {\n        type: \"section\",\n        props: props,\n        hasChildNodes: true,\n        rendered: title,\n        \"aria-label\": props[\"aria-label\"],\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    items.push({\n                        type: \"item\",\n                        element: child\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n// We don't want getCollectionNode to show up in the type definition\nlet $9fc4852771d079eb$export$6e2c8f0811a474ce = $9fc4852771d079eb$var$Section;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $eb2240fc39a57fa5$export$bf788dd355e3a401 {\n    build(props, context) {\n        this.context = context;\n        return $eb2240fc39a57fa5$var$iterable(()=>this.iterateCollection(props));\n    }\n    *iterateCollection(props) {\n        let { children: children, items: items } = props;\n        if (typeof children === \"function\") {\n            if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n            for (let item of props.items)yield* this.getFullNode({\n                value: item\n            }, {\n                renderer: children\n            });\n        } else {\n            let items = [];\n            (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                items.push(child);\n            });\n            let index = 0;\n            for (let item of items){\n                let nodes = this.getFullNode({\n                    element: item,\n                    index: index\n                }, {});\n                for (let node of nodes){\n                    index++;\n                    yield node;\n                }\n            }\n        }\n    }\n    getKey(item, partialNode, state, parentKey) {\n        if (item.key != null) return item.key;\n        if (partialNode.type === \"cell\" && partialNode.key != null) return `${parentKey}${partialNode.key}`;\n        let v = partialNode.value;\n        if (v != null) {\n            var _v_key;\n            let key = (_v_key = v.key) !== null && _v_key !== void 0 ? _v_key : v.id;\n            if (key == null) throw new Error(\"No key found for item\");\n            return key;\n        }\n        return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;\n    }\n    getChildState(state, partialNode) {\n        return {\n            renderer: partialNode.renderer || state.renderer\n        };\n    }\n    *getFullNode(partialNode, state, parentKey, parentNode) {\n        // If there's a value instead of an element on the node, and a parent renderer function is available,\n        // use it to render an element for the value.\n        let element = partialNode.element;\n        if (!element && partialNode.value && state && state.renderer) {\n            let cached = this.cache.get(partialNode.value);\n            if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {\n                cached.index = partialNode.index;\n                cached.parentKey = parentNode ? parentNode.key : null;\n                yield cached;\n                return;\n            }\n            element = state.renderer(partialNode.value);\n        }\n        // If there's an element with a getCollectionNode function on its type, then it's a supported component.\n        // Call this function to get a partial node, and recursively build a full node from there.\n        if ((0, react__WEBPACK_IMPORTED_MODULE_0__).isValidElement(element)) {\n            let type = element.type;\n            if (typeof type !== \"function\" && typeof type.getCollectionNode !== \"function\") {\n                let name = typeof element.type === \"function\" ? element.type.name : element.type;\n                throw new Error(`Unknown element <${name}> in collection.`);\n            }\n            let childNodes = type.getCollectionNode(element.props, this.context);\n            let index = partialNode.index;\n            let result = childNodes.next();\n            while(!result.done && result.value){\n                let childNode = result.value;\n                partialNode.index = index;\n                let nodeKey = childNode.key;\n                if (!nodeKey) nodeKey = childNode.element ? null : this.getKey(element, partialNode, state, parentKey);\n                let nodes = this.getFullNode({\n                    ...childNode,\n                    key: nodeKey,\n                    index: index,\n                    wrapper: $eb2240fc39a57fa5$var$compose(partialNode.wrapper, childNode.wrapper)\n                }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element.key}` : element.key, parentNode);\n                let children = [\n                    ...nodes\n                ];\n                for (let node of children){\n                    // Cache the node based on its value\n                    node.value = childNode.value || partialNode.value;\n                    if (node.value) this.cache.set(node.value, node);\n                    // The partial node may have specified a type for the child in order to specify a constraint.\n                    // Verify that the full node that was built recursively matches this type.\n                    if (partialNode.type && node.type !== partialNode.type) throw new Error(`Unsupported type <${$eb2240fc39a57fa5$var$capitalize(node.type)}> in <${$eb2240fc39a57fa5$var$capitalize(parentNode.type)}>. Only <${$eb2240fc39a57fa5$var$capitalize(partialNode.type)}> is supported.`);\n                    index++;\n                    yield node;\n                }\n                result = childNodes.next(children);\n            }\n            return;\n        }\n        // Ignore invalid elements\n        if (partialNode.key == null) return;\n        // Create full node\n        let builder = this;\n        let node = {\n            type: partialNode.type,\n            props: partialNode.props,\n            key: partialNode.key,\n            parentKey: parentNode ? parentNode.key : null,\n            value: partialNode.value,\n            level: parentNode ? parentNode.level + 1 : 0,\n            index: partialNode.index,\n            rendered: partialNode.rendered,\n            textValue: partialNode.textValue,\n            \"aria-label\": partialNode[\"aria-label\"],\n            wrapper: partialNode.wrapper,\n            shouldInvalidate: partialNode.shouldInvalidate,\n            hasChildNodes: partialNode.hasChildNodes,\n            childNodes: $eb2240fc39a57fa5$var$iterable(function*() {\n                if (!partialNode.hasChildNodes) return;\n                let index = 0;\n                for (let child of partialNode.childNodes()){\n                    // Ensure child keys are globally unique by prepending the parent node's key\n                    if (child.key != null) // Currently this line will have issues when a parent has a key `a` and a child with key `bc`\n                    // but another parent has key `ab` and its child has a key `c`. The combined keys would result in both\n                    // children having a key of `abc`.\n                    child.key = `${node.key}${child.key}`;\n                    child.index = index;\n                    let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);\n                    for (let node of nodes){\n                        index++;\n                        yield node;\n                    }\n                }\n            })\n        };\n        yield node;\n    }\n    constructor(){\n        this.cache = new WeakMap();\n    }\n}\n// Wraps an iterator function as an iterable object, and caches the results.\nfunction $eb2240fc39a57fa5$var$iterable(iterator) {\n    let cache = [];\n    let iterable = null;\n    return {\n        *[Symbol.iterator] () {\n            for (let item of cache)yield item;\n            if (!iterable) iterable = iterator();\n            for (let item of iterable){\n                cache.push(item);\n                yield item;\n            }\n        }\n    };\n}\nfunction $eb2240fc39a57fa5$var$compose(outer, inner) {\n    if (outer && inner) return (element)=>outer(inner(element));\n    if (outer) return outer;\n    if (inner) return inner;\n}\nfunction $eb2240fc39a57fa5$var$capitalize(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nfunction $7613b1592d41b092$export$6cd28814d92fa9c9(props, factory, context) {\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $eb2240fc39a57fa5$export$bf788dd355e3a401)(), []);\n    let { children: children, items: items, collection: collection } = props;\n    let result = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (collection) return collection;\n        let nodes = builder.build({\n            children: children,\n            items: items\n        }, context);\n        return factory(nodes);\n    }, [\n        builder,\n        children,\n        items,\n        collection,\n        context,\n        factory\n    ]);\n    return result;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c5a24bc478652b5f$export$1005530eda016c13(node, collection) {\n    // New API: call collection.getChildren with the node key.\n    if (typeof collection.getChildren === \"function\") return collection.getChildren(node.key);\n    // Old API: access childNodes directly.\n    return node.childNodes;\n}\nfunction $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {\n    return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);\n}\nfunction $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index) {\n    if (index < 0) return undefined;\n    let i = 0;\n    for (let item of iterable){\n        if (i === index) return item;\n        i++;\n    }\n}\nfunction $c5a24bc478652b5f$export$7475b2c64539e4cf(iterable) {\n    let lastItem = undefined;\n    for (let value of iterable)lastItem = value;\n    return lastItem;\n}\nfunction $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection, a, b) {\n    // If the two nodes have the same parent, compare their indices.\n    if (a.parentKey === b.parentKey) return a.index - b.index;\n    // Otherwise, collect all of the ancestors from each node, and find the first one that doesn't match starting from the root.\n    // Include the base nodes in case we are comparing nodes of different levels so that we can compare the higher node to the lower level node's\n    // ancestor of the same level\n    let aAncestors = [\n        ...$c5a24bc478652b5f$var$getAncestors(collection, a),\n        a\n    ];\n    let bAncestors = [\n        ...$c5a24bc478652b5f$var$getAncestors(collection, b),\n        b\n    ];\n    let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a, i)=>a !== bAncestors[i]);\n    if (firstNonMatchingAncestor !== -1) {\n        // Compare the indices of two children within the common ancestor.\n        a = aAncestors[firstNonMatchingAncestor];\n        b = bAncestors[firstNonMatchingAncestor];\n        return a.index - b.index;\n    }\n    // If there isn't a non matching ancestor, we might be in a case where one of the nodes is the ancestor of the other.\n    if (aAncestors.findIndex((node)=>node === b) >= 0) return 1;\n    else if (bAncestors.findIndex((node)=>node === a) >= 0) return -1;\n    // ðŸ¤·\n    return -1;\n}\nfunction $c5a24bc478652b5f$var$getAncestors(collection, node) {\n    let parents = [];\n    while((node === null || node === void 0 ? void 0 : node.parentKey) != null){\n        node = collection.getItem(node.parentKey);\n        parents.unshift(node);\n    }\n    return parents;\n}\nconst $453cc9f0df89c0a5$var$cache = new WeakMap();\nfunction $453cc9f0df89c0a5$export$77d5aafae4e095b2(collection) {\n    let count = $453cc9f0df89c0a5$var$cache.get(collection);\n    if (count != null) return count;\n    count = 0;\n    let countItems = (items)=>{\n        for (let item of items)if (item.type === \"section\") countItems((0, $c5a24bc478652b5f$export$1005530eda016c13)(item, collection));\n        else count++;\n    };\n    countItems(collection);\n    $453cc9f0df89c0a5$var$cache.set(collection, count);\n    return count;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThEO0FBRTlEOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0QsU0FBU0csMkJBQTJCQyxLQUFLO0lBQ3JDLE9BQU87QUFDWDtBQUNBRCwyQkFBMkJFLGlCQUFpQixHQUFHLFVBQVVBLGtCQUFrQkQsS0FBSyxFQUFFRSxPQUFPO0lBQ3JGLElBQUksRUFBRUMsWUFBWUEsVUFBVSxFQUFFQyxPQUFPQSxLQUFLLEVBQUVDLFVBQVVBLFFBQVEsRUFBRSxHQUFHTDtJQUNuRSxJQUFJTSxXQUFXTixNQUFNSSxLQUFLLElBQUlKLE1BQU1LLFFBQVE7SUFDNUMsSUFBSUUsWUFBWVAsTUFBTU8sU0FBUyxJQUFLLFFBQU9ELGFBQWEsV0FBV0EsV0FBVyxFQUFDLEtBQU1OLEtBQUssQ0FBQyxhQUFhLElBQUk7SUFDNUcscUdBQXFHO0lBQ3JHLElBQUksQ0FBQ08sYUFBYSxDQUFFTCxDQUFBQSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUU0sd0JBQXdCLEdBQUdDLFFBQVFDLElBQUksQ0FBQztJQUN0SCxNQUFNO1FBQ0ZDLE1BQU07UUFDTlgsT0FBT0E7UUFDUE0sVUFBVUE7UUFDVkMsV0FBV0E7UUFDWCxjQUFjUCxLQUFLLENBQUMsYUFBYTtRQUNqQ1ksZUFBZUMsb0NBQW9DYjtRQUNuRCxDQUFDYztZQUNHLElBQUlYLFlBQVksS0FBSyxJQUFJWSxTQUFTWixXQUFXLE1BQU07Z0JBQy9DUSxNQUFNO2dCQUNOSyxPQUFPRDtZQUNYO2lCQUNLLElBQUlYLE9BQU87Z0JBQ1osSUFBSWEsUUFBUSxFQUFFO2dCQUNiLElBQUdyQixrQ0FBVyxFQUFHc0IsUUFBUSxDQUFDQyxPQUFPLENBQUNkLFVBQVUsQ0FBQ1U7b0JBQzFDRSxNQUFNRyxJQUFJLENBQUM7d0JBQ1BULE1B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d2VicGFjazovL3pldXMtbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvY29sbGVjdGlvbnMvZGlzdC9pbXBvcnQubWpzPzFlMDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICR0eVc2QSRyZWFjdCwge3VzZU1lbW8gYXMgJHR5VzZBJHVzZU1lbW99IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJGMxZDdmYjJlYzkxYmFlNzEkdmFyJEl0ZW0ocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiRjMWQ3ZmIyZWM5MWJhZTcxJHZhciRJdGVtLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgY2hpbGRJdGVtczogY2hpbGRJdGVtcywgdGl0bGU6IHRpdGxlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSA9IHByb3BzO1xuICAgIGxldCByZW5kZXJlZCA9IHByb3BzLnRpdGxlIHx8IHByb3BzLmNoaWxkcmVuO1xuICAgIGxldCB0ZXh0VmFsdWUgPSBwcm9wcy50ZXh0VmFsdWUgfHwgKHR5cGVvZiByZW5kZXJlZCA9PT0gXCJzdHJpbmdcIiA/IHJlbmRlcmVkIDogXCJcIikgfHwgcHJvcHNbXCJhcmlhLWxhYmVsXCJdIHx8IFwiXCI7XG4gICAgLy8gc3VwcHJlc3NUZXh0VmFsdWVXYXJuaW5nIGlzIHVzZWQgaW4gY29tcG9uZW50cyBsaWtlIFRhYnMsIHdoaWNoIGRvbid0IGhhdmUgdHlwZSB0byBzZWxlY3Qgc3VwcG9ydC5cbiAgICBpZiAoIXRleHRWYWx1ZSAmJiAhKGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5zdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmcpKSBjb25zb2xlLndhcm4oXCI8SXRlbT4gd2l0aCBub24tcGxhaW4gdGV4dCBjb250ZW50cyBpcyB1bnN1cHBvcnRlZCBieSB0eXBlIHRvIHNlbGVjdCBmb3IgYWNjZXNzaWJpbGl0eS4gUGxlYXNlIGFkZCBhIGB0ZXh0VmFsdWVgIHByb3AuXCIpO1xuICAgIHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgcmVuZGVyZWQ6IHJlbmRlcmVkLFxuICAgICAgICB0ZXh0VmFsdWU6IHRleHRWYWx1ZSxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHByb3BzW1wiYXJpYS1sYWJlbFwiXSxcbiAgICAgICAgaGFzQ2hpbGROb2RlczogJGMxZDdmYjJlYzkxYmFlNzEkdmFyJGhhc0NoaWxkSXRlbXMocHJvcHMpLFxuICAgICAgICAqY2hpbGROb2RlcyAoKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRJdGVtcykgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRJdGVtcyl5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoaWxkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWxzZSBpZiAodGl0bGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAoMCwgJHR5VzZBJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpPT57XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBjaGlsZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB5aWVsZCogaXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmZ1bmN0aW9uICRjMWQ3ZmIyZWM5MWJhZTcxJHZhciRoYXNDaGlsZEl0ZW1zKHByb3BzKSB7XG4gICAgaWYgKHByb3BzLmhhc0NoaWxkSXRlbXMgIT0gbnVsbCkgcmV0dXJuIHByb3BzLmhhc0NoaWxkSXRlbXM7XG4gICAgaWYgKHByb3BzLmNoaWxkSXRlbXMpIHJldHVybiB0cnVlO1xuICAgIGlmIChwcm9wcy50aXRsZSAmJiAoMCwgJHR5VzZBJHJlYWN0KS5DaGlsZHJlbi5jb3VudChwcm9wcy5jaGlsZHJlbikgPiAwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICRjMWQ3ZmIyZWM5MWJhZTcxJGV4cG9ydCQ2ZDA4NzczZDJlNjZmOGYyID0gJGMxZDdmYjJlYzkxYmFlNzEkdmFyJEl0ZW07XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDlmYzQ4NTI3NzFkMDc5ZWIkdmFyJFNlY3Rpb24ocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQ5ZmM0ODUyNzcxZDA3OWViJHZhciRTZWN0aW9uLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzKSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCB0aXRsZTogdGl0bGUsIGl0ZW1zOiBpdGVtcyB9ID0gcHJvcHM7XG4gICAgeWllbGQge1xuICAgICAgICB0eXBlOiBcInNlY3Rpb25cIixcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBoYXNDaGlsZE5vZGVzOiB0cnVlLFxuICAgICAgICByZW5kZXJlZDogdGl0bGUsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwcm9wc1tcImFyaWEtbGFiZWxcIl0sXG4gICAgICAgICpjaGlsZE5vZGVzICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbXMpIHRocm93IG5ldyBFcnJvcihcInByb3BzLmNoaWxkcmVuIHdhcyBhIGZ1bmN0aW9uIGJ1dCBwcm9wcy5pdGVtcyBpcyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlbXMpeWllbGQge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBjaGlsZHJlblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICgwLCAkdHlXNkEkcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCk9PntcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBpdGVtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkOWZjNDg1Mjc3MWQwNzllYiRleHBvcnQkNmUyYzhmMDgxMWE0NzRjZSA9ICQ5ZmM0ODUyNzcxZDA3OWViJHZhciRTZWN0aW9uO1xuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5jbGFzcyAkZWIyMjQwZmMzOWE1N2ZhNSRleHBvcnQkYmY3ODhkZDM1NWUzYTQwMSB7XG4gICAgYnVpbGQocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgcmV0dXJuICRlYjIyNDBmYzM5YTU3ZmE1JHZhciRpdGVyYWJsZSgoKT0+dGhpcy5pdGVyYXRlQ29sbGVjdGlvbihwcm9wcykpO1xuICAgIH1cbiAgICAqaXRlcmF0ZUNvbGxlY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBpdGVtczogaXRlbXMgfSA9IHByb3BzO1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghaXRlbXMpIHRocm93IG5ldyBFcnJvcihcInByb3BzLmNoaWxkcmVuIHdhcyBhIGZ1bmN0aW9uIGJ1dCBwcm9wcy5pdGVtcyBpcyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBwcm9wcy5pdGVtcyl5aWVsZCogdGhpcy5nZXRGdWxsTm9kZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogY2hpbGRyZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGl0ZW1zID0gW107XG4gICAgICAgICAgICAoMCwgJHR5VzZBJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpPT57XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKXtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLmdldEZ1bGxOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpe1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRLZXkoaXRlbSwgcGFydGlhbE5vZGUsIHN0YXRlLCBwYXJlbnRLZXkpIHtcbiAgICAgICAgaWYgKGl0ZW0ua2V5ICE9IG51bGwpIHJldHVybiBpdGVtLmtleTtcbiAgICAgICAgaWYgKHBhcnRpYWxOb2RlLnR5cGUgPT09IFwiY2VsbFwiICYmIHBhcnRpYWxOb2RlLmtleSAhPSBudWxsKSByZXR1cm4gYCR7cGFyZW50S2V5fSR7cGFydGlhbE5vZGUua2V5fWA7XG4gICAgICAgIGxldCB2ID0gcGFydGlhbE5vZGUudmFsdWU7XG4gICAgICAgIGlmICh2ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfdl9rZXk7XG4gICAgICAgICAgICBsZXQga2V5ID0gKF92X2tleSA9IHYua2V5KSAhPT0gbnVsbCAmJiBfdl9rZXkgIT09IHZvaWQgMCA/IF92X2tleSA6IHYuaWQ7XG4gICAgICAgICAgICBpZiAoa2V5ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk5vIGtleSBmb3VuZCBmb3IgaXRlbVwiKTtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudEtleSA/IGAke3BhcmVudEtleX0uJHtwYXJ0aWFsTm9kZS5pbmRleH1gIDogYCQuJHtwYXJ0aWFsTm9kZS5pbmRleH1gO1xuICAgIH1cbiAgICBnZXRDaGlsZFN0YXRlKHN0YXRlLCBwYXJ0aWFsTm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVuZGVyZXI6IHBhcnRpYWxOb2RlLnJlbmRlcmVyIHx8IHN0YXRlLnJlbmRlcmVyXG4gICAgICAgIH07XG4gICAgfVxuICAgICpnZXRGdWxsTm9kZShwYXJ0aWFsTm9kZSwgc3RhdGUsIHBhcmVudEtleSwgcGFyZW50Tm9kZSkge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgdmFsdWUgaW5zdGVhZCBvZiBhbiBlbGVtZW50IG9uIHRoZSBub2RlLCBhbmQgYSBwYXJlbnQgcmVuZGVyZXIgZnVuY3Rpb24gaXMgYXZhaWxhYmxlLFxuICAgICAgICAvLyB1c2UgaXQgdG8gcmVuZGVyIGFuIGVsZW1lbnQgZm9yIHRoZSB2YWx1ZS5cbiAgICAgICAgbGV0IGVsZW1lbnQgPSBwYXJ0aWFsTm9kZS5lbGVtZW50O1xuICAgICAgICBpZiAoIWVsZW1lbnQgJiYgcGFydGlhbE5vZGUudmFsdWUgJiYgc3RhdGUgJiYgc3RhdGUucmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLmNhY2hlLmdldChwYXJ0aWFsTm9kZS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkICYmICghY2FjaGVkLnNob3VsZEludmFsaWRhdGUgfHwgIWNhY2hlZC5zaG91bGRJbnZhbGlkYXRlKHRoaXMuY29udGV4dCkpKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkLmluZGV4ID0gcGFydGlhbE5vZGUuaW5kZXg7XG4gICAgICAgICAgICAgICAgY2FjaGVkLnBhcmVudEtleSA9IHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmtleSA6IG51bGw7XG4gICAgICAgICAgICAgICAgeWllbGQgY2FjaGVkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQgPSBzdGF0ZS5yZW5kZXJlcihwYXJ0aWFsTm9kZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBlbGVtZW50IHdpdGggYSBnZXRDb2xsZWN0aW9uTm9kZSBmdW5jdGlvbiBvbiBpdHMgdHlwZSwgdGhlbiBpdCdzIGEgc3VwcG9ydGVkIGNvbXBvbmVudC5cbiAgICAgICAgLy8gQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGdldCBhIHBhcnRpYWwgbm9kZSwgYW5kIHJlY3Vyc2l2ZWx5IGJ1aWxkIGEgZnVsbCBub2RlIGZyb20gdGhlcmUuXG4gICAgICAgIGlmICgoMCwgJHR5VzZBJHJlYWN0KS5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdHlwZS5nZXRDb2xsZWN0aW9uTm9kZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSB0eXBlb2YgZWxlbWVudC50eXBlID09PSBcImZ1bmN0aW9uXCIgPyBlbGVtZW50LnR5cGUubmFtZSA6IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZWxlbWVudCA8JHtuYW1lfT4gaW4gY29sbGVjdGlvbi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGVzID0gdHlwZS5nZXRDb2xsZWN0aW9uTm9kZShlbGVtZW50LnByb3BzLCB0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gcGFydGlhbE5vZGUuaW5kZXg7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gY2hpbGROb2Rlcy5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSghcmVzdWx0LmRvbmUgJiYgcmVzdWx0LnZhbHVlKXtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGROb2RlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHBhcnRpYWxOb2RlLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGVLZXkgPSBjaGlsZE5vZGUua2V5O1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUtleSkgbm9kZUtleSA9IGNoaWxkTm9kZS5lbGVtZW50ID8gbnVsbCA6IHRoaXMuZ2V0S2V5KGVsZW1lbnQsIHBhcnRpYWxOb2RlLCBzdGF0ZSwgcGFyZW50S2V5KTtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLmdldEZ1bGxOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGROb2RlLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG5vZGVLZXksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlcjogJGViMjI0MGZjMzlhNTdmYTUkdmFyJGNvbXBvc2UocGFydGlhbE5vZGUud3JhcHBlciwgY2hpbGROb2RlLndyYXBwZXIpXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5nZXRDaGlsZFN0YXRlKHN0YXRlLCBjaGlsZE5vZGUpLCBwYXJlbnRLZXkgPyBgJHtwYXJlbnRLZXl9JHtlbGVtZW50LmtleX1gIDogZWxlbWVudC5rZXksIHBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4ubm9kZXNcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2YgY2hpbGRyZW4pe1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgbm9kZSBiYXNlZCBvbiBpdHMgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IGNoaWxkTm9kZS52YWx1ZSB8fCBwYXJ0aWFsTm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudmFsdWUpIHRoaXMuY2FjaGUuc2V0KG5vZGUudmFsdWUsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcGFydGlhbCBub2RlIG1heSBoYXZlIHNwZWNpZmllZCBhIHR5cGUgZm9yIHRoZSBjaGlsZCBpbiBvcmRlciB0byBzcGVjaWZ5IGEgY29uc3RyYWludC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGZ1bGwgbm9kZSB0aGF0IHdhcyBidWlsdCByZWN1cnNpdmVseSBtYXRjaGVzIHRoaXMgdHlwZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpYWxOb2RlLnR5cGUgJiYgbm9kZS50eXBlICE9PSBwYXJ0aWFsTm9kZS50eXBlKSB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgPCR7JGViMjI0MGZjMzlhNTdmYTUkdmFyJGNhcGl0YWxpemUobm9kZS50eXBlKX0+IGluIDwkeyRlYjIyNDBmYzM5YTU3ZmE1JHZhciRjYXBpdGFsaXplKHBhcmVudE5vZGUudHlwZSl9Pi4gT25seSA8JHskZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY2FwaXRhbGl6ZShwYXJ0aWFsTm9kZS50eXBlKX0+IGlzIHN1cHBvcnRlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY2hpbGROb2Rlcy5uZXh0KGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgaW52YWxpZCBlbGVtZW50c1xuICAgICAgICBpZiAocGFydGlhbE5vZGUua2V5ID09IG51bGwpIHJldHVybjtcbiAgICAgICAgLy8gQ3JlYXRlIGZ1bGwgbm9kZVxuICAgICAgICBsZXQgYnVpbGRlciA9IHRoaXM7XG4gICAgICAgIGxldCBub2RlID0ge1xuICAgICAgICAgICAgdHlwZTogcGFydGlhbE5vZGUudHlwZSxcbiAgICAgICAgICAgIHByb3BzOiBwYXJ0aWFsTm9kZS5wcm9wcyxcbiAgICAgICAgICAgIGtleTogcGFydGlhbE5vZGUua2V5LFxuICAgICAgICAgICAgcGFyZW50S2V5OiBwYXJlbnROb2RlID8gcGFyZW50Tm9kZS5rZXkgOiBudWxsLFxuICAgICAgICAgICAgdmFsdWU6IHBhcnRpYWxOb2RlLnZhbHVlLFxuICAgICAgICAgICAgbGV2ZWw6IHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmxldmVsICsgMSA6IDAsXG4gICAgICAgICAgICBpbmRleDogcGFydGlhbE5vZGUuaW5kZXgsXG4gICAgICAgICAgICByZW5kZXJlZDogcGFydGlhbE5vZGUucmVuZGVyZWQsXG4gICAgICAgICAgICB0ZXh0VmFsdWU6IHBhcnRpYWxOb2RlLnRleHRWYWx1ZSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwYXJ0aWFsTm9kZVtcImFyaWEtbGFiZWxcIl0sXG4gICAgICAgICAgICB3cmFwcGVyOiBwYXJ0aWFsTm9kZS53cmFwcGVyLFxuICAgICAgICAgICAgc2hvdWxkSW52YWxpZGF0ZTogcGFydGlhbE5vZGUuc2hvdWxkSW52YWxpZGF0ZSxcbiAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IHBhcnRpYWxOb2RlLmhhc0NoaWxkTm9kZXMsXG4gICAgICAgICAgICBjaGlsZE5vZGVzOiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkaXRlcmFibGUoZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgICAgIGlmICghcGFydGlhbE5vZGUuaGFzQ2hpbGROb2RlcykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgcGFydGlhbE5vZGUuY2hpbGROb2RlcygpKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNoaWxkIGtleXMgYXJlIGdsb2JhbGx5IHVuaXF1ZSBieSBwcmVwZW5kaW5nIHRoZSBwYXJlbnQgbm9kZSdzIGtleVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQua2V5ICE9IG51bGwpIC8vIFRPRE86IFJlbW92ZSB0aGlzIGxpbmUgZW50aXJlbHkgYW5kIGVuZm9yY2UgdGhhdCB1c2VycyBhbHdheXMgcHJvdmlkZSB1bmlxdWUga2V5cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ3VycmVudGx5IHRoaXMgbGluZSB3aWxsIGhhdmUgaXNzdWVzIHdoZW4gYSBwYXJlbnQgaGFzIGEga2V5IGBhYCBhbmQgYSBjaGlsZCB3aXRoIGtleSBgYmNgXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBhbm90aGVyIHBhcmVudCBoYXMga2V5IGBhYmAgYW5kIGl0cyBjaGlsZCBoYXMgYSBrZXkgYGNgLiBUaGUgY29tYmluZWQga2V5cyB3b3VsZCByZXN1bHQgaW4gYm90aFxuICAgICAgICAgICAgICAgICAgICAvLyBjaGlsZHJlbiBoYXZpbmcgYSBrZXkgb2YgYGFiY2AuXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmtleSA9IGAke25vZGUua2V5fSR7Y2hpbGQua2V5fWA7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlcyA9IGJ1aWxkZXIuZ2V0RnVsbE5vZGUoY2hpbGQsIGJ1aWxkZXIuZ2V0Q2hpbGRTdGF0ZShzdGF0ZSwgY2hpbGQpLCBub2RlLmtleSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgICB5aWVsZCBub2RlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG59XG4vLyBXcmFwcyBhbiBpdGVyYXRvciBmdW5jdGlvbiBhcyBhbiBpdGVyYWJsZSBvYmplY3QsIGFuZCBjYWNoZXMgdGhlIHJlc3VsdHMuXG5mdW5jdGlvbiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkaXRlcmFibGUoaXRlcmF0b3IpIHtcbiAgICBsZXQgY2FjaGUgPSBbXTtcbiAgICBsZXQgaXRlcmFibGUgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgICpbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGNhY2hlKXlpZWxkIGl0ZW07XG4gICAgICAgICAgICBpZiAoIWl0ZXJhYmxlKSBpdGVyYWJsZSA9IGl0ZXJhdG9yKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZXJhYmxlKXtcbiAgICAgICAgICAgICAgICBjYWNoZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gJGViMjI0MGZjMzlhNTdmYTUkdmFyJGNvbXBvc2Uob3V0ZXIsIGlubmVyKSB7XG4gICAgaWYgKG91dGVyICYmIGlubmVyKSByZXR1cm4gKGVsZW1lbnQpPT5vdXRlcihpbm5lcihlbGVtZW50KSk7XG4gICAgaWYgKG91dGVyKSByZXR1cm4gb3V0ZXI7XG4gICAgaWYgKGlubmVyKSByZXR1cm4gaW5uZXI7XG59XG5mdW5jdGlvbiAkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY2FwaXRhbGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cblxuXG5mdW5jdGlvbiAkNzYxM2IxNTkyZDQxYjA5MiRleHBvcnQkNmNkMjg4MTRkOTJmYTljOShwcm9wcywgZmFjdG9yeSwgY29udGV4dCkge1xuICAgIGxldCBidWlsZGVyID0gKDAsICR0eVc2QSR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkZWIyMjQwZmMzOWE1N2ZhNSRleHBvcnQkYmY3ODhkZDM1NWUzYTQwMSkoKSwgW10pO1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgaXRlbXM6IGl0ZW1zLCBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uIH0gPSBwcm9wcztcbiAgICBsZXQgcmVzdWx0ID0gKDAsICR0eVc2QSR1c2VNZW1vKSgoKT0+e1xuICAgICAgICBpZiAoY29sbGVjdGlvbikgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIGxldCBub2RlcyA9IGJ1aWxkZXIuYnVpbGQoe1xuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICAgICAgaXRlbXM6IGl0ZW1zXG4gICAgICAgIH0sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZmFjdG9yeShub2Rlcyk7XG4gICAgfSwgW1xuICAgICAgICBidWlsZGVyLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGZhY3RvcnlcbiAgICBdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDEwMDU1MzBlZGEwMTZjMTMobm9kZSwgY29sbGVjdGlvbikge1xuICAgIC8vIE5ldyBBUEk6IGNhbGwgY29sbGVjdGlvbi5nZXRDaGlsZHJlbiB3aXRoIHRoZSBub2RlIGtleS5cbiAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb24uZ2V0Q2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNvbGxlY3Rpb24uZ2V0Q2hpbGRyZW4obm9kZS5rZXkpO1xuICAgIC8vIE9sZCBBUEk6IGFjY2VzcyBjaGlsZE5vZGVzIGRpcmVjdGx5LlxuICAgIHJldHVybiBub2RlLmNoaWxkTm9kZXM7XG59XG5mdW5jdGlvbiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkZmJkZWFhNmE3NjY5NGY3MShpdGVyYWJsZSkge1xuICAgIHJldHVybiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNWYzMzk4Zjg3MzNmOTBlMihpdGVyYWJsZSwgMCk7XG59XG5mdW5jdGlvbiAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNWYzMzk4Zjg3MzNmOTBlMihpdGVyYWJsZSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZXJhYmxlKXtcbiAgICAgICAgaWYgKGkgPT09IGluZGV4KSByZXR1cm4gaXRlbTtcbiAgICAgICAgaSsrO1xuICAgIH1cbn1cbmZ1bmN0aW9uICRjNWEyNGJjNDc4NjUyYjVmJGV4cG9ydCQ3NDc1YjJjNjQ1MzllNGNmKGl0ZXJhYmxlKSB7XG4gICAgbGV0IGxhc3RJdGVtID0gdW5kZWZpbmVkO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIGl0ZXJhYmxlKWxhc3RJdGVtID0gdmFsdWU7XG4gICAgcmV0dXJuIGxhc3RJdGVtO1xufVxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDhjNDM0YjNhN2E0ZGFkNihjb2xsZWN0aW9uLCBhLCBiKSB7XG4gICAgLy8gSWYgdGhlIHR3byBub2RlcyBoYXZlIHRoZSBzYW1lIHBhcmVudCwgY29tcGFyZSB0aGVpciBpbmRpY2VzLlxuICAgIGlmIChhLnBhcmVudEtleSA9PT0gYi5wYXJlbnRLZXkpIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAvLyBPdGhlcndpc2UsIGNvbGxlY3QgYWxsIG9mIHRoZSBhbmNlc3RvcnMgZnJvbSBlYWNoIG5vZGUsIGFuZCBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBkb2Vzbid0IG1hdGNoIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QuXG4gICAgLy8gSW5jbHVkZSB0aGUgYmFzZSBub2RlcyBpbiBjYXNlIHdlIGFyZSBjb21wYXJpbmcgbm9kZXMgb2YgZGlmZmVyZW50IGxldmVscyBzbyB0aGF0IHdlIGNhbiBjb21wYXJlIHRoZSBoaWdoZXIgbm9kZSB0byB0aGUgbG93ZXIgbGV2ZWwgbm9kZSdzXG4gICAgLy8gYW5jZXN0b3Igb2YgdGhlIHNhbWUgbGV2ZWxcbiAgICBsZXQgYUFuY2VzdG9ycyA9IFtcbiAgICAgICAgLi4uJGM1YTI0YmM0Nzg2NTJiNWYkdmFyJGdldEFuY2VzdG9ycyhjb2xsZWN0aW9uLCBhKSxcbiAgICAgICAgYVxuICAgIF07XG4gICAgbGV0IGJBbmNlc3RvcnMgPSBbXG4gICAgICAgIC4uLiRjNWEyNGJjNDc4NjUyYjVmJHZhciRnZXRBbmNlc3RvcnMoY29sbGVjdGlvbiwgYiksXG4gICAgICAgIGJcbiAgICBdO1xuICAgIGxldCBmaXJzdE5vbk1hdGNoaW5nQW5jZXN0b3IgPSBhQW5jZXN0b3JzLnNsaWNlKDAsIGJBbmNlc3RvcnMubGVuZ3RoKS5maW5kSW5kZXgoKGEsIGkpPT5hICE9PSBiQW5jZXN0b3JzW2ldKTtcbiAgICBpZiAoZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yICE9PSAtMSkge1xuICAgICAgICAvLyBDb21wYXJlIHRoZSBpbmRpY2VzIG9mIHR3byBjaGlsZHJlbiB3aXRoaW4gdGhlIGNvbW1vbiBhbmNlc3Rvci5cbiAgICAgICAgYSA9IGFBbmNlc3RvcnNbZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yXTtcbiAgICAgICAgYiA9IGJBbmNlc3RvcnNbZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yXTtcbiAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSBpc24ndCBhIG5vbiBtYXRjaGluZyBhbmNlc3Rvciwgd2UgbWlnaHQgYmUgaW4gYSBjYXNlIHdoZXJlIG9uZSBvZiB0aGUgbm9kZXMgaXMgdGhlIGFuY2VzdG9yIG9mIHRoZSBvdGhlci5cbiAgICBpZiAoYUFuY2VzdG9ycy5maW5kSW5kZXgoKG5vZGUpPT5ub2RlID09PSBiKSA+PSAwKSByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChiQW5jZXN0b3JzLmZpbmRJbmRleCgobm9kZSk9Pm5vZGUgPT09IGEpID49IDApIHJldHVybiAtMTtcbiAgICAvLyDwn6S3XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gJGM1YTI0YmM0Nzg2NTJiNWYkdmFyJGdldEFuY2VzdG9ycyhjb2xsZWN0aW9uLCBub2RlKSB7XG4gICAgbGV0IHBhcmVudHMgPSBbXTtcbiAgICB3aGlsZSgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnBhcmVudEtleSkgIT0gbnVsbCl7XG4gICAgICAgIG5vZGUgPSBjb2xsZWN0aW9uLmdldEl0ZW0obm9kZS5wYXJlbnRLZXkpO1xuICAgICAgICBwYXJlbnRzLnVuc2hpZnQobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRzO1xufVxuXG5cbmNvbnN0ICQ0NTNjYzlmMGRmODljMGE1JHZhciRjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiAkNDUzY2M5ZjBkZjg5YzBhNSRleHBvcnQkNzdkNWFhZmFlNGUwOTViMihjb2xsZWN0aW9uKSB7XG4gICAgbGV0IGNvdW50ID0gJDQ1M2NjOWYwZGY4OWMwYTUkdmFyJGNhY2hlLmdldChjb2xsZWN0aW9uKTtcbiAgICBpZiAoY291bnQgIT0gbnVsbCkgcmV0dXJuIGNvdW50O1xuICAgIGNvdW50ID0gMDtcbiAgICBsZXQgY291bnRJdGVtcyA9IChpdGVtcyk9PntcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcylpZiAoaXRlbS50eXBlID09PSBcInNlY3Rpb25cIikgY291bnRJdGVtcygoMCwgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDEwMDU1MzBlZGEwMTZjMTMpKGl0ZW0sIGNvbGxlY3Rpb24pKTtcbiAgICAgICAgZWxzZSBjb3VudCsrO1xuICAgIH07XG4gICAgY291bnRJdGVtcyhjb2xsZWN0aW9uKTtcbiAgICAkNDUzY2M5ZjBkZjg5YzBhNSR2YXIkY2FjaGUuc2V0KGNvbGxlY3Rpb24sIGNvdW50KTtcbiAgICByZXR1cm4gY291bnQ7XG59XG5cblxuXG5cblxuXG5leHBvcnQgeyRjMWQ3ZmIyZWM5MWJhZTcxJGV4cG9ydCQ2ZDA4NzczZDJlNjZmOGYyIGFzIEl0ZW0sICQ5ZmM0ODUyNzcxZDA3OWViJGV4cG9ydCQ2ZTJjOGYwODExYTQ3NGNlIGFzIFNlY3Rpb24sICQ3NjEzYjE1OTJkNDFiMDkyJGV4cG9ydCQ2Y2QyODgxNGQ5MmZhOWM5IGFzIHVzZUNvbGxlY3Rpb24sICQ0NTNjYzlmMGRmODljMGE1JGV4cG9ydCQ3N2Q1YWFmYWU0ZTA5NWIyIGFzIGdldEl0ZW1Db3VudCwgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDEwMDU1MzBlZGEwMTZjMTMgYXMgZ2V0Q2hpbGROb2RlcywgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JGZiZGVhYTZhNzY2OTRmNzEgYXMgZ2V0Rmlyc3RJdGVtLCAkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNzQ3NWIyYzY0NTM5ZTRjZiBhcyBnZXRMYXN0SXRlbSwgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDVmMzM5OGY4NzMzZjkwZTIgYXMgZ2V0TnRoSXRlbSwgJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDhjNDM0YjNhN2E0ZGFkNiBhcyBjb21wYXJlTm9kZU9yZGVyLCAkZWIyMjQwZmMzOWE1N2ZhNSRleHBvcnQkYmY3ODhkZDM1NWUzYTQwMSBhcyBDb2xsZWN0aW9uQnVpbGRlcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiJHR5VzZBJHJlYWN0IiwidXNlTWVtbyIsIiR0eVc2QSR1c2VNZW1vIiwiJGMxZDdmYjJlYzkxYmFlNzEkdmFyJEl0ZW0iLCJwcm9wcyIsImdldENvbGxlY3Rpb25Ob2RlIiwiY29udGV4dCIsImNoaWxkSXRlbXMiLCJ0aXRsZSIsImNoaWxkcmVuIiwicmVuZGVyZWQiLCJ0ZXh0VmFsdWUiLCJzdXBwcmVzc1RleHRWYWx1ZVdhcm5pbmciLCJjb25zb2xlIiwid2FybiIsInR5cGUiLCJoYXNDaGlsZE5vZGVzIiwiJGMxZDdmYjJlYzkxYmFlNzEkdmFyJGhhc0NoaWxkSXRlbXMiLCJjaGlsZE5vZGVzIiwiY2hpbGQiLCJ2YWx1ZSIsIml0ZW1zIiwiQ2hpbGRyZW4iLCJmb3JFYWNoIiwicHVzaCIsImVsZW1lbnQiLCJoYXNDaGlsZEl0ZW1zIiwiY291bnQiLCIkYzFkN2ZiMmVjOTFiYWU3MSRleHBvcnQkNmQwODc3M2QyZTY2ZjhmMiIsIiQ5ZmM0ODUyNzcxZDA3OWViJHZhciRTZWN0aW9uIiwiRXJyb3IiLCJpdGVtIiwicmVuZGVyZXIiLCIkOWZjNDg1Mjc3MWQwNzllYiRleHBvcnQkNmUyYzhmMDgxMWE0NzRjZSIsIiRlYjIyNDBmYzM5YTU3ZmE1JGV4cG9ydCRiZjc4OGRkMzU1ZTNhNDAxIiwiYnVpbGQiLCIkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkaXRlcmFibGUiLCJpdGVyYXRlQ29sbGVjdGlvbiIsImdldEZ1bGxOb2RlIiwiaW5kZXgiLCJub2RlcyIsIm5vZGUiLCJnZXRLZXkiLCJwYXJ0aWFsTm9kZSIsInN0YXRlIiwicGFyZW50S2V5Iiwia2V5IiwidiIsIl92X2tleSIsImlkIiwiZ2V0Q2hpbGRTdGF0ZSIsInBhcmVudE5vZGUiLCJjYWNoZWQiLCJjYWNoZSIsImdldCIsInNob3VsZEludmFsaWRhdGUiLCJpc1ZhbGlkRWxlbWVudCIsIm5hbWUiLCJyZXN1bHQiLCJuZXh0IiwiZG9uZSIsImNoaWxkTm9kZSIsIm5vZGVLZXkiLCJ3cmFwcGVyIiwiJGViMjI0MGZjMzlhNTdmYTUkdmFyJGNvbXBvc2UiLCJzZXQiLCIkZWIyMjQwZmMzOWE1N2ZhNSR2YXIkY2FwaXRhbGl6ZSIsImJ1aWxkZXIiLCJsZXZlbCIsImNvbnN0cnVjdG9yIiwiV2Vha01hcCIsIml0ZXJhdG9yIiwiaXRlcmFibGUiLCJTeW1ib2wiLCJvdXRlciIsImlubmVyIiwic3RyIiwidG9VcHBlckNhc2UiLCJzbGljZSIsIiQ3NjEzYjE1OTJkNDFiMDkyJGV4cG9ydCQ2Y2QyODgxNGQ5MmZhOWM5IiwiZmFjdG9yeSIsImNvbGxlY3Rpb24iLCIkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkMTAwNTUzMGVkYTAxNmMxMyIsImdldENoaWxkcmVuIiwiJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JGZiZGVhYTZhNzY2OTRmNzEiLCIkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNWYzMzk4Zjg3MzNmOTBlMiIsInVuZGVmaW5lZCIsImkiLCIkYzVhMjRiYzQ3ODY1MmI1ZiRleHBvcnQkNzQ3NWIyYzY0NTM5ZTRjZiIsImxhc3RJdGVtIiwiJGM1YTI0YmM0Nzg2NTJiNWYkZXhwb3J0JDhjNDM0YjNhN2E0ZGFkNiIsImEiLCJiIiwiYUFuY2VzdG9ycyIsIiRjNWEyNGJjNDc4NjUyYjVmJHZhciRnZXRBbmNlc3RvcnMiLCJiQW5jZXN0b3JzIiwiZmlyc3ROb25NYXRjaGluZ0FuY2VzdG9yIiwibGVuZ3RoIiwiZmluZEluZGV4IiwicGFyZW50cyIsImdldEl0ZW0iLCJ1bnNoaWZ0IiwiJDQ1M2NjOWYwZGY4OWMwYTUkdmFyJGNhY2hlIiwiJDQ1M2NjOWYwZGY4OWMwYTUkZXhwb3J0JDc3ZDVhYWZhZTRlMDk1YjIiLCJjb3VudEl0ZW1zIiwiSXRlbSIsIlNlY3Rpb24iLCJ1c2VDb2xsZWN0aW9uIiwiZ2V0SXRlbUNvdW50IiwiZ2V0Q2hpbGROb2RlcyIsImdldEZpcnN0SXRlbSIsImdldExhc3RJdGVtIiwiZ2V0TnRoSXRlbSIsImNvbXBhcmVOb2RlT3JkZXIiLCJDb2xsZWN0aW9uQnVpbGRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/data/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/data/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAsyncList: () => (/* binding */ $f86e6c1ec7da6ebb$export$bc3384a35de93d66),\n/* harmony export */   useListData: () => (/* binding */ $0d86e9c8f07f9a7b$export$762f73dccccd255d),\n/* harmony export */   useTreeData: () => (/* binding */ $be2ea0343af54212$export$d14e1352e21f4a16)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $0d86e9c8f07f9a7b$export$762f73dccccd255d(options) {\n    let { initialItems: initialItems = [], initialSelectedKeys: initialSelectedKeys, getKey: getKey = (item)=>item.id || item.key, filter: filter, initialFilterText: initialFilterText = \"\" } = options;\n    // Store both items and filteredItems in state so we can go back to the unfiltered list\n    let [state, setState] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        items: initialItems,\n        selectedKeys: initialSelectedKeys === \"all\" ? \"all\" : new Set(initialSelectedKeys || []),\n        filterText: initialFilterText\n    });\n    let filteredItems = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>filter ? state.items.filter((item)=>filter(item, state.filterText)) : state.items, [\n        state.items,\n        state.filterText,\n        filter\n    ]);\n    return {\n        ...state,\n        items: filteredItems,\n        ...$0d86e9c8f07f9a7b$export$79c0c687a5963b0a({\n            getKey: getKey\n        }, setState),\n        getItem (key) {\n            return state.items.find((item)=>getKey(item) === key);\n        }\n    };\n}\nfunction $0d86e9c8f07f9a7b$export$79c0c687a5963b0a(opts, dispatch) {\n    let { cursor: cursor, getKey: getKey } = opts;\n    return {\n        setSelectedKeys (selectedKeys) {\n            dispatch((state)=>({\n                    ...state,\n                    selectedKeys: selectedKeys\n                }));\n        },\n        setFilterText (filterText) {\n            dispatch((state)=>({\n                    ...state,\n                    filterText: filterText\n                }));\n        },\n        insert (index, ...values) {\n            dispatch((state)=>$0d86e9c8f07f9a7b$var$insert(state, index, ...values));\n        },\n        insertBefore (key, ...values) {\n            dispatch((state)=>{\n                let index = state.items.findIndex((item)=>getKey(item) === key);\n                if (index === -1) {\n                    if (state.items.length === 0) index = 0;\n                    else return state;\n                }\n                return $0d86e9c8f07f9a7b$var$insert(state, index, ...values);\n            });\n        },\n        insertAfter (key, ...values) {\n            dispatch((state)=>{\n                let index = state.items.findIndex((item)=>getKey(item) === key);\n                if (index === -1) {\n                    if (state.items.length === 0) index = 0;\n                    else return state;\n                }\n                return $0d86e9c8f07f9a7b$var$insert(state, index + 1, ...values);\n            });\n        },\n        prepend (...values) {\n            dispatch((state)=>$0d86e9c8f07f9a7b$var$insert(state, 0, ...values));\n        },\n        append (...values) {\n            dispatch((state)=>$0d86e9c8f07f9a7b$var$insert(state, state.items.length, ...values));\n        },\n        remove (...keys) {\n            dispatch((state)=>{\n                let keySet = new Set(keys);\n                let items = state.items.filter((item)=>!keySet.has(getKey(item)));\n                let selection = \"all\";\n                if (state.selectedKeys !== \"all\") {\n                    selection = new Set(state.selectedKeys);\n                    for (let key of keys)selection.delete(key);\n                }\n                if (cursor == null && items.length === 0) selection = new Set();\n                return {\n                    ...state,\n                    items: items,\n                    selectedKeys: selection\n                };\n            });\n        },\n        removeSelectedItems () {\n            dispatch((state)=>{\n                if (state.selectedKeys === \"all\") return {\n                    ...state,\n                    items: [],\n                    selectedKeys: new Set()\n                };\n                let selectedKeys = state.selectedKeys;\n                let items = state.items.filter((item)=>!selectedKeys.has(getKey(item)));\n                return {\n                    ...state,\n                    items: items,\n                    selectedKeys: new Set()\n                };\n            });\n        },\n        move (key, toIndex) {\n            dispatch((state)=>{\n                let index = state.items.findIndex((item)=>getKey(item) === key);\n                if (index === -1) return state;\n                let copy = state.items.slice();\n                let [item] = copy.splice(index, 1);\n                copy.splice(toIndex, 0, item);\n                return {\n                    ...state,\n                    items: copy\n                };\n            });\n        },\n        moveBefore (key, keys) {\n            dispatch((state)=>{\n                let toIndex = state.items.findIndex((item)=>getKey(item) === key);\n                if (toIndex === -1) return state;\n                // Find indices of keys to move. Sort them so that the order in the list is retained.\n                let keyArray = Array.isArray(keys) ? keys : [\n                    ...keys\n                ];\n                let indices = keyArray.map((key)=>state.items.findIndex((item)=>getKey(item) === key)).sort();\n                return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex);\n            });\n        },\n        moveAfter (key, keys) {\n            dispatch((state)=>{\n                let toIndex = state.items.findIndex((item)=>getKey(item) === key);\n                if (toIndex === -1) return state;\n                let keyArray = Array.isArray(keys) ? keys : [\n                    ...keys\n                ];\n                let indices = keyArray.map((key)=>state.items.findIndex((item)=>getKey(item) === key)).sort();\n                return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex + 1);\n            });\n        },\n        update (key, newValue) {\n            dispatch((state)=>{\n                let index = state.items.findIndex((item)=>getKey(item) === key);\n                if (index === -1) return state;\n                return {\n                    ...state,\n                    items: [\n                        ...state.items.slice(0, index),\n                        newValue,\n                        ...state.items.slice(index + 1)\n                    ]\n                };\n            });\n        }\n    };\n}\nfunction $0d86e9c8f07f9a7b$var$insert(state, index, ...values) {\n    return {\n        ...state,\n        items: [\n            ...state.items.slice(0, index),\n            ...values,\n            ...state.items.slice(index)\n        ]\n    };\n}\nfunction $0d86e9c8f07f9a7b$var$move(state, indices, toIndex) {\n    // Shift the target down by the number of items being moved from before the target\n    toIndex -= indices.filter((index)=>index < toIndex).length;\n    let moves = indices.map((from)=>({\n            from: from,\n            to: toIndex++\n        }));\n    // Shift later from indices down if they have a larger index\n    for(let i = 0; i < moves.length; i++){\n        let a = moves[i].from;\n        for(let j = i; j < moves.length; j++){\n            let b = moves[j].from;\n            if (b > a) moves[j].from--;\n        }\n    }\n    // Interleave the moves so they can be applied one by one rather than all at once\n    for(let i = 0; i < moves.length; i++){\n        let a = moves[i];\n        for(let j = moves.length - 1; j > i; j--){\n            let b = moves[j];\n            if (b.from < a.to) a.to++;\n            else b.from++;\n        }\n    }\n    let copy = state.items.slice();\n    for (let move of moves){\n        let [item] = copy.splice(move.from, 1);\n        copy.splice(move.to, 0, item);\n    }\n    return {\n        ...state,\n        items: copy\n    };\n}\nfunction $f86e6c1ec7da6ebb$var$reducer(data, action) {\n    let selectedKeys;\n    switch(data.state){\n        case \"idle\":\n        case \"error\":\n            switch(action.type){\n                case \"loading\":\n                case \"loadingMore\":\n                case \"sorting\":\n                case \"filtering\":\n                    var _action_filterText, _action_sortDescriptor;\n                    return {\n                        ...data,\n                        filterText: (_action_filterText = action.filterText) !== null && _action_filterText !== void 0 ? _action_filterText : data.filterText,\n                        state: action.type,\n                        // Reset items to an empty list if loading, but not when sorting.\n                        items: action.type === \"loading\" ? [] : data.items,\n                        sortDescriptor: (_action_sortDescriptor = action.sortDescriptor) !== null && _action_sortDescriptor !== void 0 ? _action_sortDescriptor : data.sortDescriptor,\n                        abortController: action.abortController\n                    };\n                case \"update\":\n                    return {\n                        ...data,\n                        ...action.updater(data)\n                    };\n                case \"success\":\n                case \"error\":\n                    return data;\n                default:\n                    throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n            }\n        case \"loading\":\n        case \"sorting\":\n        case \"filtering\":\n            switch(action.type){\n                case \"success\":\n                    // Ignore if there is a newer abortcontroller in state.\n                    // This means that multiple requests were going at once.\n                    // We want to take only the latest result.\n                    if (action.abortController !== data.abortController) return data;\n                    var _action_selectedKeys;\n                    selectedKeys = (_action_selectedKeys = action.selectedKeys) !== null && _action_selectedKeys !== void 0 ? _action_selectedKeys : data.selectedKeys;\n                    var _action_filterText1, _action_sortDescriptor1;\n                    return {\n                        ...data,\n                        filterText: (_action_filterText1 = action.filterText) !== null && _action_filterText1 !== void 0 ? _action_filterText1 : data.filterText,\n                        state: \"idle\",\n                        items: [\n                            ...action.items\n                        ],\n                        selectedKeys: selectedKeys === \"all\" ? \"all\" : new Set(selectedKeys),\n                        sortDescriptor: (_action_sortDescriptor1 = action.sortDescriptor) !== null && _action_sortDescriptor1 !== void 0 ? _action_sortDescriptor1 : data.sortDescriptor,\n                        abortController: null,\n                        cursor: action.cursor\n                    };\n                case \"error\":\n                    if (action.abortController !== data.abortController) return data;\n                    return {\n                        ...data,\n                        state: \"error\",\n                        error: action.error,\n                        abortController: null\n                    };\n                case \"loading\":\n                case \"loadingMore\":\n                case \"sorting\":\n                case \"filtering\":\n                    // We're already loading, and another load was triggered at the same time.\n                    // We need to abort the previous load and start a new one.\n                    data.abortController.abort();\n                    var _action_filterText2;\n                    return {\n                        ...data,\n                        filterText: (_action_filterText2 = action.filterText) !== null && _action_filterText2 !== void 0 ? _action_filterText2 : data.filterText,\n                        state: action.type,\n                        // Reset items to an empty list if loading, but not when sorting.\n                        items: action.type === \"loading\" ? [] : data.items,\n                        abortController: action.abortController\n                    };\n                case \"update\":\n                    // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n                    // Update data but don't abort previous load.\n                    return {\n                        ...data,\n                        ...action.updater(data)\n                    };\n                default:\n                    throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n            }\n        case \"loadingMore\":\n            switch(action.type){\n                case \"success\":\n                    var _action_selectedKeys1;\n                    selectedKeys = data.selectedKeys === \"all\" || action.selectedKeys === \"all\" ? \"all\" : new Set([\n                        ...data.selectedKeys,\n                        ...(_action_selectedKeys1 = action.selectedKeys) !== null && _action_selectedKeys1 !== void 0 ? _action_selectedKeys1 : []\n                    ]);\n                    var _action_sortDescriptor2;\n                    // Append the new items\n                    return {\n                        ...data,\n                        state: \"idle\",\n                        items: [\n                            ...data.items,\n                            ...action.items\n                        ],\n                        selectedKeys: selectedKeys,\n                        sortDescriptor: (_action_sortDescriptor2 = action.sortDescriptor) !== null && _action_sortDescriptor2 !== void 0 ? _action_sortDescriptor2 : data.sortDescriptor,\n                        abortController: null,\n                        cursor: action.cursor\n                    };\n                case \"error\":\n                    if (action.abortController !== data.abortController) return data;\n                    return {\n                        ...data,\n                        state: \"error\",\n                        error: action.error\n                    };\n                case \"loading\":\n                case \"sorting\":\n                case \"filtering\":\n                    // We're already loading more, and another load was triggered at the same time.\n                    // We need to abort the previous load more and start a new one.\n                    data.abortController.abort();\n                    var _action_filterText3;\n                    return {\n                        ...data,\n                        filterText: (_action_filterText3 = action.filterText) !== null && _action_filterText3 !== void 0 ? _action_filterText3 : data.filterText,\n                        state: action.type,\n                        // Reset items to an empty list if loading, but not when sorting.\n                        items: action.type === \"loading\" ? [] : data.items,\n                        abortController: action.abortController\n                    };\n                case \"loadingMore\":\n                    // If already loading more and another loading more is triggered, abort the new load more since\n                    // it is a duplicate request since the cursor hasn't been updated.\n                    // Do not overwrite the data.abortController\n                    action.abortController.abort();\n                    return data;\n                case \"update\":\n                    // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n                    // Update data but don't abort previous load.\n                    return {\n                        ...data,\n                        ...action.updater(data)\n                    };\n                default:\n                    throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n            }\n        default:\n            throw new Error(`Invalid state \"${data.state}\"`);\n    }\n}\nfunction $f86e6c1ec7da6ebb$export$bc3384a35de93d66(options) {\n    const { load: load, sort: sort, initialSelectedKeys: initialSelectedKeys, initialSortDescriptor: initialSortDescriptor, getKey: getKey = (item)=>item.id || item.key, initialFilterText: initialFilterText = \"\" } = options;\n    let [data, dispatch] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useReducer)($f86e6c1ec7da6ebb$var$reducer, {\n        state: \"idle\",\n        error: null,\n        items: [],\n        selectedKeys: initialSelectedKeys === \"all\" ? \"all\" : new Set(initialSelectedKeys),\n        sortDescriptor: initialSortDescriptor,\n        filterText: initialFilterText\n    });\n    const dispatchFetch = async (action, fn)=>{\n        let abortController = new AbortController();\n        try {\n            dispatch({\n                ...action,\n                abortController: abortController\n            });\n            var _action_filterText;\n            let previousFilterText = (_action_filterText = action.filterText) !== null && _action_filterText !== void 0 ? _action_filterText : data.filterText;\n            var _action_sortDescriptor;\n            let response = await fn({\n                items: data.items.slice(),\n                selectedKeys: data.selectedKeys,\n                sortDescriptor: (_action_sortDescriptor = action.sortDescriptor) !== null && _action_sortDescriptor !== void 0 ? _action_sortDescriptor : data.sortDescriptor,\n                signal: abortController.signal,\n                cursor: action.type === \"loadingMore\" ? data.cursor : null,\n                filterText: previousFilterText\n            });\n            var _response_filterText;\n            let filterText = (_response_filterText = response.filterText) !== null && _response_filterText !== void 0 ? _response_filterText : previousFilterText;\n            dispatch({\n                type: \"success\",\n                ...response,\n                abortController: abortController\n            });\n            // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n            // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n            if (filterText && filterText !== previousFilterText && !abortController.signal.aborted) dispatchFetch({\n                type: \"filtering\",\n                filterText: filterText\n            }, load);\n        } catch (e) {\n            dispatch({\n                type: \"error\",\n                error: e,\n                abortController: abortController\n            });\n        }\n    };\n    let didDispatchInitialFetch = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!didDispatchInitialFetch.current) {\n            dispatchFetch({\n                type: \"loading\"\n            }, load);\n            didDispatchInitialFetch.current = true;\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return {\n        items: data.items,\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: data.sortDescriptor,\n        isLoading: data.state === \"loading\" || data.state === \"loadingMore\" || data.state === \"sorting\" || data.state === \"filtering\",\n        loadingState: data.state,\n        error: data.error,\n        filterText: data.filterText,\n        getItem (key) {\n            return data.items.find((item)=>getKey(item) === key);\n        },\n        reload () {\n            dispatchFetch({\n                type: \"loading\"\n            }, load);\n        },\n        loadMore () {\n            // Ignore if already loading more or if performing server side filtering.\n            if (data.state === \"loadingMore\" || data.state === \"filtering\" || data.cursor == null) return;\n            dispatchFetch({\n                type: \"loadingMore\"\n            }, load);\n        },\n        sort (sortDescriptor) {\n            dispatchFetch({\n                type: \"sorting\",\n                sortDescriptor: sortDescriptor\n            }, sort || load);\n        },\n        ...(0, $0d86e9c8f07f9a7b$export$79c0c687a5963b0a)({\n            ...options,\n            getKey: getKey,\n            cursor: data.cursor\n        }, (fn)=>{\n            dispatch({\n                type: \"update\",\n                updater: fn\n            });\n        }),\n        setFilterText (filterText) {\n            dispatchFetch({\n                type: \"filtering\",\n                filterText: filterText\n            }, load);\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $be2ea0343af54212$export$d14e1352e21f4a16(options) {\n    let { initialItems: initialItems = [], initialSelectedKeys: initialSelectedKeys, getKey: getKey = (item)=>item.id || item.key, getChildren: getChildren = (item)=>item.children } = options;\n    let map = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new Map(), []);\n    // We only want to compute this on initial render.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    let initialNodes = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>buildTree(initialItems), []);\n    let [items, setItems] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialNodes);\n    let [selectedKeys, setSelectedKeys] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(new Set(initialSelectedKeys || []));\n    function buildTree(initialItems = [], parentKey) {\n        return initialItems.map((item)=>{\n            let node = {\n                key: getKey(item),\n                parentKey: parentKey,\n                value: item,\n                children: null\n            };\n            node.children = buildTree(getChildren(item), node.key);\n            map.set(node.key, node);\n            return node;\n        });\n    }\n    function updateTree(items, key, update) {\n        let node = map.get(key);\n        if (!node) return items;\n        // Create a new node. If null, then delete the node, otherwise replace.\n        let newNode = update(node);\n        if (newNode == null) deleteNode(node);\n        else addNode(newNode);\n        // Walk up the tree and update each parent to refer to the new chilren.\n        while(node.parentKey){\n            let nextParent = map.get(node.parentKey);\n            let copy = {\n                key: nextParent.key,\n                parentKey: nextParent.parentKey,\n                value: nextParent.value,\n                children: null\n            };\n            let children = nextParent.children;\n            if (newNode == null) children = children.filter((c)=>c !== node);\n            copy.children = children.map((child)=>{\n                if (child === node) return newNode;\n                return child;\n            });\n            map.set(copy.key, copy);\n            newNode = copy;\n            node = nextParent;\n        }\n        if (newNode == null) items = items.filter((c)=>c !== node);\n        return items.map((item)=>{\n            if (item === node) return newNode;\n            return item;\n        });\n    }\n    function addNode(node) {\n        map.set(node.key, node);\n        for (let child of node.children)addNode(child);\n    }\n    function deleteNode(node) {\n        map.delete(node.key);\n        for (let child of node.children)deleteNode(child);\n    }\n    return {\n        items: items,\n        selectedKeys: selectedKeys,\n        setSelectedKeys: setSelectedKeys,\n        getItem (key) {\n            return map.get(key);\n        },\n        insert (parentKey, index, ...values) {\n            setItems((items)=>{\n                let nodes = buildTree(values, parentKey);\n                // If parentKey is null, insert into the root.\n                if (parentKey == null) return [\n                    ...items.slice(0, index),\n                    ...nodes,\n                    ...items.slice(index)\n                ];\n                // Otherwise, update the parent node and its ancestors.\n                return updateTree(items, parentKey, (parentNode)=>({\n                        key: parentNode.key,\n                        parentKey: parentNode.parentKey,\n                        value: parentNode.value,\n                        children: [\n                            ...parentNode.children.slice(0, index),\n                            ...nodes,\n                            ...parentNode.children.slice(index)\n                        ]\n                    }));\n            });\n        },\n        insertBefore (key, ...values) {\n            let node = map.get(key);\n            if (!node) return;\n            let parentNode = map.get(node.parentKey);\n            let nodes = parentNode ? parentNode.children : items;\n            let index = nodes.indexOf(node);\n            this.insert(parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index, ...values);\n        },\n        insertAfter (key, ...values) {\n            let node = map.get(key);\n            if (!node) return;\n            let parentNode = map.get(node.parentKey);\n            let nodes = parentNode ? parentNode.children : items;\n            let index = nodes.indexOf(node);\n            this.insert(parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index + 1, ...values);\n        },\n        prepend (parentKey, ...values) {\n            this.insert(parentKey, 0, ...values);\n        },\n        append (parentKey, ...values) {\n            if (parentKey == null) this.insert(null, items.length, ...values);\n            else {\n                let parentNode = map.get(parentKey);\n                if (!parentNode) return;\n                this.insert(parentKey, parentNode.children.length, ...values);\n            }\n        },\n        remove (...keys) {\n            let newItems = items;\n            for (let key of keys)newItems = updateTree(newItems, key, ()=>null);\n            setItems(newItems);\n            let selection = new Set(selectedKeys);\n            for (let key of selectedKeys)if (!map.has(key)) selection.delete(key);\n            setSelectedKeys(selection);\n        },\n        removeSelectedItems () {\n            this.remove(...selectedKeys);\n        },\n        move (key, toParentKey, index) {\n            setItems((items)=>{\n                let node = map.get(key);\n                if (!node) return items;\n                items = updateTree(items, key, ()=>null);\n                const movedNode = {\n                    ...node,\n                    parentKey: toParentKey\n                };\n                // If parentKey is null, insert into the root.\n                if (toParentKey == null) return [\n                    ...items.slice(0, index),\n                    movedNode,\n                    ...items.slice(index)\n                ];\n                // Otherwise, update the parent node and its ancestors.\n                return updateTree(items, toParentKey, (parentNode)=>({\n                        key: parentNode.key,\n                        parentKey: parentNode.parentKey,\n                        value: parentNode.value,\n                        children: [\n                            ...parentNode.children.slice(0, index),\n                            movedNode,\n                            ...parentNode.children.slice(index)\n                        ]\n                    }));\n            });\n        },\n        update (oldKey, newValue) {\n            setItems((items)=>updateTree(items, oldKey, (oldNode)=>{\n                    let node = {\n                        key: oldNode.key,\n                        parentKey: oldNode.parentKey,\n                        value: newValue,\n                        children: null\n                    };\n                    node.children = buildTree(getChildren(newValue), node.key);\n                    return node;\n                }));\n        }\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZGF0YS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzSztBQUV0Szs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FDRCxTQUFTVSwwQ0FBMENDLE9BQU87SUFDdEQsSUFBSSxFQUFFQyxjQUFjQSxlQUFlLEVBQUUsRUFBRUMscUJBQXFCQSxtQkFBbUIsRUFBRUMsUUFBUUEsU0FBUyxDQUFDQyxPQUFPQSxLQUFLQyxFQUFFLElBQUlELEtBQUtFLEdBQUcsRUFBRUMsUUFBUUEsTUFBTSxFQUFFQyxtQkFBbUJBLG9CQUFvQixFQUFFLEVBQUUsR0FBR1I7SUFDN0wsdUZBQXVGO0lBQ3ZGLElBQUksQ0FBQ1MsT0FBT0MsU0FBUyxHQUFHLENBQUMsR0FBR2QsMkNBQWMsRUFBRztRQUN6Q2UsT0FBT1Y7UUFDUFcsY0FBY1Ysd0JBQXdCLFFBQVEsUUFBUSxJQUFJVyxJQUFJWCx1QkFBdUIsRUFBRTtRQUN2RlksWUFBWU47SUFDaEI7SUFDQSxJQUFJTyxnQkFBZ0IsQ0FBQyxHQUFHakIsMENBQWEsRUFBRyxJQUFJUyxTQUFTRSxNQUFNRSxLQUFLLENBQUNKLE1BQU0sQ0FBQyxDQUFDSCxPQUFPRyxPQUFPSCxNQUFNSyxNQUFNSyxVQUFVLEtBQUtMLE1BQU1FLEtBQUssRUFBRTtRQUMzSEYsTUFBTUUsS0FBSztRQUNYRixNQUFNSyxVQUFVO1FBQ2hCUDtLQUNIO0lBQ0QsT0FBTztRQUNILEdBQUdFLEtBQUs7UUFDUkUsT0FBT0k7UUFDUCxHQUFHQywwQ0FBMEM7WUFDekNiLFFBQVFBO1FBQ1osR0FBR08sU0FBUztRQUNaTyxTQUFTWCxHQUFHO1lBQ1IsT0FBT0csTUFBTUUsS0FBSyxDQUFDTyxJQUFJLENBQUMsQ0FBQ2QsT0FBT0QsT0FBT0MsVUFBVUU7UUFDckQ7SUFDSjtBQUNKO0FBQ0EsU0FBU1UsMENBQTBDRyxJQUFJLEVBQUVDLFFB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QyxLQUFLLENBQUNuQjtpQkFDbEI7Z0JBQ0QsdURBQXVEO2dCQUN2RCxPQUFPdUYsV0FBV3JHLE9BQU9pSCxhQUFhLENBQUNILGFBQWM7d0JBQzdDbkgsS0FBS21ILFdBQVduSCxHQUFHO3dCQUNuQnNHLFdBQVdhLFdBQVdiLFNBQVM7d0JBQy9CRSxPQUFPVyxXQUFXWCxLQUFLO3dCQUN2QlAsVUFBVTsrQkFDSGtCLFdBQVdsQixRQUFRLENBQUMzRCxLQUFLLENBQUMsR0FBR25COzRCQUNoQ29HOytCQUNHSixXQUFXbEIsUUFBUSxDQUFDM0QsS0FBSyxDQUFDbkI7eUJBQ2hDO29CQUNMO1lBQ1I7UUFDSjtRQUNBOEIsUUFBUXVFLE1BQU0sRUFBRXRFLFFBQVE7WUFDcEJtRCxTQUFTLENBQUNoRyxRQUFRcUcsV0FBV3JHLE9BQU9tSCxRQUFRLENBQUNDO29CQUNyQyxJQUFJbEIsT0FBTzt3QkFDUHZHLEtBQUt5SCxRQUFRekgsR0FBRzt3QkFDaEJzRyxXQUFXbUIsUUFBUW5CLFNBQVM7d0JBQzVCRSxPQUFPdEQ7d0JBQ1ArQyxVQUFVO29CQUNkO29CQUNBTSxLQUFLTixRQUFRLEdBQUdHLFVBQVVKLFlBQVk5QyxXQUFXcUQsS0FBS3ZHLEdBQUc7b0JBQ3pELE9BQU91RztnQkFDWDtRQUNSO0lBQ0o7QUFDSjtBQU11TCxDQUN2TCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZXVzLW5leHQtYXBwLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2RhdGEvZGlzdC9pbXBvcnQubWpzP2RhYzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VSZWR1Y2VyIGFzICRkNzBBcSR1c2VSZWR1Y2VyLCB1c2VSZWYgYXMgJGQ3MEFxJHVzZVJlZiwgdXNlRWZmZWN0IGFzICRkNzBBcSR1c2VFZmZlY3QsIHVzZVN0YXRlIGFzICRkNzBBcSR1c2VTdGF0ZSwgdXNlTWVtbyBhcyAkZDcwQXEkdXNlTWVtb30gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDBkODZlOWM4ZjA3ZjlhN2IkZXhwb3J0JDc2MmY3M2RjY2NjZDI1NWQob3B0aW9ucykge1xuICAgIGxldCB7IGluaXRpYWxJdGVtczogaW5pdGlhbEl0ZW1zID0gW10sIGluaXRpYWxTZWxlY3RlZEtleXM6IGluaXRpYWxTZWxlY3RlZEtleXMsIGdldEtleTogZ2V0S2V5ID0gKGl0ZW0pPT5pdGVtLmlkIHx8IGl0ZW0ua2V5LCBmaWx0ZXI6IGZpbHRlciwgaW5pdGlhbEZpbHRlclRleHQ6IGluaXRpYWxGaWx0ZXJUZXh0ID0gXCJcIiB9ID0gb3B0aW9ucztcbiAgICAvLyBTdG9yZSBib3RoIGl0ZW1zIGFuZCBmaWx0ZXJlZEl0ZW1zIGluIHN0YXRlIHNvIHdlIGNhbiBnbyBiYWNrIHRvIHRoZSB1bmZpbHRlcmVkIGxpc3RcbiAgICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSAoMCwgJGQ3MEFxJHVzZVN0YXRlKSh7XG4gICAgICAgIGl0ZW1zOiBpbml0aWFsSXRlbXMsXG4gICAgICAgIHNlbGVjdGVkS2V5czogaW5pdGlhbFNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIiA/IFwiYWxsXCIgOiBuZXcgU2V0KGluaXRpYWxTZWxlY3RlZEtleXMgfHwgW10pLFxuICAgICAgICBmaWx0ZXJUZXh0OiBpbml0aWFsRmlsdGVyVGV4dFxuICAgIH0pO1xuICAgIGxldCBmaWx0ZXJlZEl0ZW1zID0gKDAsICRkNzBBcSR1c2VNZW1vKSgoKT0+ZmlsdGVyID8gc3RhdGUuaXRlbXMuZmlsdGVyKChpdGVtKT0+ZmlsdGVyKGl0ZW0sIHN0YXRlLmZpbHRlclRleHQpKSA6IHN0YXRlLml0ZW1zLCBbXG4gICAgICAgIHN0YXRlLml0ZW1zLFxuICAgICAgICBzdGF0ZS5maWx0ZXJUZXh0LFxuICAgICAgICBmaWx0ZXJcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgaXRlbXM6IGZpbHRlcmVkSXRlbXMsXG4gICAgICAgIC4uLiQwZDg2ZTljOGYwN2Y5YTdiJGV4cG9ydCQ3OWMwYzY4N2E1OTYzYjBhKHtcbiAgICAgICAgICAgIGdldEtleTogZ2V0S2V5XG4gICAgICAgIH0sIHNldFN0YXRlKSxcbiAgICAgICAgZ2V0SXRlbSAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuaXRlbXMuZmluZCgoaXRlbSk9PmdldEtleShpdGVtKSA9PT0ga2V5KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiAkMGQ4NmU5YzhmMDdmOWE3YiRleHBvcnQkNzljMGM2ODdhNTk2M2IwYShvcHRzLCBkaXNwYXRjaCkge1xuICAgIGxldCB7IGN1cnNvcjogY3Vyc29yLCBnZXRLZXk6IGdldEtleSB9ID0gb3B0cztcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRTZWxlY3RlZEtleXMgKHNlbGVjdGVkS2V5cykge1xuICAgICAgICAgICAgZGlzcGF0Y2goKHN0YXRlKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkS2V5czogc2VsZWN0ZWRLZXlzXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRGaWx0ZXJUZXh0IChmaWx0ZXJUZXh0KSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgoc3RhdGUpPT4oe1xuICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogZmlsdGVyVGV4dFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0IChpbmRleCwgLi4udmFsdWVzKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgoc3RhdGUpPT4kMGQ4NmU5YzhmMDdmOWE3YiR2YXIkaW5zZXJ0KHN0YXRlLCBpbmRleCwgLi4udmFsdWVzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydEJlZm9yZSAoa2V5LCAuLi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKChzdGF0ZSk9PntcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBzdGF0ZS5pdGVtcy5maW5kSW5kZXgoKGl0ZW0pPT5nZXRLZXkoaXRlbSkgPT09IGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXRlbXMubGVuZ3RoID09PSAwKSBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJDBkODZlOWM4ZjA3ZjlhN2IkdmFyJGluc2VydChzdGF0ZSwgaW5kZXgsIC4uLnZhbHVlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0QWZ0ZXIgKGtleSwgLi4udmFsdWVzKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgoc3RhdGUpPT57XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gc3RhdGUuaXRlbXMuZmluZEluZGV4KChpdGVtKT0+Z2V0S2V5KGl0ZW0pID09PSBrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLml0ZW1zLmxlbmd0aCA9PT0gMCkgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICQwZDg2ZTljOGYwN2Y5YTdiJHZhciRpbnNlcnQoc3RhdGUsIGluZGV4ICsgMSwgLi4udmFsdWVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBwcmVwZW5kICguLi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKChzdGF0ZSk9PiQwZDg2ZTljOGYwN2Y5YTdiJHZhciRpbnNlcnQoc3RhdGUsIDAsIC4uLnZhbHVlcykpO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmQgKC4uLnZhbHVlcykge1xuICAgICAgICAgICAgZGlzcGF0Y2goKHN0YXRlKT0+JDBkODZlOWM4ZjA3ZjlhN2IkdmFyJGluc2VydChzdGF0ZSwgc3RhdGUuaXRlbXMubGVuZ3RoLCAuLi52YWx1ZXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlICguLi5rZXlzKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgoc3RhdGUpPT57XG4gICAgICAgICAgICAgICAgbGV0IGtleVNldCA9IG5ldyBTZXQoa2V5cyk7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gc3RhdGUuaXRlbXMuZmlsdGVyKChpdGVtKT0+IWtleVNldC5oYXMoZ2V0S2V5KGl0ZW0pKSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IFwiYWxsXCI7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGVkS2V5cyAhPT0gXCJhbGxcIikge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBuZXcgU2V0KHN0YXRlLnNlbGVjdGVkS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBrZXlzKXNlbGVjdGlvbi5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvciA9PSBudWxsICYmIGl0ZW1zLmxlbmd0aCA9PT0gMCkgc2VsZWN0aW9uID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkS2V5czogc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVTZWxlY3RlZEl0ZW1zICgpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKChzdGF0ZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEtleXM6IG5ldyBTZXQoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkS2V5cyA9IHN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBzdGF0ZS5pdGVtcy5maWx0ZXIoKGl0ZW0pPT4hc2VsZWN0ZWRLZXlzLmhhcyhnZXRLZXkoaXRlbSkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEtleXM6IG5ldyBTZXQoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbW92ZSAoa2V5LCB0b0luZGV4KSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgoc3RhdGUpPT57XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gc3RhdGUuaXRlbXMuZmluZEluZGV4KChpdGVtKT0+Z2V0S2V5KGl0ZW0pID09PSBrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICBsZXQgY29weSA9IHN0YXRlLml0ZW1zLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgbGV0IFtpdGVtXSA9IGNvcHkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBjb3B5LnNwbGljZSh0b0luZGV4LCAwLCBpdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IGNvcHlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmVCZWZvcmUgKGtleSwga2V5cykge1xuICAgICAgICAgICAgZGlzcGF0Y2goKHN0YXRlKT0+e1xuICAgICAgICAgICAgICAgIGxldCB0b0luZGV4ID0gc3RhdGUuaXRlbXMuZmluZEluZGV4KChpdGVtKT0+Z2V0S2V5KGl0ZW0pID09PSBrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0b0luZGV4ID09PSAtMSkgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgaW5kaWNlcyBvZiBrZXlzIHRvIG1vdmUuIFNvcnQgdGhlbSBzbyB0aGF0IHRoZSBvcmRlciBpbiB0aGUgbGlzdCBpcyByZXRhaW5lZC5cbiAgICAgICAgICAgICAgICBsZXQga2V5QXJyYXkgPSBBcnJheS5pc0FycmF5KGtleXMpID8ga2V5cyA6IFtcbiAgICAgICAgICAgICAgICAgICAgLi4ua2V5c1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSBrZXlBcnJheS5tYXAoKGtleSk9PnN0YXRlLml0ZW1zLmZpbmRJbmRleCgoaXRlbSk9PmdldEtleShpdGVtKSA9PT0ga2V5KSkuc29ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkMGQ4NmU5YzhmMDdmOWE3YiR2YXIkbW92ZShzdGF0ZSwgaW5kaWNlcywgdG9JbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbW92ZUFmdGVyIChrZXksIGtleXMpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKChzdGF0ZSk9PntcbiAgICAgICAgICAgICAgICBsZXQgdG9JbmRleCA9IHN0YXRlLml0ZW1zLmZpbmRJbmRleCgoaXRlbSk9PmdldEtleShpdGVtKSA9PT0ga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodG9JbmRleCA9PT0gLTEpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICBsZXQga2V5QXJyYXkgPSBBcnJheS5pc0FycmF5KGtleXMpID8ga2V5cyA6IFtcbiAgICAgICAgICAgICAgICAgICAgLi4ua2V5c1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSBrZXlBcnJheS5tYXAoKGtleSk9PnN0YXRlLml0ZW1zLmZpbmRJbmRleCgoaXRlbSk9PmdldEtleShpdGVtKSA9PT0ga2V5KSkuc29ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkMGQ4NmU5YzhmMDdmOWE3YiR2YXIkbW92ZShzdGF0ZSwgaW5kaWNlcywgdG9JbmRleCArIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZSAoa2V5LCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZGlzcGF0Y2goKHN0YXRlKT0+e1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IHN0YXRlLml0ZW1zLmZpbmRJbmRleCgoaXRlbSk9PmdldEtleShpdGVtKSA9PT0ga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZS5pdGVtcy5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLml0ZW1zLnNsaWNlKGluZGV4ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiAkMGQ4NmU5YzhmMDdmOWE3YiR2YXIkaW5zZXJ0KHN0YXRlLCBpbmRleCwgLi4udmFsdWVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAuLi5zdGF0ZS5pdGVtcy5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgICAuLi52YWx1ZXMsXG4gICAgICAgICAgICAuLi5zdGF0ZS5pdGVtcy5zbGljZShpbmRleClcbiAgICAgICAgXVxuICAgIH07XG59XG5mdW5jdGlvbiAkMGQ4NmU5YzhmMDdmOWE3YiR2YXIkbW92ZShzdGF0ZSwgaW5kaWNlcywgdG9JbmRleCkge1xuICAgIC8vIFNoaWZ0IHRoZSB0YXJnZXQgZG93biBieSB0aGUgbnVtYmVyIG9mIGl0ZW1zIGJlaW5nIG1vdmVkIGZyb20gYmVmb3JlIHRoZSB0YXJnZXRcbiAgICB0b0luZGV4IC09IGluZGljZXMuZmlsdGVyKChpbmRleCk9PmluZGV4IDwgdG9JbmRleCkubGVuZ3RoO1xuICAgIGxldCBtb3ZlcyA9IGluZGljZXMubWFwKChmcm9tKT0+KHtcbiAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICB0bzogdG9JbmRleCsrXG4gICAgICAgIH0pKTtcbiAgICAvLyBTaGlmdCBsYXRlciBmcm9tIGluZGljZXMgZG93biBpZiB0aGV5IGhhdmUgYSBsYXJnZXIgaW5kZXhcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbW92ZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBsZXQgYSA9IG1vdmVzW2ldLmZyb207XG4gICAgICAgIGZvcihsZXQgaiA9IGk7IGogPCBtb3Zlcy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICBsZXQgYiA9IG1vdmVzW2pdLmZyb207XG4gICAgICAgICAgICBpZiAoYiA+IGEpIG1vdmVzW2pdLmZyb20tLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbnRlcmxlYXZlIHRoZSBtb3ZlcyBzbyB0aGV5IGNhbiBiZSBhcHBsaWVkIG9uZSBieSBvbmUgcmF0aGVyIHRoYW4gYWxsIGF0IG9uY2VcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbW92ZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBsZXQgYSA9IG1vdmVzW2ldO1xuICAgICAgICBmb3IobGV0IGogPSBtb3Zlcy5sZW5ndGggLSAxOyBqID4gaTsgai0tKXtcbiAgICAgICAgICAgIGxldCBiID0gbW92ZXNbal07XG4gICAgICAgICAgICBpZiAoYi5mcm9tIDwgYS50bykgYS50bysrO1xuICAgICAgICAgICAgZWxzZSBiLmZyb20rKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY29weSA9IHN0YXRlLml0ZW1zLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgbW92ZSBvZiBtb3Zlcyl7XG4gICAgICAgIGxldCBbaXRlbV0gPSBjb3B5LnNwbGljZShtb3ZlLmZyb20sIDEpO1xuICAgICAgICBjb3B5LnNwbGljZShtb3ZlLnRvLCAwLCBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGl0ZW1zOiBjb3B5XG4gICAgfTtcbn1cblxuXG5cbmZ1bmN0aW9uICRmODZlNmMxZWM3ZGE2ZWJiJHZhciRyZWR1Y2VyKGRhdGEsIGFjdGlvbikge1xuICAgIGxldCBzZWxlY3RlZEtleXM7XG4gICAgc3dpdGNoKGRhdGEuc3RhdGUpe1xuICAgICAgICBjYXNlIFwiaWRsZVwiOlxuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcImxvYWRpbmdcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwibG9hZGluZ01vcmVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic29ydGluZ1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hY3Rpb25fZmlsdGVyVGV4dCwgX2FjdGlvbl9zb3J0RGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0OiAoX2FjdGlvbl9maWx0ZXJUZXh0ID0gYWN0aW9uLmZpbHRlclRleHQpICE9PSBudWxsICYmIF9hY3Rpb25fZmlsdGVyVGV4dCAhPT0gdm9pZCAwID8gX2FjdGlvbl9maWx0ZXJUZXh0IDogZGF0YS5maWx0ZXJUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGFjdGlvbi50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgaXRlbXMgdG8gYW4gZW1wdHkgbGlzdCBpZiBsb2FkaW5nLCBidXQgbm90IHdoZW4gc29ydGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBhY3Rpb24udHlwZSA9PT0gXCJsb2FkaW5nXCIgPyBbXSA6IGRhdGEuaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0RGVzY3JpcHRvcjogKF9hY3Rpb25fc29ydERlc2NyaXB0b3IgPSBhY3Rpb24uc29ydERlc2NyaXB0b3IpICE9PSBudWxsICYmIF9hY3Rpb25fc29ydERlc2NyaXB0b3IgIT09IHZvaWQgMCA/IF9hY3Rpb25fc29ydERlc2NyaXB0b3IgOiBkYXRhLnNvcnREZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyOiBhY3Rpb24uYWJvcnRDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FzZSBcInVwZGF0ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFjdGlvbi51cGRhdGVyKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFjdGlvbiBcIiR7YWN0aW9uLnR5cGV9XCIgaW4gc3RhdGUgXCIke2RhdGEuc3RhdGV9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcImxvYWRpbmdcIjpcbiAgICAgICAgY2FzZSBcInNvcnRpbmdcIjpcbiAgICAgICAgY2FzZSBcImZpbHRlcmluZ1wiOlxuICAgICAgICAgICAgc3dpdGNoKGFjdGlvbi50eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgaWYgdGhlcmUgaXMgYSBuZXdlciBhYm9ydGNvbnRyb2xsZXIgaW4gc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCBtdWx0aXBsZSByZXF1ZXN0cyB3ZXJlIGdvaW5nIGF0IG9uY2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gdGFrZSBvbmx5IHRoZSBsYXRlc3QgcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLmFib3J0Q29udHJvbGxlciAhPT0gZGF0YS5hYm9ydENvbnRyb2xsZXIpIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2FjdGlvbl9zZWxlY3RlZEtleXM7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkS2V5cyA9IChfYWN0aW9uX3NlbGVjdGVkS2V5cyA9IGFjdGlvbi5zZWxlY3RlZEtleXMpICE9PSBudWxsICYmIF9hY3Rpb25fc2VsZWN0ZWRLZXlzICE9PSB2b2lkIDAgPyBfYWN0aW9uX3NlbGVjdGVkS2V5cyA6IGRhdGEuc2VsZWN0ZWRLZXlzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2FjdGlvbl9maWx0ZXJUZXh0MSwgX2FjdGlvbl9zb3J0RGVzY3JpcHRvcjE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogKF9hY3Rpb25fZmlsdGVyVGV4dDEgPSBhY3Rpb24uZmlsdGVyVGV4dCkgIT09IG51bGwgJiYgX2FjdGlvbl9maWx0ZXJUZXh0MSAhPT0gdm9pZCAwID8gX2FjdGlvbl9maWx0ZXJUZXh0MSA6IGRhdGEuZmlsdGVyVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYWN0aW9uLml0ZW1zXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRLZXlzOiBzZWxlY3RlZEtleXMgPT09IFwiYWxsXCIgPyBcImFsbFwiIDogbmV3IFNldChzZWxlY3RlZEtleXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydERlc2NyaXB0b3I6IChfYWN0aW9uX3NvcnREZXNjcmlwdG9yMSA9IGFjdGlvbi5zb3J0RGVzY3JpcHRvcikgIT09IG51bGwgJiYgX2FjdGlvbl9zb3J0RGVzY3JpcHRvcjEgIT09IHZvaWQgMCA/IF9hY3Rpb25fc29ydERlc2NyaXB0b3IxIDogZGF0YS5zb3J0RGVzY3JpcHRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogYWN0aW9uLmN1cnNvclxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLmFib3J0Q29udHJvbGxlciAhPT0gZGF0YS5hYm9ydENvbnRyb2xsZXIpIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FzZSBcImxvYWRpbmdcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwibG9hZGluZ01vcmVcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic29ydGluZ1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgYWxyZWFkeSBsb2FkaW5nLCBhbmQgYW5vdGhlciBsb2FkIHdhcyB0cmlnZ2VyZWQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBhYm9ydCB0aGUgcHJldmlvdXMgbG9hZCBhbmQgc3RhcnQgYSBuZXcgb25lLlxuICAgICAgICAgICAgICAgICAgICBkYXRhLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2FjdGlvbl9maWx0ZXJUZXh0MjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0OiAoX2FjdGlvbl9maWx0ZXJUZXh0MiA9IGFjdGlvbi5maWx0ZXJUZXh0KSAhPT0gbnVsbCAmJiBfYWN0aW9uX2ZpbHRlclRleHQyICE9PSB2b2lkIDAgPyBfYWN0aW9uX2ZpbHRlclRleHQyIDogZGF0YS5maWx0ZXJUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGFjdGlvbi50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgaXRlbXMgdG8gYW4gZW1wdHkgbGlzdCBpZiBsb2FkaW5nLCBidXQgbm90IHdoZW4gc29ydGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBhY3Rpb24udHlwZSA9PT0gXCJsb2FkaW5nXCIgPyBbXSA6IGRhdGEuaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXI6IGFjdGlvbi5hYm9ydENvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGFscmVhZHkgbG9hZGluZywgYW5kIGFuIHVwZGF0ZSBoYXBwZW5lZCBhdCB0aGUgc2FtZSB0aW1lIChlLmcuIHNlbGVjdGVkS2V5IGNoYW5nZWQpLlxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZGF0YSBidXQgZG9uJ3QgYWJvcnQgcHJldmlvdXMgbG9hZC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hY3Rpb24udXBkYXRlcihkYXRhKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhY3Rpb24gXCIke2FjdGlvbi50eXBlfVwiIGluIHN0YXRlIFwiJHtkYXRhLnN0YXRlfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJsb2FkaW5nTW9yZVwiOlxuICAgICAgICAgICAgc3dpdGNoKGFjdGlvbi50eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgX2FjdGlvbl9zZWxlY3RlZEtleXMxO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEtleXMgPSBkYXRhLnNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIiB8fCBhY3Rpb24uc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiID8gXCJhbGxcIiA6IG5ldyBTZXQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YS5zZWxlY3RlZEtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4oX2FjdGlvbl9zZWxlY3RlZEtleXMxID0gYWN0aW9uLnNlbGVjdGVkS2V5cykgIT09IG51bGwgJiYgX2FjdGlvbl9zZWxlY3RlZEtleXMxICE9PSB2b2lkIDAgPyBfYWN0aW9uX3NlbGVjdGVkS2V5czEgOiBbXVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hY3Rpb25fc29ydERlc2NyaXB0b3IyO1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIG5ldyBpdGVtc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YS5pdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hY3Rpb24uaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEtleXM6IHNlbGVjdGVkS2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnREZXNjcmlwdG9yOiAoX2FjdGlvbl9zb3J0RGVzY3JpcHRvcjIgPSBhY3Rpb24uc29ydERlc2NyaXB0b3IpICE9PSBudWxsICYmIF9hY3Rpb25fc29ydERlc2NyaXB0b3IyICE9PSB2b2lkIDAgPyBfYWN0aW9uX3NvcnREZXNjcmlwdG9yMiA6IGRhdGEuc29ydERlc2NyaXB0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IGFjdGlvbi5jdXJzb3JcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbi5hYm9ydENvbnRyb2xsZXIgIT09IGRhdGEuYWJvcnRDb250cm9sbGVyKSByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGFjdGlvbi5lcnJvclxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsb2FkaW5nXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInNvcnRpbmdcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmlsdGVyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGFscmVhZHkgbG9hZGluZyBtb3JlLCBhbmQgYW5vdGhlciBsb2FkIHdhcyB0cmlnZ2VyZWQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBhYm9ydCB0aGUgcHJldmlvdXMgbG9hZCBtb3JlIGFuZCBzdGFydCBhIG5ldyBvbmUuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYWN0aW9uX2ZpbHRlclRleHQzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclRleHQ6IChfYWN0aW9uX2ZpbHRlclRleHQzID0gYWN0aW9uLmZpbHRlclRleHQpICE9PSBudWxsICYmIF9hY3Rpb25fZmlsdGVyVGV4dDMgIT09IHZvaWQgMCA/IF9hY3Rpb25fZmlsdGVyVGV4dDMgOiBkYXRhLmZpbHRlclRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogYWN0aW9uLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBpdGVtcyB0byBhbiBlbXB0eSBsaXN0IGlmIGxvYWRpbmcsIGJ1dCBub3Qgd2hlbiBzb3J0aW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IGFjdGlvbi50eXBlID09PSBcImxvYWRpbmdcIiA/IFtdIDogZGF0YS5pdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcjogYWN0aW9uLmFib3J0Q29udHJvbGxlclxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsb2FkaW5nTW9yZVwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhbHJlYWR5IGxvYWRpbmcgbW9yZSBhbmQgYW5vdGhlciBsb2FkaW5nIG1vcmUgaXMgdHJpZ2dlcmVkLCBhYm9ydCB0aGUgbmV3IGxvYWQgbW9yZSBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBpcyBhIGR1cGxpY2F0ZSByZXF1ZXN0IHNpbmNlIHRoZSBjdXJzb3IgaGFzbid0IGJlZW4gdXBkYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IG92ZXJ3cml0ZSB0aGUgZGF0YS5hYm9ydENvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGFscmVhZHkgbG9hZGluZywgYW5kIGFuIHVwZGF0ZSBoYXBwZW5lZCBhdCB0aGUgc2FtZSB0aW1lIChlLmcuIHNlbGVjdGVkS2V5IGNoYW5nZWQpLlxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZGF0YSBidXQgZG9uJ3QgYWJvcnQgcHJldmlvdXMgbG9hZC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hY3Rpb24udXBkYXRlcihkYXRhKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhY3Rpb24gXCIke2FjdGlvbi50eXBlfVwiIGluIHN0YXRlIFwiJHtkYXRhLnN0YXRlfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdGUgXCIke2RhdGEuc3RhdGV9XCJgKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkZjg2ZTZjMWVjN2RhNmViYiRleHBvcnQkYmMzMzg0YTM1ZGU5M2Q2NihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBsb2FkOiBsb2FkLCBzb3J0OiBzb3J0LCBpbml0aWFsU2VsZWN0ZWRLZXlzOiBpbml0aWFsU2VsZWN0ZWRLZXlzLCBpbml0aWFsU29ydERlc2NyaXB0b3I6IGluaXRpYWxTb3J0RGVzY3JpcHRvciwgZ2V0S2V5OiBnZXRLZXkgPSAoaXRlbSk9Pml0ZW0uaWQgfHwgaXRlbS5rZXksIGluaXRpYWxGaWx0ZXJUZXh0OiBpbml0aWFsRmlsdGVyVGV4dCA9IFwiXCIgfSA9IG9wdGlvbnM7XG4gICAgbGV0IFtkYXRhLCBkaXNwYXRjaF0gPSAoMCwgJGQ3MEFxJHVzZVJlZHVjZXIpKCRmODZlNmMxZWM3ZGE2ZWJiJHZhciRyZWR1Y2VyLCB7XG4gICAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgc2VsZWN0ZWRLZXlzOiBpbml0aWFsU2VsZWN0ZWRLZXlzID09PSBcImFsbFwiID8gXCJhbGxcIiA6IG5ldyBTZXQoaW5pdGlhbFNlbGVjdGVkS2V5cyksXG4gICAgICAgIHNvcnREZXNjcmlwdG9yOiBpbml0aWFsU29ydERlc2NyaXB0b3IsXG4gICAgICAgIGZpbHRlclRleHQ6IGluaXRpYWxGaWx0ZXJUZXh0XG4gICAgfSk7XG4gICAgY29uc3QgZGlzcGF0Y2hGZXRjaCA9IGFzeW5jIChhY3Rpb24sIGZuKT0+e1xuICAgICAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIC4uLmFjdGlvbixcbiAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXI6IGFib3J0Q29udHJvbGxlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2FjdGlvbl9maWx0ZXJUZXh0O1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzRmlsdGVyVGV4dCA9IChfYWN0aW9uX2ZpbHRlclRleHQgPSBhY3Rpb24uZmlsdGVyVGV4dCkgIT09IG51bGwgJiYgX2FjdGlvbl9maWx0ZXJUZXh0ICE9PSB2b2lkIDAgPyBfYWN0aW9uX2ZpbHRlclRleHQgOiBkYXRhLmZpbHRlclRleHQ7XG4gICAgICAgICAgICB2YXIgX2FjdGlvbl9zb3J0RGVzY3JpcHRvcjtcbiAgICAgICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZuKHtcbiAgICAgICAgICAgICAgICBpdGVtczogZGF0YS5pdGVtcy5zbGljZSgpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkS2V5czogZGF0YS5zZWxlY3RlZEtleXMsXG4gICAgICAgICAgICAgICAgc29ydERlc2NyaXB0b3I6IChfYWN0aW9uX3NvcnREZXNjcmlwdG9yID0gYWN0aW9uLnNvcnREZXNjcmlwdG9yKSAhPT0gbnVsbCAmJiBfYWN0aW9uX3NvcnREZXNjcmlwdG9yICE9PSB2b2lkIDAgPyBfYWN0aW9uX3NvcnREZXNjcmlwdG9yIDogZGF0YS5zb3J0RGVzY3JpcHRvcixcbiAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgICAgY3Vyc29yOiBhY3Rpb24udHlwZSA9PT0gXCJsb2FkaW5nTW9yZVwiID8gZGF0YS5jdXJzb3IgOiBudWxsLFxuICAgICAgICAgICAgICAgIGZpbHRlclRleHQ6IHByZXZpb3VzRmlsdGVyVGV4dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX3Jlc3BvbnNlX2ZpbHRlclRleHQ7XG4gICAgICAgICAgICBsZXQgZmlsdGVyVGV4dCA9IChfcmVzcG9uc2VfZmlsdGVyVGV4dCA9IHJlc3BvbnNlLmZpbHRlclRleHQpICE9PSBudWxsICYmIF9yZXNwb25zZV9maWx0ZXJUZXh0ICE9PSB2b2lkIDAgPyBfcmVzcG9uc2VfZmlsdGVyVGV4dCA6IHByZXZpb3VzRmlsdGVyVGV4dDtcbiAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXI6IGFib3J0Q29udHJvbGxlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBGZXRjaCBhIG5ldyBmaWx0ZXJlZCBsaXN0IGlmIGZpbHRlclRleHQgaXMgdXBkYXRlZCB2aWEgYGxvYWRgIHJlc3BvbnNlIGZ1bmMgcmF0aGVyIHRoYW4gbGlzdC5zZXRGaWx0ZXJUZXh0XG4gICAgICAgICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgbm90IGFib3J0ZWQgKGUuZy4gdXNlciB0cmlnZ2VycyBhbm90aGVyIGZpbHRlciBhY3Rpb24gYmVmb3JlIGxvYWQgY29tcGxldGVzKVxuICAgICAgICAgICAgaWYgKGZpbHRlclRleHQgJiYgZmlsdGVyVGV4dCAhPT0gcHJldmlvdXNGaWx0ZXJUZXh0ICYmICFhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIGRpc3BhdGNoRmV0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsdGVyaW5nXCIsXG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogZmlsdGVyVGV4dFxuICAgICAgICAgICAgfSwgbG9hZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyOiBhYm9ydENvbnRyb2xsZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgZGlkRGlzcGF0Y2hJbml0aWFsRmV0Y2ggPSAoMCwgJGQ3MEFxJHVzZVJlZikoZmFsc2UpO1xuICAgICgwLCAkZDcwQXEkdXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoIWRpZERpc3BhdGNoSW5pdGlhbEZldGNoLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoRmV0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibG9hZGluZ1wiXG4gICAgICAgICAgICB9LCBsb2FkKTtcbiAgICAgICAgICAgIGRpZERpc3BhdGNoSW5pdGlhbEZldGNoLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpdGVtczogZGF0YS5pdGVtcyxcbiAgICAgICAgc2VsZWN0ZWRLZXlzOiBkYXRhLnNlbGVjdGVkS2V5cyxcbiAgICAgICAgc29ydERlc2NyaXB0b3I6IGRhdGEuc29ydERlc2NyaXB0b3IsXG4gICAgICAgIGlzTG9hZGluZzogZGF0YS5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgfHwgZGF0YS5zdGF0ZSA9PT0gXCJsb2FkaW5nTW9yZVwiIHx8IGRhdGEuc3RhdGUgPT09IFwic29ydGluZ1wiIHx8IGRhdGEuc3RhdGUgPT09IFwiZmlsdGVyaW5nXCIsXG4gICAgICAgIGxvYWRpbmdTdGF0ZTogZGF0YS5zdGF0ZSxcbiAgICAgICAgZXJyb3I6IGRhdGEuZXJyb3IsXG4gICAgICAgIGZpbHRlclRleHQ6IGRhdGEuZmlsdGVyVGV4dCxcbiAgICAgICAgZ2V0SXRlbSAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5pdGVtcy5maW5kKChpdGVtKT0+Z2V0S2V5KGl0ZW0pID09PSBrZXkpO1xuICAgICAgICB9LFxuICAgICAgICByZWxvYWQgKCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hGZXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJsb2FkaW5nXCJcbiAgICAgICAgICAgIH0sIGxvYWQpO1xuICAgICAgICB9LFxuICAgICAgICBsb2FkTW9yZSAoKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgaWYgYWxyZWFkeSBsb2FkaW5nIG1vcmUgb3IgaWYgcGVyZm9ybWluZyBzZXJ2ZXIgc2lkZSBmaWx0ZXJpbmcuXG4gICAgICAgICAgICBpZiAoZGF0YS5zdGF0ZSA9PT0gXCJsb2FkaW5nTW9yZVwiIHx8IGRhdGEuc3RhdGUgPT09IFwiZmlsdGVyaW5nXCIgfHwgZGF0YS5jdXJzb3IgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgICAgZGlzcGF0Y2hGZXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJsb2FkaW5nTW9yZVwiXG4gICAgICAgICAgICB9LCBsb2FkKTtcbiAgICAgICAgfSxcbiAgICAgICAgc29ydCAoc29ydERlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoRmV0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic29ydGluZ1wiLFxuICAgICAgICAgICAgICAgIHNvcnREZXNjcmlwdG9yOiBzb3J0RGVzY3JpcHRvclxuICAgICAgICAgICAgfSwgc29ydCB8fCBsb2FkKTtcbiAgICAgICAgfSxcbiAgICAgICAgLi4uKDAsICQwZDg2ZTljOGYwN2Y5YTdiJGV4cG9ydCQ3OWMwYzY4N2E1OTYzYjBhKSh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgZ2V0S2V5OiBnZXRLZXksXG4gICAgICAgICAgICBjdXJzb3I6IGRhdGEuY3Vyc29yXG4gICAgICAgIH0sIChmbik9PntcbiAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIHVwZGF0ZXI6IGZuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIHNldEZpbHRlclRleHQgKGZpbHRlclRleHQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoRmV0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsdGVyaW5nXCIsXG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogZmlsdGVyVGV4dFxuICAgICAgICAgICAgfSwgbG9hZCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICRiZTJlYTAzNDNhZjU0MjEyJGV4cG9ydCRkMTRlMTM1MmUyMWY0YTE2KG9wdGlvbnMpIHtcbiAgICBsZXQgeyBpbml0aWFsSXRlbXM6IGluaXRpYWxJdGVtcyA9IFtdLCBpbml0aWFsU2VsZWN0ZWRLZXlzOiBpbml0aWFsU2VsZWN0ZWRLZXlzLCBnZXRLZXk6IGdldEtleSA9IChpdGVtKT0+aXRlbS5pZCB8fCBpdGVtLmtleSwgZ2V0Q2hpbGRyZW46IGdldENoaWxkcmVuID0gKGl0ZW0pPT5pdGVtLmNoaWxkcmVuIH0gPSBvcHRpb25zO1xuICAgIGxldCBtYXAgPSAoMCwgJGQ3MEFxJHVzZU1lbW8pKCgpPT5uZXcgTWFwKCksIFtdKTtcbiAgICAvLyBXZSBvbmx5IHdhbnQgdG8gY29tcHV0ZSB0aGlzIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBsZXQgaW5pdGlhbE5vZGVzID0gKDAsICRkNzBBcSR1c2VNZW1vKSgoKT0+YnVpbGRUcmVlKGluaXRpYWxJdGVtcyksIFtdKTtcbiAgICBsZXQgW2l0ZW1zLCBzZXRJdGVtc10gPSAoMCwgJGQ3MEFxJHVzZVN0YXRlKShpbml0aWFsTm9kZXMpO1xuICAgIGxldCBbc2VsZWN0ZWRLZXlzLCBzZXRTZWxlY3RlZEtleXNdID0gKDAsICRkNzBBcSR1c2VTdGF0ZSkobmV3IFNldChpbml0aWFsU2VsZWN0ZWRLZXlzIHx8IFtdKSk7XG4gICAgZnVuY3Rpb24gYnVpbGRUcmVlKGluaXRpYWxJdGVtcyA9IFtdLCBwYXJlbnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIGluaXRpYWxJdGVtcy5tYXAoKGl0ZW0pPT57XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICBrZXk6IGdldEtleShpdGVtKSxcbiAgICAgICAgICAgICAgICBwYXJlbnRLZXk6IHBhcmVudEtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4gPSBidWlsZFRyZWUoZ2V0Q2hpbGRyZW4oaXRlbSksIG5vZGUua2V5KTtcbiAgICAgICAgICAgIG1hcC5zZXQobm9kZS5rZXksIG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVUcmVlKGl0ZW1zLCBrZXksIHVwZGF0ZSkge1xuICAgICAgICBsZXQgbm9kZSA9IG1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm4gaXRlbXM7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBub2RlLiBJZiBudWxsLCB0aGVuIGRlbGV0ZSB0aGUgbm9kZSwgb3RoZXJ3aXNlIHJlcGxhY2UuXG4gICAgICAgIGxldCBuZXdOb2RlID0gdXBkYXRlKG5vZGUpO1xuICAgICAgICBpZiAobmV3Tm9kZSA9PSBudWxsKSBkZWxldGVOb2RlKG5vZGUpO1xuICAgICAgICBlbHNlIGFkZE5vZGUobmV3Tm9kZSk7XG4gICAgICAgIC8vIFdhbGsgdXAgdGhlIHRyZWUgYW5kIHVwZGF0ZSBlYWNoIHBhcmVudCB0byByZWZlciB0byB0aGUgbmV3IGNoaWxyZW4uXG4gICAgICAgIHdoaWxlKG5vZGUucGFyZW50S2V5KXtcbiAgICAgICAgICAgIGxldCBuZXh0UGFyZW50ID0gbWFwLmdldChub2RlLnBhcmVudEtleSk7XG4gICAgICAgICAgICBsZXQgY29weSA9IHtcbiAgICAgICAgICAgICAgICBrZXk6IG5leHRQYXJlbnQua2V5LFxuICAgICAgICAgICAgICAgIHBhcmVudEtleTogbmV4dFBhcmVudC5wYXJlbnRLZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5leHRQYXJlbnQudmFsdWUsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBuZXh0UGFyZW50LmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKG5ld05vZGUgPT0gbnVsbCkgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoKGMpPT5jICE9PSBub2RlKTtcbiAgICAgICAgICAgIGNvcHkuY2hpbGRyZW4gPSBjaGlsZHJlbi5tYXAoKGNoaWxkKT0+e1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gbm9kZSkgcmV0dXJuIG5ld05vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtYXAuc2V0KGNvcHkua2V5LCBjb3B5KTtcbiAgICAgICAgICAgIG5ld05vZGUgPSBjb3B5O1xuICAgICAgICAgICAgbm9kZSA9IG5leHRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld05vZGUgPT0gbnVsbCkgaXRlbXMgPSBpdGVtcy5maWx0ZXIoKGMpPT5jICE9PSBub2RlKTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSk9PntcbiAgICAgICAgICAgIGlmIChpdGVtID09PSBub2RlKSByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkTm9kZShub2RlKSB7XG4gICAgICAgIG1hcC5zZXQobm9kZS5rZXksIG5vZGUpO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKWFkZE5vZGUoY2hpbGQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWxldGVOb2RlKG5vZGUpIHtcbiAgICAgICAgbWFwLmRlbGV0ZShub2RlLmtleSk7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pZGVsZXRlTm9kZShjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1zOiBpdGVtcyxcbiAgICAgICAgc2VsZWN0ZWRLZXlzOiBzZWxlY3RlZEtleXMsXG4gICAgICAgIHNldFNlbGVjdGVkS2V5czogc2V0U2VsZWN0ZWRLZXlzLFxuICAgICAgICBnZXRJdGVtIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXAuZ2V0KGtleSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydCAocGFyZW50S2V5LCBpbmRleCwgLi4udmFsdWVzKSB7XG4gICAgICAgICAgICBzZXRJdGVtcygoaXRlbXMpPT57XG4gICAgICAgICAgICAgICAgbGV0IG5vZGVzID0gYnVpbGRUcmVlKHZhbHVlcywgcGFyZW50S2V5KTtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXJlbnRLZXkgaXMgbnVsbCwgaW5zZXJ0IGludG8gdGhlIHJvb3QuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEtleSA9PSBudWxsKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAuLi5pdGVtcy5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgICAgICAgICAgIC4uLm5vZGVzLFxuICAgICAgICAgICAgICAgICAgICAuLi5pdGVtcy5zbGljZShpbmRleClcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdXBkYXRlIHRoZSBwYXJlbnQgbm9kZSBhbmQgaXRzIGFuY2VzdG9ycy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlVHJlZShpdGVtcywgcGFyZW50S2V5LCAocGFyZW50Tm9kZSk9Pih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHBhcmVudE5vZGUua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50S2V5OiBwYXJlbnROb2RlLnBhcmVudEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJlbnROb2RlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJlbnROb2RlLmNoaWxkcmVuLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5ub2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJlbnROb2RlLmNoaWxkcmVuLnNsaWNlKGluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0QmVmb3JlIChrZXksIC4uLnZhbHVlcykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBtYXAuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICAgICAgICAgIGxldCBwYXJlbnROb2RlID0gbWFwLmdldChub2RlLnBhcmVudEtleSk7XG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBwYXJlbnROb2RlID8gcGFyZW50Tm9kZS5jaGlsZHJlbiA6IGl0ZW1zO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gbm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KHBhcmVudE5vZGUgPT09IG51bGwgfHwgcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50Tm9kZS5rZXksIGluZGV4LCAuLi52YWx1ZXMpO1xuICAgICAgICB9LFxuICAgICAgICBpbnNlcnRBZnRlciAoa2V5LCAuLi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gbWFwLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XG4gICAgICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IG1hcC5nZXQobm9kZS5wYXJlbnRLZXkpO1xuICAgICAgICAgICAgbGV0IG5vZGVzID0gcGFyZW50Tm9kZSA/IHBhcmVudE5vZGUuY2hpbGRyZW4gOiBpdGVtcztcbiAgICAgICAgICAgIGxldCBpbmRleCA9IG5vZGVzLmluZGV4T2Yobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmluc2VydChwYXJlbnROb2RlID09PSBudWxsIHx8IHBhcmVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudE5vZGUua2V5LCBpbmRleCArIDEsIC4uLnZhbHVlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBlbmQgKHBhcmVudEtleSwgLi4udmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydChwYXJlbnRLZXksIDAsIC4uLnZhbHVlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZCAocGFyZW50S2V5LCAuLi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRLZXkgPT0gbnVsbCkgdGhpcy5pbnNlcnQobnVsbCwgaXRlbXMubGVuZ3RoLCAuLi52YWx1ZXMpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudE5vZGUgPSBtYXAuZ2V0KHBhcmVudEtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnROb2RlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQocGFyZW50S2V5LCBwYXJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aCwgLi4udmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlICguLi5rZXlzKSB7XG4gICAgICAgICAgICBsZXQgbmV3SXRlbXMgPSBpdGVtcztcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBrZXlzKW5ld0l0ZW1zID0gdXBkYXRlVHJlZShuZXdJdGVtcywga2V5LCAoKT0+bnVsbCk7XG4gICAgICAgICAgICBzZXRJdGVtcyhuZXdJdGVtcyk7XG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gbmV3IFNldChzZWxlY3RlZEtleXMpO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIHNlbGVjdGVkS2V5cylpZiAoIW1hcC5oYXMoa2V5KSkgc2VsZWN0aW9uLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRLZXlzKHNlbGVjdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVNlbGVjdGVkSXRlbXMgKCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoLi4uc2VsZWN0ZWRLZXlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW92ZSAoa2V5LCB0b1BhcmVudEtleSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHNldEl0ZW1zKChpdGVtcyk9PntcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG1hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHJldHVybiBpdGVtcztcbiAgICAgICAgICAgICAgICBpdGVtcyA9IHVwZGF0ZVRyZWUoaXRlbXMsIGtleSwgKCk9Pm51bGwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vdmVkTm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50S2V5OiB0b1BhcmVudEtleVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFyZW50S2V5IGlzIG51bGwsIGluc2VydCBpbnRvIHRoZSByb290LlxuICAgICAgICAgICAgICAgIGlmICh0b1BhcmVudEtleSA9PSBudWxsKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAuLi5pdGVtcy5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgICAgICAgICAgIG1vdmVkTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgLi4uaXRlbXMuc2xpY2UoaW5kZXgpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHVwZGF0ZSB0aGUgcGFyZW50IG5vZGUgYW5kIGl0cyBhbmNlc3RvcnMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVRyZWUoaXRlbXMsIHRvUGFyZW50S2V5LCAocGFyZW50Tm9kZSk9Pih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHBhcmVudE5vZGUua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50S2V5OiBwYXJlbnROb2RlLnBhcmVudEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJlbnROb2RlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJlbnROb2RlLmNoaWxkcmVuLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGFyZW50Tm9kZS5jaGlsZHJlbi5zbGljZShpbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZSAob2xkS2V5LCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgc2V0SXRlbXMoKGl0ZW1zKT0+dXBkYXRlVHJlZShpdGVtcywgb2xkS2V5LCAob2xkTm9kZSk9PntcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IG9sZE5vZGUua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50S2V5OiBvbGROb2RlLnBhcmVudEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4gPSBidWlsZFRyZWUoZ2V0Q2hpbGRyZW4obmV3VmFsdWUpLCBub2RlLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuXG5cblxuZXhwb3J0IHskZjg2ZTZjMWVjN2RhNmViYiRleHBvcnQkYmMzMzg0YTM1ZGU5M2Q2NiBhcyB1c2VBc3luY0xpc3QsICRiZTJlYTAzNDNhZjU0MjEyJGV4cG9ydCRkMTRlMTM1MmUyMWY0YTE2IGFzIHVzZVRyZWVEYXRhLCAkMGQ4NmU5YzhmMDdmOWE3YiRleHBvcnQkNzYyZjczZGNjY2NkMjU1ZCBhcyB1c2VMaXN0RGF0YX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlUmVkdWNlciIsIiRkNzBBcSR1c2VSZWR1Y2VyIiwidXNlUmVmIiwiJGQ3MEFxJHVzZVJlZiIsInVzZUVmZmVjdCIsIiRkNzBBcSR1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIiRkNzBBcSR1c2VTdGF0ZSIsInVzZU1lbW8iLCIkZDcwQXEkdXNlTWVtbyIsIiQwZDg2ZTljOGYwN2Y5YTdiJGV4cG9ydCQ3NjJmNzNkY2NjY2QyNTVkIiwib3B0aW9ucyIsImluaXRpYWxJdGVtcyIsImluaXRpYWxTZWxlY3RlZEtleXMiLCJnZXRLZXkiLCJpdGVtIiwiaWQiLCJrZXkiLCJmaWx0ZXIiLCJpbml0aWFsRmlsdGVyVGV4dCIsInN0YXRlIiwic2V0U3RhdGUiLCJpdGVtcyIsInNlbGVjdGVkS2V5cyIsIlNldCIsImZpbHRlclRleHQiLCJmaWx0ZXJlZEl0ZW1zIiwiJDBkODZlOWM4ZjA3ZjlhN2IkZXhwb3J0JDc5YzBjNjg3YTU5NjNiMGEiLCJnZXRJdGVtIiwiZmluZCIsIm9wdHMiLCJkaXNwYXRjaCIsImN1cnNvciIsInNldFNlbGVjdGVkS2V5cyIsInNldEZpbHRlclRleHQiLCJpbnNlcnQiLCJpbmRleCIsInZhbHVlcyIsIiQwZDg2ZTljOGYwN2Y5YTdiJHZhciRpbnNlcnQiLCJpbnNlcnRCZWZvcmUiLCJmaW5kSW5kZXgiLCJsZW5ndGgiLCJpbnNlcnRBZnRlciIsInByZXBlbmQiLCJhcHBlbmQiLCJyZW1vdmUiLCJrZXlzIiwia2V5U2V0IiwiaGFzIiwic2VsZWN0aW9uIiwiZGVsZXRlIiwicmVtb3ZlU2VsZWN0ZWRJdGVtcyIsIm1vdmUiLCJ0b0luZGV4IiwiY29weSIsInNsaWNlIiwic3BsaWNlIiwibW92ZUJlZm9yZSIsImtleUFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiaW5kaWNlcyIsIm1hcCIsInNvcnQiLCIkMGQ4NmU5YzhmMDdmOWE3YiR2YXIkbW92ZSIsIm1vdmVBZnRlciIsInVwZGF0ZSIsIm5ld1ZhbHVlIiwibW92ZXMiLCJmcm9tIiwidG8iLCJpIiwiYSIsImoiLCJiIiwiJGY4NmU2YzFlYzdkYTZlYmIkdmFyJHJlZHVjZXIiLCJkYXRhIiwiYWN0aW9uIiwidHlwZSIsIl9hY3Rpb25fZmlsdGVyVGV4dCIsIl9hY3Rpb25fc29ydERlc2NyaXB0b3IiLCJzb3J0RGVzY3JpcHRvciIsImFib3J0Q29udHJvbGxlciIsInVwZGF0ZXIiLCJFcnJvciIsIl9hY3Rpb25fc2VsZWN0ZWRLZXlzIiwiX2FjdGlvbl9maWx0ZXJUZXh0MSIsIl9hY3Rpb25fc29ydERlc2NyaXB0b3IxIiwiZXJyb3IiLCJhYm9ydCIsIl9hY3Rpb25fZmlsdGVyVGV4dDIiLCJfYWN0aW9uX3NlbGVjdGVkS2V5czEiLCJfYWN0aW9uX3NvcnREZXNjcmlwdG9yMiIsIl9hY3Rpb25fZmlsdGVyVGV4dDMiLCIkZjg2ZTZjMWVjN2RhNmViYiRleHBvcnQkYmMzMzg0YTM1ZGU5M2Q2NiIsImxvYWQiLCJpbml0aWFsU29ydERlc2NyaXB0b3IiLCJkaXNwYXRjaEZldGNoIiwiZm4iLCJBYm9ydENvbnRyb2xsZXIiLCJwcmV2aW91c0ZpbHRlclRleHQiLCJyZXNwb25zZSIsInNpZ25hbCIsIl9yZXNwb25zZV9maWx0ZXJUZXh0IiwiYWJvcnRlZCIsImUiLCJkaWREaXNwYXRjaEluaXRpYWxGZXRjaCIsImN1cnJlbnQiLCJpc0xvYWRpbmciLCJsb2FkaW5nU3RhdGUiLCJyZWxvYWQiLCJsb2FkTW9yZSIsIiRiZTJlYTAzNDNhZjU0MjEyJGV4cG9ydCRkMTRlMTM1MmUyMWY0YTE2IiwiZ2V0Q2hpbGRyZW4iLCJjaGlsZHJlbiIsIk1hcCIsImluaXRpYWxOb2RlcyIsImJ1aWxkVHJlZSIsInNldEl0ZW1zIiwicGFyZW50S2V5Iiwibm9kZSIsInZhbHVlIiwic2V0IiwidXBkYXRlVHJlZSIsImdldCIsIm5ld05vZGUiLCJkZWxldGVOb2RlIiwiYWRkTm9kZSIsIm5leHRQYXJlbnQiLCJjIiwiY2hpbGQiLCJub2RlcyIsInBhcmVudE5vZGUiLCJpbmRleE9mIiwibmV3SXRlbXMiLCJ0b1BhcmVudEtleSIsIm1vdmVkTm9kZSIsIm9sZEtleSIsIm9sZE5vZGUiLCJ1c2VBc3luY0xpc3QiLCJ1c2VUcmVlRGF0YSIsInVzZUxpc3REYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/data/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/flags/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/flags/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   enableTableNestedRows: () => (/* binding */ $f4e2df6bd15f8569$export$d9d8a0f82de49530),\n/* harmony export */   tableNestedRows: () => (/* binding */ $f4e2df6bd15f8569$export$1b00cb14a96194e6)\n/* harmony export */ });\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $f4e2df6bd15f8569$var$_tableNestedRows = false;\nfunction $f4e2df6bd15f8569$export$d9d8a0f82de49530() {\n    $f4e2df6bd15f8569$var$_tableNestedRows = true;\n}\nfunction $f4e2df6bd15f8569$export$1b00cb14a96194e6() {\n    return $f4e2df6bd15f8569$var$_tableNestedRows;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZmxhZ3MvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUFHLElBQUlBLHlDQUF5QztBQUNqRCxTQUFTQztJQUNMRCx5Q0FBeUM7QUFDN0M7QUFDQSxTQUFTRTtJQUNMLE9BQU9GO0FBQ1g7QUFHMEksQ0FDMUksa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemV1cy1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9mbGFncy9kaXN0L2ltcG9ydC5tanM/YTgwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gbGV0ICRmNGUyZGY2YmQxNWY4NTY5JHZhciRfdGFibGVOZXN0ZWRSb3dzID0gZmFsc2U7XG5mdW5jdGlvbiAkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkZDlkOGEwZjgyZGU0OTUzMCgpIHtcbiAgICAkZjRlMmRmNmJkMTVmODU2OSR2YXIkX3RhYmxlTmVzdGVkUm93cyA9IHRydWU7XG59XG5mdW5jdGlvbiAkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkMWIwMGNiMTRhOTYxOTRlNigpIHtcbiAgICByZXR1cm4gJGY0ZTJkZjZiZDE1Zjg1NjkkdmFyJF90YWJsZU5lc3RlZFJvd3M7XG59XG5cblxuZXhwb3J0IHskZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkZDlkOGEwZjgyZGU0OTUzMCBhcyBlbmFibGVUYWJsZU5lc3RlZFJvd3MsICRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCQxYjAwY2IxNGE5NjE5NGU2IGFzIHRhYmxlTmVzdGVkUm93c307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiJGY0ZTJkZjZiZDE1Zjg1NjkkdmFyJF90YWJsZU5lc3RlZFJvd3MiLCIkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkZDlkOGEwZjgyZGU0OTUzMCIsIiRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCQxYjAwY2IxNGE5NjE5NGU2IiwiZW5hYmxlVGFibGVOZXN0ZWRSb3dzIiwidGFibGVOZXN0ZWRSb3dzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/flags/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/form/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/form/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_VALIDATION_RESULT: () => (/* binding */ $e5be200c675c3b3a$export$dad6ae84456c676a),\n/* harmony export */   FormValidationContext: () => (/* binding */ $e5be200c675c3b3a$export$571b5131b7e65c11),\n/* harmony export */   VALID_VALIDITY_STATE: () => (/* binding */ $e5be200c675c3b3a$export$aca958c65c314e6c),\n/* harmony export */   mergeValidation: () => (/* binding */ $e5be200c675c3b3a$export$75ee7c75d68f5b0e),\n/* harmony export */   privateValidationStateProp: () => (/* binding */ $e5be200c675c3b3a$export$a763b9476acd3eb),\n/* harmony export */   useFormValidationState: () => (/* binding */ $e5be200c675c3b3a$export$fc1a364ae1f3ff10)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $e5be200c675c3b3a$export$aca958c65c314e6c = {\n    badInput: false,\n    customError: false,\n    patternMismatch: false,\n    rangeOverflow: false,\n    rangeUnderflow: false,\n    stepMismatch: false,\n    tooLong: false,\n    tooShort: false,\n    typeMismatch: false,\n    valueMissing: false,\n    valid: true\n};\nconst $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE = {\n    ...$e5be200c675c3b3a$export$aca958c65c314e6c,\n    customError: true,\n    valid: false\n};\nconst $e5be200c675c3b3a$export$dad6ae84456c676a = {\n    isInvalid: false,\n    validationDetails: $e5be200c675c3b3a$export$aca958c65c314e6c,\n    validationErrors: []\n};\nconst $e5be200c675c3b3a$export$571b5131b7e65c11 = (0, react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nconst $e5be200c675c3b3a$export$a763b9476acd3eb = \"__formValidationState\" + Date.now();\nfunction $e5be200c675c3b3a$export$fc1a364ae1f3ff10(props) {\n    // Private prop for parent components to pass state to children.\n    if (props[$e5be200c675c3b3a$export$a763b9476acd3eb]) {\n        let { realtimeValidation: realtimeValidation, displayValidation: displayValidation, updateValidation: updateValidation, resetValidation: resetValidation, commitValidation: commitValidation } = props[$e5be200c675c3b3a$export$a763b9476acd3eb];\n        return {\n            realtimeValidation: realtimeValidation,\n            displayValidation: displayValidation,\n            updateValidation: updateValidation,\n            resetValidation: resetValidation,\n            commitValidation: commitValidation\n        };\n    }\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return $e5be200c675c3b3a$var$useFormValidationStateImpl(props);\n}\nfunction $e5be200c675c3b3a$var$useFormValidationStateImpl(props) {\n    let { isInvalid: isInvalid, validationState: validationState, name: name, value: value, builtinValidation: builtinValidation, validate: validate, validationBehavior: validationBehavior = \"aria\" } = props;\n    // backward compatibility.\n    if (validationState) isInvalid || (isInvalid = validationState === \"invalid\");\n    // If the isInvalid prop is true, update validation result in realtime (controlled).\n    let controlledError = isInvalid ? {\n        isInvalid: true,\n        validationErrors: [],\n        validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE\n    } : null;\n    // Perform custom client side validation.\n    let clientError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$e5be200c675c3b3a$var$getValidationResult($e5be200c675c3b3a$var$runValidate(validate, value)), [\n        validate,\n        value\n    ]);\n    if (builtinValidation === null || builtinValidation === void 0 ? void 0 : builtinValidation.validationDetails.valid) builtinValidation = null;\n    // Get relevant server errors from the form.\n    let serverErrors = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($e5be200c675c3b3a$export$571b5131b7e65c11);\n    let serverErrorMessages = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (name) return Array.isArray(name) ? name.flatMap((name)=>$e5be200c675c3b3a$var$asArray(serverErrors[name])) : $e5be200c675c3b3a$var$asArray(serverErrors[name]);\n        return [];\n    }, [\n        serverErrors,\n        name\n    ]);\n    // Show server errors when the form gets a new value, and clear when the user changes the value.\n    let [lastServerErrors, setLastServerErrors] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(serverErrors);\n    let [isServerErrorCleared, setServerErrorCleared] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    if (serverErrors !== lastServerErrors) {\n        setLastServerErrors(serverErrors);\n        setServerErrorCleared(false);\n    }\n    let serverError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$e5be200c675c3b3a$var$getValidationResult(isServerErrorCleared ? [] : serverErrorMessages), [\n        isServerErrorCleared,\n        serverErrorMessages\n    ]);\n    // Track the next validation state in a ref until commitValidation is called.\n    let nextValidation = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let [currentValidity, setCurrentValidity] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let lastError = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);\n    let commitValidation = ()=>{\n        if (!commitQueued) return;\n        setCommitQueued(false);\n        let error = clientError || builtinValidation || nextValidation.current;\n        if (!$e5be200c675c3b3a$var$isEqualValidation(error, lastError.current)) {\n            lastError.current = error;\n            setCurrentValidity(error);\n        }\n    };\n    let [commitQueued, setCommitQueued] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(commitValidation);\n    // realtimeValidation is used to update the native input element's state based on custom validation logic.\n    // displayValidation is the currently displayed validation state that the user sees (e.g. on input change/form submit).\n    // With validationBehavior=\"aria\", all errors are displayed in realtime rather than on submit.\n    let realtimeValidation = controlledError || serverError || clientError || builtinValidation || $e5be200c675c3b3a$export$dad6ae84456c676a;\n    let displayValidation = validationBehavior === \"native\" ? controlledError || serverError || currentValidity : controlledError || serverError || clientError || builtinValidation || currentValidity;\n    return {\n        realtimeValidation: realtimeValidation,\n        displayValidation: displayValidation,\n        updateValidation (value) {\n            // If validationBehavior is 'aria', update in realtime. Otherwise, store in a ref until commit.\n            if (validationBehavior === \"aria\" && !$e5be200c675c3b3a$var$isEqualValidation(currentValidity, value)) setCurrentValidity(value);\n            else nextValidation.current = value;\n        },\n        resetValidation () {\n            // Update the currently displayed validation state to valid on form reset,\n            // even if the native validity says it isn't. It'll show again on the next form submit.\n            let error = $e5be200c675c3b3a$export$dad6ae84456c676a;\n            if (!$e5be200c675c3b3a$var$isEqualValidation(error, lastError.current)) {\n                lastError.current = error;\n                setCurrentValidity(error);\n            }\n            // Do not commit validation after the next render. This avoids a condition where\n            // useSelect calls commitValidation inside an onReset handler.\n            if (validationBehavior === \"native\") setCommitQueued(false);\n            setServerErrorCleared(true);\n        },\n        commitValidation () {\n            // Commit validation state so the user sees it on blur/change/submit. Also clear any server errors.\n            // Wait until after the next render to commit so that the latest value has been validated.\n            if (validationBehavior === \"native\") setCommitQueued(true);\n            setServerErrorCleared(true);\n        }\n    };\n}\nfunction $e5be200c675c3b3a$var$asArray(v) {\n    if (!v) return [];\n    return Array.isArray(v) ? v : [\n        v\n    ];\n}\nfunction $e5be200c675c3b3a$var$runValidate(validate, value) {\n    if (typeof validate === \"function\") {\n        let e = validate(value);\n        if (e && typeof e !== \"boolean\") return $e5be200c675c3b3a$var$asArray(e);\n    }\n    return [];\n}\nfunction $e5be200c675c3b3a$var$getValidationResult(errors) {\n    return errors.length ? {\n        isInvalid: true,\n        validationErrors: errors,\n        validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE\n    } : null;\n}\nfunction $e5be200c675c3b3a$var$isEqualValidation(a, b) {\n    if (a === b) return true;\n    return a && b && a.isInvalid === b.isInvalid && a.validationErrors.length === b.validationErrors.length && a.validationErrors.every((a, i)=>a === b.validationErrors[i]) && Object.entries(a.validationDetails).every(([k, v])=>b.validationDetails[k] === v);\n}\nfunction $e5be200c675c3b3a$export$75ee7c75d68f5b0e(...results) {\n    let errors = new Set();\n    let isInvalid = false;\n    let validationDetails = {\n        ...$e5be200c675c3b3a$export$aca958c65c314e6c\n    };\n    for (let v of results){\n        var _validationDetails, _key;\n        for (let e of v.validationErrors)errors.add(e);\n        // Only these properties apply for checkboxes.\n        isInvalid || (isInvalid = v.isInvalid);\n        for(let key in validationDetails)(_validationDetails = validationDetails)[_key = key] || (_validationDetails[_key] = v.validationDetails[key]);\n    }\n    validationDetails.valid = !isInvalid;\n    return {\n        isInvalid: isInvalid,\n        validationErrors: [\n            ...errors\n        ],\n        validationDetails: validationDetails\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZm9ybS9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2TTtBQUU3TTs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUNELE1BQU1ZLDRDQUE0QztJQUM5Q0MsVUFBVTtJQUNWQyxhQUFhO0lBQ2JDLGlCQUFpQjtJQUNqQkMsZUFBZTtJQUNmQyxnQkFBZ0I7SUFDaEJDLGNBQWM7SUFDZEMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZDLGNBQWM7SUFDZEMsY0FBYztJQUNkQyxPQUFPO0FBQ1g7QUFDQSxNQUFNQyw4Q0FBOEM7SUFDaEQsR0FBR1oseUNBQXlDO0lBQzVDRSxhQUFhO0lBQ2JTLE9BQU87QUFDWDtBQUNBLE1BQU1FLDRDQUE0QztJQUM5Q0MsV0FBVztJQUNYQyxtQkFBbUJmO0lBQ25CZ0Isa0JBQWtCLEVBQUU7QUFDeEI7QUFDQSxNQUFNQyw0Q0FBNEMsQ0FBQyxHQUFHNUIsZ0RBQW1CLEVBQUcsQ0FBQztBQUM3RSxNQUFNNkIsMkNBQTJDLDBCQUEwQkMsS0FBS0MsR0FBRztBQUNuRixTQUFTQywwQ0FBMENDLEtBQUs7SUFDcEQsZ0VBQWdFO0lBQ2hFLElBQUlBLEtBQUssQ0FBQ0oseUNBQXlDLEVBQUU7UUFDakQsSUFBSSxFQUFFSyxvQkFBb0JBLGtCQUFrQixFQUFFQyxtQkFBbUJBLGlCQUFpQixFQUFFQyxrQkFBa0JBLGdCQUFnQixFQUFFQyxpQkFBaUJBLGVBQWUsRUFBRUMsa0JBQWtCQSxnQkFBZ0IsRUFBRSxHQUFHTCxLQUFLLENBQUNKLHlDQUF5QztRQUNoUCxPQUFPO1lBQ0hLLG9CQUFvQkE7WUFDcEJDLG1CQUFtQkE7WUFDbkJDLGtCQUFrQkE7WUFDbEJDLGlCQUFpQkE7WUFDakJDLGtCQUFrQkE7UUFDdEI7SUFDSjtJQUNBLHNEQUFzRDtJQUN0RCxPQUFPQyxpREFBaUROO0FBQzVEO0FBQ0EsU0FBU00saURBQWlETixLQUFLO0lBQzNELElB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LGdCQUFnQixDQUFDOEMsTUFBTSxLQUFLRSxFQUFFaEQsZ0JBQWdCLENBQUM4QyxNQUFNLElBQUlDLEVBQUUvQyxnQkFBZ0IsQ0FBQ2lELEtBQUssQ0FBQyxDQUFDRixHQUFHRyxJQUFJSCxNQUFNQyxFQUFFaEQsZ0JBQWdCLENBQUNrRCxFQUFFLEtBQUtDLE9BQU9DLE9BQU8sQ0FBQ0wsRUFBRWhELGlCQUFpQixFQUFFa0QsS0FBSyxDQUFDLENBQUMsQ0FBQ0ksR0FBR1YsRUFBRSxHQUFHSyxFQUFFakQsaUJBQWlCLENBQUNzRCxFQUFFLEtBQUtWO0FBQy9QO0FBQ0EsU0FBU1csMENBQTBDLEdBQUdDLE9BQU87SUFDekQsSUFBSVYsU0FBUyxJQUFJVztJQUNqQixJQUFJMUQsWUFBWTtJQUNoQixJQUFJQyxvQkFBb0I7UUFDcEIsR0FBR2YseUNBQXlDO0lBQ2hEO0lBQ0EsS0FBSyxJQUFJMkQsS0FBS1ksUUFBUTtRQUNsQixJQUFJRSxvQkFBb0JDO1FBQ3hCLEtBQUssSUFBSWQsS0FBS0QsRUFBRTNDLGdCQUFnQixDQUFDNkMsT0FBT2MsR0FBRyxDQUFDZjtRQUM1Qyw4Q0FBOEM7UUFDOUM5QyxhQUFjQSxDQUFBQSxZQUFZNkMsRUFBRTdDLFNBQVM7UUFDckMsSUFBSSxJQUFJOEQsT0FBTzdELGtCQUFrQixDQUFDMEQscUJBQXFCMUQsaUJBQWdCLENBQUUsQ0FBQzJELE9BQU9FLElBQUksSUFBS0gsQ0FBQUEsa0JBQWtCLENBQUNDLEtBQUssR0FBR2YsRUFBRTVDLGlCQUFpQixDQUFDNkQsSUFBSTtJQUNqSjtJQUNBN0Qsa0JBQWtCSixLQUFLLEdBQUcsQ0FBQ0c7SUFDM0IsT0FBTztRQUNIQSxXQUFXQTtRQUNYRSxrQkFBa0I7ZUFDWDZDO1NBQ047UUFDRDlDLG1CQUFtQkE7SUFDdkI7QUFDSjtBQUtrYSxDQUNsYSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZXVzLW5leHQtYXBwLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L2Zvcm0vZGlzdC9pbXBvcnQubWpzP2Y1MDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjcmVhdGVDb250ZXh0IGFzICRqY0lPdyRjcmVhdGVDb250ZXh0LCB1c2VNZW1vIGFzICRqY0lPdyR1c2VNZW1vLCB1c2VDb250ZXh0IGFzICRqY0lPdyR1c2VDb250ZXh0LCB1c2VTdGF0ZSBhcyAkamNJT3ckdXNlU3RhdGUsIHVzZVJlZiBhcyAkamNJT3ckdXNlUmVmLCB1c2VFZmZlY3QgYXMgJGpjSU93JHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5jb25zdCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYWNhOTU4YzY1YzMxNGU2YyA9IHtcbiAgICBiYWRJbnB1dDogZmFsc2UsXG4gICAgY3VzdG9tRXJyb3I6IGZhbHNlLFxuICAgIHBhdHRlcm5NaXNtYXRjaDogZmFsc2UsXG4gICAgcmFuZ2VPdmVyZmxvdzogZmFsc2UsXG4gICAgcmFuZ2VVbmRlcmZsb3c6IGZhbHNlLFxuICAgIHN0ZXBNaXNtYXRjaDogZmFsc2UsXG4gICAgdG9vTG9uZzogZmFsc2UsXG4gICAgdG9vU2hvcnQ6IGZhbHNlLFxuICAgIHR5cGVNaXNtYXRjaDogZmFsc2UsXG4gICAgdmFsdWVNaXNzaW5nOiBmYWxzZSxcbiAgICB2YWxpZDogdHJ1ZVxufTtcbmNvbnN0ICRlNWJlMjAwYzY3NWMzYjNhJHZhciRDVVNUT01fVkFMSURJVFlfU1RBVEUgPSB7XG4gICAgLi4uJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGFjYTk1OGM2NWMzMTRlNmMsXG4gICAgY3VzdG9tRXJyb3I6IHRydWUsXG4gICAgdmFsaWQ6IGZhbHNlXG59O1xuY29uc3QgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGRhZDZhZTg0NDU2YzY3NmEgPSB7XG4gICAgaXNJbnZhbGlkOiBmYWxzZSxcbiAgICB2YWxpZGF0aW9uRGV0YWlsczogJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGFjYTk1OGM2NWMzMTRlNmMsXG4gICAgdmFsaWRhdGlvbkVycm9yczogW11cbn07XG5jb25zdCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNTcxYjUxMzFiN2U2NWMxMSA9ICgwLCAkamNJT3ckY3JlYXRlQ29udGV4dCkoe30pO1xuY29uc3QgJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGE3NjNiOTQ3NmFjZDNlYiA9IFwiX19mb3JtVmFsaWRhdGlvblN0YXRlXCIgKyBEYXRlLm5vdygpO1xuZnVuY3Rpb24gJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGZjMWEzNjRhZTFmM2ZmMTAocHJvcHMpIHtcbiAgICAvLyBQcml2YXRlIHByb3AgZm9yIHBhcmVudCBjb21wb25lbnRzIHRvIHBhc3Mgc3RhdGUgdG8gY2hpbGRyZW4uXG4gICAgaWYgKHByb3BzWyRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhNzYzYjk0NzZhY2QzZWJdKSB7XG4gICAgICAgIGxldCB7IHJlYWx0aW1lVmFsaWRhdGlvbjogcmVhbHRpbWVWYWxpZGF0aW9uLCBkaXNwbGF5VmFsaWRhdGlvbjogZGlzcGxheVZhbGlkYXRpb24sIHVwZGF0ZVZhbGlkYXRpb246IHVwZGF0ZVZhbGlkYXRpb24sIHJlc2V0VmFsaWRhdGlvbjogcmVzZXRWYWxpZGF0aW9uLCBjb21taXRWYWxpZGF0aW9uOiBjb21taXRWYWxpZGF0aW9uIH0gPSBwcm9wc1skZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYTc2M2I5NDc2YWNkM2ViXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWx0aW1lVmFsaWRhdGlvbjogcmVhbHRpbWVWYWxpZGF0aW9uLFxuICAgICAgICAgICAgZGlzcGxheVZhbGlkYXRpb246IGRpc3BsYXlWYWxpZGF0aW9uLFxuICAgICAgICAgICAgdXBkYXRlVmFsaWRhdGlvbjogdXBkYXRlVmFsaWRhdGlvbixcbiAgICAgICAgICAgIHJlc2V0VmFsaWRhdGlvbjogcmVzZXRWYWxpZGF0aW9uLFxuICAgICAgICAgICAgY29tbWl0VmFsaWRhdGlvbjogY29tbWl0VmFsaWRhdGlvblxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICByZXR1cm4gJGU1YmUyMDBjNjc1YzNiM2EkdmFyJHVzZUZvcm1WYWxpZGF0aW9uU3RhdGVJbXBsKHByb3BzKTtcbn1cbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJHZhciR1c2VGb3JtVmFsaWRhdGlvblN0YXRlSW1wbChwcm9wcykge1xuICAgIGxldCB7IGlzSW52YWxpZDogaXNJbnZhbGlkLCB2YWxpZGF0aW9uU3RhdGU6IHZhbGlkYXRpb25TdGF0ZSwgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBidWlsdGluVmFsaWRhdGlvbjogYnVpbHRpblZhbGlkYXRpb24sIHZhbGlkYXRlOiB2YWxpZGF0ZSwgdmFsaWRhdGlvbkJlaGF2aW9yOiB2YWxpZGF0aW9uQmVoYXZpb3IgPSBcImFyaWFcIiB9ID0gcHJvcHM7XG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICBpZiAodmFsaWRhdGlvblN0YXRlKSBpc0ludmFsaWQgfHwgKGlzSW52YWxpZCA9IHZhbGlkYXRpb25TdGF0ZSA9PT0gXCJpbnZhbGlkXCIpO1xuICAgIC8vIElmIHRoZSBpc0ludmFsaWQgcHJvcCBpcyB0cnVlLCB1cGRhdGUgdmFsaWRhdGlvbiByZXN1bHQgaW4gcmVhbHRpbWUgKGNvbnRyb2xsZWQpLlxuICAgIGxldCBjb250cm9sbGVkRXJyb3IgPSBpc0ludmFsaWQgPyB7XG4gICAgICAgIGlzSW52YWxpZDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGlvbkVycm9yczogW10sXG4gICAgICAgIHZhbGlkYXRpb25EZXRhaWxzOiAkZTViZTIwMGM2NzVjM2IzYSR2YXIkQ1VTVE9NX1ZBTElESVRZX1NUQVRFXG4gICAgfSA6IG51bGw7XG4gICAgLy8gUGVyZm9ybSBjdXN0b20gY2xpZW50IHNpZGUgdmFsaWRhdGlvbi5cbiAgICBsZXQgY2xpZW50RXJyb3IgPSAoMCwgJGpjSU93JHVzZU1lbW8pKCgpPT4kZTViZTIwMGM2NzVjM2IzYSR2YXIkZ2V0VmFsaWRhdGlvblJlc3VsdCgkZTViZTIwMGM2NzVjM2IzYSR2YXIkcnVuVmFsaWRhdGUodmFsaWRhdGUsIHZhbHVlKSksIFtcbiAgICAgICAgdmFsaWRhdGUsXG4gICAgICAgIHZhbHVlXG4gICAgXSk7XG4gICAgaWYgKGJ1aWx0aW5WYWxpZGF0aW9uID09PSBudWxsIHx8IGJ1aWx0aW5WYWxpZGF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBidWlsdGluVmFsaWRhdGlvbi52YWxpZGF0aW9uRGV0YWlscy52YWxpZCkgYnVpbHRpblZhbGlkYXRpb24gPSBudWxsO1xuICAgIC8vIEdldCByZWxldmFudCBzZXJ2ZXIgZXJyb3JzIGZyb20gdGhlIGZvcm0uXG4gICAgbGV0IHNlcnZlckVycm9ycyA9ICgwLCAkamNJT3ckdXNlQ29udGV4dCkoJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDU3MWI1MTMxYjdlNjVjMTEpO1xuICAgIGxldCBzZXJ2ZXJFcnJvck1lc3NhZ2VzID0gKDAsICRqY0lPdyR1c2VNZW1vKSgoKT0+e1xuICAgICAgICBpZiAobmFtZSkgcmV0dXJuIEFycmF5LmlzQXJyYXkobmFtZSkgPyBuYW1lLmZsYXRNYXAoKG5hbWUpPT4kZTViZTIwMGM2NzVjM2IzYSR2YXIkYXNBcnJheShzZXJ2ZXJFcnJvcnNbbmFtZV0pKSA6ICRlNWJlMjAwYzY3NWMzYjNhJHZhciRhc0FycmF5KHNlcnZlckVycm9yc1tuYW1lXSk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LCBbXG4gICAgICAgIHNlcnZlckVycm9ycyxcbiAgICAgICAgbmFtZVxuICAgIF0pO1xuICAgIC8vIFNob3cgc2VydmVyIGVycm9ycyB3aGVuIHRoZSBmb3JtIGdldHMgYSBuZXcgdmFsdWUsIGFuZCBjbGVhciB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIHZhbHVlLlxuICAgIGxldCBbbGFzdFNlcnZlckVycm9ycywgc2V0TGFzdFNlcnZlckVycm9yc10gPSAoMCwgJGpjSU93JHVzZVN0YXRlKShzZXJ2ZXJFcnJvcnMpO1xuICAgIGxldCBbaXNTZXJ2ZXJFcnJvckNsZWFyZWQsIHNldFNlcnZlckVycm9yQ2xlYXJlZF0gPSAoMCwgJGpjSU93JHVzZVN0YXRlKShmYWxzZSk7XG4gICAgaWYgKHNlcnZlckVycm9ycyAhPT0gbGFzdFNlcnZlckVycm9ycykge1xuICAgICAgICBzZXRMYXN0U2VydmVyRXJyb3JzKHNlcnZlckVycm9ycyk7XG4gICAgICAgIHNldFNlcnZlckVycm9yQ2xlYXJlZChmYWxzZSk7XG4gICAgfVxuICAgIGxldCBzZXJ2ZXJFcnJvciA9ICgwLCAkamNJT3ckdXNlTWVtbykoKCk9PiRlNWJlMjAwYzY3NWMzYjNhJHZhciRnZXRWYWxpZGF0aW9uUmVzdWx0KGlzU2VydmVyRXJyb3JDbGVhcmVkID8gW10gOiBzZXJ2ZXJFcnJvck1lc3NhZ2VzKSwgW1xuICAgICAgICBpc1NlcnZlckVycm9yQ2xlYXJlZCxcbiAgICAgICAgc2VydmVyRXJyb3JNZXNzYWdlc1xuICAgIF0pO1xuICAgIC8vIFRyYWNrIHRoZSBuZXh0IHZhbGlkYXRpb24gc3RhdGUgaW4gYSByZWYgdW50aWwgY29tbWl0VmFsaWRhdGlvbiBpcyBjYWxsZWQuXG4gICAgbGV0IG5leHRWYWxpZGF0aW9uID0gKDAsICRqY0lPdyR1c2VSZWYpKCRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhKTtcbiAgICBsZXQgW2N1cnJlbnRWYWxpZGl0eSwgc2V0Q3VycmVudFZhbGlkaXR5XSA9ICgwLCAkamNJT3ckdXNlU3RhdGUpKCRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhKTtcbiAgICBsZXQgbGFzdEVycm9yID0gKDAsICRqY0lPdyR1c2VSZWYpKCRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhKTtcbiAgICBsZXQgY29tbWl0VmFsaWRhdGlvbiA9ICgpPT57XG4gICAgICAgIGlmICghY29tbWl0UXVldWVkKSByZXR1cm47XG4gICAgICAgIHNldENvbW1pdFF1ZXVlZChmYWxzZSk7XG4gICAgICAgIGxldCBlcnJvciA9IGNsaWVudEVycm9yIHx8IGJ1aWx0aW5WYWxpZGF0aW9uIHx8IG5leHRWYWxpZGF0aW9uLmN1cnJlbnQ7XG4gICAgICAgIGlmICghJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGlzRXF1YWxWYWxpZGF0aW9uKGVycm9yLCBsYXN0RXJyb3IuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGxhc3RFcnJvci5jdXJyZW50ID0gZXJyb3I7XG4gICAgICAgICAgICBzZXRDdXJyZW50VmFsaWRpdHkoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgW2NvbW1pdFF1ZXVlZCwgc2V0Q29tbWl0UXVldWVkXSA9ICgwLCAkamNJT3ckdXNlU3RhdGUpKGZhbHNlKTtcbiAgICAoMCwgJGpjSU93JHVzZUVmZmVjdCkoY29tbWl0VmFsaWRhdGlvbik7XG4gICAgLy8gcmVhbHRpbWVWYWxpZGF0aW9uIGlzIHVzZWQgdG8gdXBkYXRlIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudCdzIHN0YXRlIGJhc2VkIG9uIGN1c3RvbSB2YWxpZGF0aW9uIGxvZ2ljLlxuICAgIC8vIGRpc3BsYXlWYWxpZGF0aW9uIGlzIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHZhbGlkYXRpb24gc3RhdGUgdGhhdCB0aGUgdXNlciBzZWVzIChlLmcuIG9uIGlucHV0IGNoYW5nZS9mb3JtIHN1Ym1pdCkuXG4gICAgLy8gV2l0aCB2YWxpZGF0aW9uQmVoYXZpb3I9XCJhcmlhXCIsIGFsbCBlcnJvcnMgYXJlIGRpc3BsYXllZCBpbiByZWFsdGltZSByYXRoZXIgdGhhbiBvbiBzdWJtaXQuXG4gICAgbGV0IHJlYWx0aW1lVmFsaWRhdGlvbiA9IGNvbnRyb2xsZWRFcnJvciB8fCBzZXJ2ZXJFcnJvciB8fCBjbGllbnRFcnJvciB8fCBidWlsdGluVmFsaWRhdGlvbiB8fCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YTtcbiAgICBsZXQgZGlzcGxheVZhbGlkYXRpb24gPSB2YWxpZGF0aW9uQmVoYXZpb3IgPT09IFwibmF0aXZlXCIgPyBjb250cm9sbGVkRXJyb3IgfHwgc2VydmVyRXJyb3IgfHwgY3VycmVudFZhbGlkaXR5IDogY29udHJvbGxlZEVycm9yIHx8IHNlcnZlckVycm9yIHx8IGNsaWVudEVycm9yIHx8IGJ1aWx0aW5WYWxpZGF0aW9uIHx8IGN1cnJlbnRWYWxpZGl0eTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWFsdGltZVZhbGlkYXRpb246IHJlYWx0aW1lVmFsaWRhdGlvbixcbiAgICAgICAgZGlzcGxheVZhbGlkYXRpb246IGRpc3BsYXlWYWxpZGF0aW9uLFxuICAgICAgICB1cGRhdGVWYWxpZGF0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gSWYgdmFsaWRhdGlvbkJlaGF2aW9yIGlzICdhcmlhJywgdXBkYXRlIGluIHJlYWx0aW1lLiBPdGhlcndpc2UsIHN0b3JlIGluIGEgcmVmIHVudGlsIGNvbW1pdC5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uQmVoYXZpb3IgPT09IFwiYXJpYVwiICYmICEkZTViZTIwMGM2NzVjM2IzYSR2YXIkaXNFcXVhbFZhbGlkYXRpb24oY3VycmVudFZhbGlkaXR5LCB2YWx1ZSkpIHNldEN1cnJlbnRWYWxpZGl0eSh2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIG5leHRWYWxpZGF0aW9uLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXRWYWxpZGF0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudGx5IGRpc3BsYXllZCB2YWxpZGF0aW9uIHN0YXRlIHRvIHZhbGlkIG9uIGZvcm0gcmVzZXQsXG4gICAgICAgICAgICAvLyBldmVuIGlmIHRoZSBuYXRpdmUgdmFsaWRpdHkgc2F5cyBpdCBpc24ndC4gSXQnbGwgc2hvdyBhZ2FpbiBvbiB0aGUgbmV4dCBmb3JtIHN1Ym1pdC5cbiAgICAgICAgICAgIGxldCBlcnJvciA9ICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhO1xuICAgICAgICAgICAgaWYgKCEkZTViZTIwMGM2NzVjM2IzYSR2YXIkaXNFcXVhbFZhbGlkYXRpb24oZXJyb3IsIGxhc3RFcnJvci5jdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIGxhc3RFcnJvci5jdXJyZW50ID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFZhbGlkaXR5KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvIG5vdCBjb21taXQgdmFsaWRhdGlvbiBhZnRlciB0aGUgbmV4dCByZW5kZXIuIFRoaXMgYXZvaWRzIGEgY29uZGl0aW9uIHdoZXJlXG4gICAgICAgICAgICAvLyB1c2VTZWxlY3QgY2FsbHMgY29tbWl0VmFsaWRhdGlvbiBpbnNpZGUgYW4gb25SZXNldCBoYW5kbGVyLlxuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25CZWhhdmlvciA9PT0gXCJuYXRpdmVcIikgc2V0Q29tbWl0UXVldWVkKGZhbHNlKTtcbiAgICAgICAgICAgIHNldFNlcnZlckVycm9yQ2xlYXJlZCh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tbWl0VmFsaWRhdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDb21taXQgdmFsaWRhdGlvbiBzdGF0ZSBzbyB0aGUgdXNlciBzZWVzIGl0IG9uIGJsdXIvY2hhbmdlL3N1Ym1pdC4gQWxzbyBjbGVhciBhbnkgc2VydmVyIGVycm9ycy5cbiAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgYWZ0ZXIgdGhlIG5leHQgcmVuZGVyIHRvIGNvbW1pdCBzbyB0aGF0IHRoZSBsYXRlc3QgdmFsdWUgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25CZWhhdmlvciA9PT0gXCJuYXRpdmVcIikgc2V0Q29tbWl0UXVldWVkKHRydWUpO1xuICAgICAgICAgICAgc2V0U2VydmVyRXJyb3JDbGVhcmVkKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJHZhciRhc0FycmF5KHYpIHtcbiAgICBpZiAoIXYpIHJldHVybiBbXTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbXG4gICAgICAgIHZcbiAgICBdO1xufVxuZnVuY3Rpb24gJGU1YmUyMDBjNjc1YzNiM2EkdmFyJHJ1blZhbGlkYXRlKHZhbGlkYXRlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsaWRhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBsZXQgZSA9IHZhbGlkYXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKGUgJiYgdHlwZW9mIGUgIT09IFwiYm9vbGVhblwiKSByZXR1cm4gJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGFzQXJyYXkoZSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJHZhciRnZXRWYWxpZGF0aW9uUmVzdWx0KGVycm9ycykge1xuICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID8ge1xuICAgICAgICBpc0ludmFsaWQ6IHRydWUsXG4gICAgICAgIHZhbGlkYXRpb25FcnJvcnM6IGVycm9ycyxcbiAgICAgICAgdmFsaWRhdGlvbkRldGFpbHM6ICRlNWJlMjAwYzY3NWMzYjNhJHZhciRDVVNUT01fVkFMSURJVFlfU1RBVEVcbiAgICB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uICRlNWJlMjAwYzY3NWMzYjNhJHZhciRpc0VxdWFsVmFsaWRhdGlvbihhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBhICYmIGIgJiYgYS5pc0ludmFsaWQgPT09IGIuaXNJbnZhbGlkICYmIGEudmFsaWRhdGlvbkVycm9ycy5sZW5ndGggPT09IGIudmFsaWRhdGlvbkVycm9ycy5sZW5ndGggJiYgYS52YWxpZGF0aW9uRXJyb3JzLmV2ZXJ5KChhLCBpKT0+YSA9PT0gYi52YWxpZGF0aW9uRXJyb3JzW2ldKSAmJiBPYmplY3QuZW50cmllcyhhLnZhbGlkYXRpb25EZXRhaWxzKS5ldmVyeSgoW2ssIHZdKT0+Yi52YWxpZGF0aW9uRGV0YWlsc1trXSA9PT0gdik7XG59XG5mdW5jdGlvbiAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNzVlZTdjNzVkNjhmNWIwZSguLi5yZXN1bHRzKSB7XG4gICAgbGV0IGVycm9ycyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgaXNJbnZhbGlkID0gZmFsc2U7XG4gICAgbGV0IHZhbGlkYXRpb25EZXRhaWxzID0ge1xuICAgICAgICAuLi4kZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYWNhOTU4YzY1YzMxNGU2Y1xuICAgIH07XG4gICAgZm9yIChsZXQgdiBvZiByZXN1bHRzKXtcbiAgICAgICAgdmFyIF92YWxpZGF0aW9uRGV0YWlscywgX2tleTtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB2LnZhbGlkYXRpb25FcnJvcnMpZXJyb3JzLmFkZChlKTtcbiAgICAgICAgLy8gT25seSB0aGVzZSBwcm9wZXJ0aWVzIGFwcGx5IGZvciBjaGVja2JveGVzLlxuICAgICAgICBpc0ludmFsaWQgfHwgKGlzSW52YWxpZCA9IHYuaXNJbnZhbGlkKTtcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gdmFsaWRhdGlvbkRldGFpbHMpKF92YWxpZGF0aW9uRGV0YWlscyA9IHZhbGlkYXRpb25EZXRhaWxzKVtfa2V5ID0ga2V5XSB8fCAoX3ZhbGlkYXRpb25EZXRhaWxzW19rZXldID0gdi52YWxpZGF0aW9uRGV0YWlsc1trZXldKTtcbiAgICB9XG4gICAgdmFsaWRhdGlvbkRldGFpbHMudmFsaWQgPSAhaXNJbnZhbGlkO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzSW52YWxpZDogaXNJbnZhbGlkLFxuICAgICAgICB2YWxpZGF0aW9uRXJyb3JzOiBbXG4gICAgICAgICAgICAuLi5lcnJvcnNcbiAgICAgICAgXSxcbiAgICAgICAgdmFsaWRhdGlvbkRldGFpbHM6IHZhbGlkYXRpb25EZXRhaWxzXG4gICAgfTtcbn1cblxuXG5cblxuZXhwb3J0IHskZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNTcxYjUxMzFiN2U2NWMxMSBhcyBGb3JtVmFsaWRhdGlvbkNvbnRleHQsICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRmYzFhMzY0YWUxZjNmZjEwIGFzIHVzZUZvcm1WYWxpZGF0aW9uU3RhdGUsICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRkYWQ2YWU4NDQ1NmM2NzZhIGFzIERFRkFVTFRfVkFMSURBVElPTl9SRVNVTFQsICRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCRhY2E5NThjNjVjMzE0ZTZjIGFzIFZBTElEX1ZBTElESVRZX1NUQVRFLCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYTc2M2I5NDc2YWNkM2ViIGFzIHByaXZhdGVWYWxpZGF0aW9uU3RhdGVQcm9wLCAkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkNzVlZTdjNzVkNjhmNWIwZSBhcyBtZXJnZVZhbGlkYXRpb259O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCIkamNJT3ckY3JlYXRlQ29udGV4dCIsInVzZU1lbW8iLCIkamNJT3ckdXNlTWVtbyIsInVzZUNvbnRleHQiLCIkamNJT3ckdXNlQ29udGV4dCIsInVzZVN0YXRlIiwiJGpjSU93JHVzZVN0YXRlIiwidXNlUmVmIiwiJGpjSU93JHVzZVJlZiIsInVzZUVmZmVjdCIsIiRqY0lPdyR1c2VFZmZlY3QiLCIkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkYWNhOTU4YzY1YzMxNGU2YyIsImJhZElucHV0IiwiY3VzdG9tRXJyb3IiLCJwYXR0ZXJuTWlzbWF0Y2giLCJyYW5nZU92ZXJmbG93IiwicmFuZ2VVbmRlcmZsb3ciLCJzdGVwTWlzbWF0Y2giLCJ0b29Mb25nIiwidG9vU2hvcnQiLCJ0eXBlTWlzbWF0Y2giLCJ2YWx1ZU1pc3NpbmciLCJ2YWxpZCIsIiRlNWJlMjAwYzY3NWMzYjNhJHZhciRDVVNUT01fVkFMSURJVFlfU1RBVEUiLCIkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZGFkNmFlODQ0NTZjNjc2YSIsImlzSW52YWxpZCIsInZhbGlkYXRpb25EZXRhaWxzIiwidmFsaWRhdGlvbkVycm9ycyIsIiRlNWJlMjAwYzY3NWMzYjNhJGV4cG9ydCQ1NzFiNTEzMWI3ZTY1YzExIiwiJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JGE3NjNiOTQ3NmFjZDNlYiIsIkRhdGUiLCJub3ciLCIkZTViZTIwMGM2NzVjM2IzYSRleHBvcnQkZmMxYTM2NGFlMWYzZmYxMCIsInByb3BzIiwicmVhbHRpbWVWYWxpZGF0aW9uIiwiZGlzcGxheVZhbGlkYXRpb24iLCJ1cGRhdGVWYWxpZGF0aW9uIiwicmVzZXRWYWxpZGF0aW9uIiwiY29tbWl0VmFsaWRhdGlvbiIsIiRlNWJlMjAwYzY3NWMzYjNhJHZhciR1c2VGb3JtVmFsaWRhdGlvblN0YXRlSW1wbCIsInZhbGlkYXRpb25TdGF0ZSIsIm5hbWUiLCJ2YWx1ZSIsImJ1aWx0aW5WYWxpZGF0aW9uIiwidmFsaWRhdGUiLCJ2YWxpZGF0aW9uQmVoYXZpb3IiLCJjb250cm9sbGVkRXJyb3IiLCJjbGllbnRFcnJvciIsIiRlNWJlMjAwYzY3NWMzYjNhJHZhciRnZXRWYWxpZGF0aW9uUmVzdWx0IiwiJGU1YmUyMDBjNjc1YzNiM2EkdmFyJHJ1blZhbGlkYXRlIiwic2VydmVyRXJyb3JzIiwic2VydmVyRXJyb3JNZXNzYWdlcyIsIkFycmF5IiwiaXNBcnJheSIsImZsYXRNYXAiLCIkZTViZTIwMGM2NzVjM2IzYSR2YXIkYXNBcnJheSIsImxhc3RTZXJ2ZXJFcnJvcnMiLCJzZXRMYXN0U2VydmVyRXJyb3JzIiwiaXNTZXJ2ZXJFcnJvckNsZWFyZWQiLCJzZXRTZXJ2ZXJFcnJvckNsZWFyZWQiLCJzZXJ2ZXJFcnJvciIsIm5leHRWYWxpZGF0aW9uIiwiY3VycmVudFZhbGlkaXR5Iiwic2V0Q3VycmVudFZhbGlkaXR5IiwibGFzdEVycm9yIiwiY29tbWl0UXVldWVkIiwic2V0Q29tbWl0UXVldWVkIiwiZXJyb3IiLCJjdXJyZW50IiwiJGU1YmUyMDBjNjc1YzNiM2EkdmFyJGlzRXF1YWxWYWxpZGF0aW9uIiwidiIsImUiLCJlcnJvcnMiLCJsZW5ndGgiLCJhIiwiYiIsImV2ZXJ5IiwiaSIsIk9iamVjdCIsImVudHJpZXMiLCJrIiwiJGU1YmUyMDBjNjc1YzNiM2EkZXhwb3J0JDc1ZWU3Yzc1ZDY4ZjViMGUiLCJyZXN1bHRzIiwiU2V0IiwiX3ZhbGlkYXRpb25EZXRhaWxzIiwiX2tleSIsImFkZCIsImtleSIsIkZvcm1WYWxpZGF0aW9uQ29udGV4dCIsInVzZUZvcm1WYWxpZGF0aW9uU3RhdGUiLCJERUZBVUxUX1ZBTElEQVRJT05fUkVTVUxUIiwiVkFMSURfVkFMSURJVFlfU1RBVEUiLCJwcml2YXRlVmFsaWRhdGlvblN0YXRlUHJvcCIsIm1lcmdlVmFsaWRhdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/form/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/grid/dist/import.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@react-stately/grid/dist/import.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridCollection: () => (/* binding */ $16805b1b18093c5f$export$de3fdf6493c353d),\n/* harmony export */   useGridState: () => (/* binding */ $62967d126f3aa823$export$4007ac09ff9c68ed)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/selection */ \"(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $62967d126f3aa823$export$4007ac09ff9c68ed(props) {\n    let { collection: collection, focusMode: focusMode } = props;\n    let selectionState = (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.useMultipleSelectionState)(props);\n    let disabledKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let setFocusedKey = selectionState.setFocusedKey;\n    selectionState.setFocusedKey = (key, child)=>{\n        // If focusMode is cell and an item is focused, focus a child cell instead.\n        if (focusMode === \"cell\" && key != null) {\n            let item = collection.getItem(key);\n            if ((item === null || item === void 0 ? void 0 : item.type) === \"item\") {\n                var _getLastItem, _getFirstItem;\n                let children = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(item, collection);\n                if (child === \"last\") key = (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n                else key = (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n            }\n        }\n        setFocusedKey(key, child);\n    };\n    let selectionManager = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_selection__WEBPACK_IMPORTED_MODULE_1__.SelectionManager)(collection, selectionState), [\n        collection,\n        selectionState\n    ]);\n    // Reset focused key if that item is deleted from the collection.\n    const cachedCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n            const node = cachedCollection.current.getItem(selectionState.focusedKey);\n            const parentNode = node.parentKey != null && (node.type === \"cell\" || node.type === \"rowheader\" || node.type === \"column\") ? cachedCollection.current.getItem(node.parentKey) : node;\n            const cachedRows = cachedCollection.current.rows;\n            const rows = collection.rows;\n            const diff = cachedRows.length - rows.length;\n            let index = Math.min(diff > 1 ? Math.max(parentNode.index - diff + 1, 0) : parentNode.index, rows.length - 1);\n            let newRow;\n            while(index >= 0){\n                if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== \"headerrow\") {\n                    newRow = rows[index];\n                    break;\n                }\n                // Find next, not disabled row.\n                if (index < rows.length - 1) index++;\n                else {\n                    if (index > parentNode.index) index = parentNode.index;\n                    index--;\n                }\n            }\n            if (newRow) {\n                const childNodes = newRow.hasChildNodes ? [\n                    ...(0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(newRow, collection)\n                ] : [];\n                const keyToFocus = newRow.hasChildNodes && parentNode !== node && node.index < childNodes.length ? childNodes[node.index].key : newRow.key;\n                selectionState.setFocusedKey(keyToFocus);\n            } else selectionState.setFocusedKey(null);\n        }\n        cachedCollection.current = collection;\n    }, [\n        collection,\n        selectionManager,\n        selectionState,\n        selectionState.focusedKey\n    ]);\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        isKeyboardNavigationDisabled: false,\n        selectionManager: selectionManager\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $16805b1b18093c5f$export$de3fdf6493c353d {\n    *[Symbol.iterator]() {\n        yield* [\n            ...this.rows\n        ];\n    }\n    get size() {\n        return [\n            ...this.rows\n        ].length;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _;\n        return (_ = [\n            ...this.rows\n        ][0]) === null || _ === void 0 ? void 0 : _.key;\n    }\n    getLastKey() {\n        var _rows_;\n        let rows = [\n            ...this.rows\n        ];\n        return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getChildren(key) {\n        let node = this.keyMap.get(key);\n        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n    constructor(opts){\n        this.keyMap = new Map();\n        this.keyMap = new Map();\n        this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;\n        this.rows = [];\n        let visit = (node)=>{\n            // If the node is the same object as the previous node for the same key,\n            // we can skip this node and its children. We always visit columns though,\n            // because we depend on order to build the columns array.\n            let prevNode = this.keyMap.get(node.key);\n            if (opts.visitNode) node = opts.visitNode(node);\n            this.keyMap.set(node.key, node);\n            let childKeys = new Set();\n            let last;\n            for (let child of node.childNodes){\n                if (child.type === \"cell\" && child.parentKey == null) child.parentKey = node.key;\n                childKeys.add(child.key);\n                if (last) {\n                    last.nextKey = child.key;\n                    child.prevKey = last.key;\n                } else child.prevKey = null;\n                visit(child);\n                last = child;\n            }\n            if (last) last.nextKey = null;\n            // Remove deleted nodes and their children from the key map\n            if (prevNode) {\n                for (let child of prevNode.childNodes)if (!childKeys.has(child.key)) remove(child);\n            }\n        };\n        let remove = (node)=>{\n            this.keyMap.delete(node.key);\n            for (let child of node.childNodes)if (this.keyMap.get(child.key) === child) remove(child);\n        };\n        let last;\n        opts.items.forEach((node, i)=>{\n            let rowNode = {\n                level: 0,\n                key: \"row-\" + i,\n                type: \"row\",\n                value: undefined,\n                hasChildNodes: true,\n                childNodes: [\n                    ...node.childNodes\n                ],\n                rendered: undefined,\n                textValue: undefined,\n                ...node\n            };\n            if (last) {\n                last.nextKey = rowNode.key;\n                rowNode.prevKey = last.key;\n            } else rowNode.prevKey = null;\n            this.rows.push(rowNode);\n            visit(rowNode);\n            last = rowNode;\n        });\n        if (last) last.nextKey = null;\n    }\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZ3JpZC9kaXN0L2ltcG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUo7QUFDTDtBQUM1QztBQUV4Rzs7Ozs7Ozs7OztDQVVDLEdBR0QsU0FBU2dCLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLEVBQUVDLFlBQVlBLFVBQVUsRUFBRUMsV0FBV0EsU0FBUyxFQUFFLEdBQUdGO0lBQ3ZELElBQUlHLGlCQUFpQixDQUFDLEdBQUdiLCtFQUErQixFQUFHVTtJQUMzRCxJQUFJSSxlQUFlLENBQUMsR0FBR1YsMENBQWEsRUFBRyxJQUFJTSxNQUFNSSxZQUFZLEdBQUcsSUFBSUMsSUFBSUwsTUFBTUksWUFBWSxJQUFJLElBQUlDLE9BQU87UUFDckdMLE1BQU1JLFlBQVk7S0FDckI7SUFDRCxJQUFJRSxnQkFBZ0JILGVBQWVHLGFBQWE7SUFDaERILGVBQWVHLGFBQWEsR0FBRyxDQUFDQyxLQUFLQztRQUNqQywyRUFBMkU7UUFDM0UsSUFBSU4sY0FBYyxVQUFVSyxPQUFPLE1BQU07WUFDckMsSUFBSUUsT0FBT1IsV0FBV1MsT0FBTyxDQUFDSDtZQUM5QixJQUFJLENBQUNFLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLRSxJQUFJLE1BQU0sUUFBUTtnQkFDcEUsSUFBSUMsY0FBY0M7Z0JBQ2xCLElBQUlDLFdBQVcsQ0FBQyxHQUFHOUIscUVBQW1CLEVBQUd5QixNQUFNUjtnQkFDL0MsSUFBSU8sVUFBVSxRQUFRRCxNQUFNLENBQUNLLGVBQWUsQ0FBQyxHQUFHMUIsbUVBQWlCLEVBQUc0QixTQUFRLE1BQU8sUUFBUUYsaUJBQWlCLEtBQUssSUFBSSxLQUFLLElBQUlBLGFBQWFMLEdBQUc7cUJBQ3pJQSxNQUFNLENBQUNNLGdCQUFnQixDQUFDLEdBQUd6QixvRUFBa0IsRUFBRzBCLFNBQVEsTUFBTyxRQUFRRCxrQkFBa0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsY0FBY04sR0FB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Q0FBQzFELE1BQU1ELEdBQUcsR0FBRzRELE9BQU8zRDtZQUNoRjtRQUNKO1FBQ0EsSUFBSTJELFNBQVMsQ0FBQ2pEO1lBQ1YsSUFBSSxDQUFDdUIsTUFBTSxDQUFDMkIsTUFBTSxDQUFDbEQsS0FBS1gsR0FBRztZQUMzQixLQUFLLElBQUlDLFNBQVNVLEtBQUtjLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQ1MsTUFBTSxDQUFDRyxHQUFHLENBQUNwQyxNQUFNRCxHQUFHLE1BQU1DLE9BQU8yRCxPQUFPM0Q7UUFDdkY7UUFDQSxJQUFJd0Q7UUFDSlIsS0FBS2EsS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQ3BELE1BQU1xRDtZQUN0QixJQUFJQyxVQUFVO2dCQUNWQyxPQUFPO2dCQUNQbEUsS0FBSyxTQUFTZ0U7Z0JBQ2Q1RCxNQUFNO2dCQUNOK0QsT0FBT0M7Z0JBQ1AxQyxlQUFlO2dCQUNmRCxZQUFZO3VCQUNMZCxLQUFLYyxVQUFVO2lCQUNyQjtnQkFDRDRDLFVBQVVEO2dCQUNWRSxXQUFXRjtnQkFDWCxHQUFHekQsSUFBSTtZQUNYO1lBQ0EsSUFBSThDLE1BQU07Z0JBQ05BLEtBQUtqQixPQUFPLEdBQUd5QixRQUFRakUsR0FBRztnQkFDMUJpRSxRQUFRM0IsT0FBTyxHQUFHbUIsS0FBS3pELEdBQUc7WUFDOUIsT0FBT2lFLFFBQVEzQixPQUFPLEdBQUc7WUFDekIsSUFBSSxDQUFDdEIsSUFBSSxDQUFDdUQsSUFBSSxDQUFDTjtZQUNmYixNQUFNYTtZQUNOUixPQUFPUTtRQUNYO1FBQ0EsSUFBSVIsTUFBTUEsS0FBS2pCLE9BQU8sR0FBRztJQUM3QjtBQUNKO0FBSytILENBQy9ILGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3pldXMtbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZ3JpZC9kaXN0L2ltcG9ydC5tanM/YjZhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2dldENoaWxkTm9kZXMgYXMgJGNBbjVmJGdldENoaWxkTm9kZXMsIGdldExhc3RJdGVtIGFzICRjQW41ZiRnZXRMYXN0SXRlbSwgZ2V0Rmlyc3RJdGVtIGFzICRjQW41ZiRnZXRGaXJzdEl0ZW19IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9jb2xsZWN0aW9uc1wiO1xuaW1wb3J0IHt1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlIGFzICRjQW41ZiR1c2VNdWx0aXBsZVNlbGVjdGlvblN0YXRlLCBTZWxlY3Rpb25NYW5hZ2VyIGFzICRjQW41ZiRTZWxlY3Rpb25NYW5hZ2VyfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uXCI7XG5pbXBvcnQge3VzZU1lbW8gYXMgJGNBbjVmJHVzZU1lbW8sIHVzZVJlZiBhcyAkY0FuNWYkdXNlUmVmLCB1c2VFZmZlY3QgYXMgJGNBbjVmJHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG5mdW5jdGlvbiAkNjI5NjdkMTI2ZjNhYTgyMyRleHBvcnQkNDAwN2FjMDlmZjljNjhlZChwcm9wcykge1xuICAgIGxldCB7IGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sIGZvY3VzTW9kZTogZm9jdXNNb2RlIH0gPSBwcm9wcztcbiAgICBsZXQgc2VsZWN0aW9uU3RhdGUgPSAoMCwgJGNBbjVmJHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUpKHByb3BzKTtcbiAgICBsZXQgZGlzYWJsZWRLZXlzID0gKDAsICRjQW41ZiR1c2VNZW1vKSgoKT0+cHJvcHMuZGlzYWJsZWRLZXlzID8gbmV3IFNldChwcm9wcy5kaXNhYmxlZEtleXMpIDogbmV3IFNldCgpLCBbXG4gICAgICAgIHByb3BzLmRpc2FibGVkS2V5c1xuICAgIF0pO1xuICAgIGxldCBzZXRGb2N1c2VkS2V5ID0gc2VsZWN0aW9uU3RhdGUuc2V0Rm9jdXNlZEtleTtcbiAgICBzZWxlY3Rpb25TdGF0ZS5zZXRGb2N1c2VkS2V5ID0gKGtleSwgY2hpbGQpPT57XG4gICAgICAgIC8vIElmIGZvY3VzTW9kZSBpcyBjZWxsIGFuZCBhbiBpdGVtIGlzIGZvY3VzZWQsIGZvY3VzIGEgY2hpbGQgY2VsbCBpbnN0ZWFkLlxuICAgICAgICBpZiAoZm9jdXNNb2RlID09PSBcImNlbGxcIiAmJiBrZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBjb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgIGlmICgoaXRlbSA9PT0gbnVsbCB8fCBpdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpdGVtLnR5cGUpID09PSBcIml0ZW1cIikge1xuICAgICAgICAgICAgICAgIHZhciBfZ2V0TGFzdEl0ZW0sIF9nZXRGaXJzdEl0ZW07XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gKDAsICRjQW41ZiRnZXRDaGlsZE5vZGVzKShpdGVtLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT09IFwibGFzdFwiKSBrZXkgPSAoX2dldExhc3RJdGVtID0gKDAsICRjQW41ZiRnZXRMYXN0SXRlbSkoY2hpbGRyZW4pKSA9PT0gbnVsbCB8fCBfZ2V0TGFzdEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRMYXN0SXRlbS5rZXk7XG4gICAgICAgICAgICAgICAgZWxzZSBrZXkgPSAoX2dldEZpcnN0SXRlbSA9ICgwLCAkY0FuNWYkZ2V0Rmlyc3RJdGVtKShjaGlsZHJlbikpID09PSBudWxsIHx8IF9nZXRGaXJzdEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRGaXJzdEl0ZW0ua2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldEZvY3VzZWRLZXkoa2V5LCBjaGlsZCk7XG4gICAgfTtcbiAgICBsZXQgc2VsZWN0aW9uTWFuYWdlciA9ICgwLCAkY0FuNWYkdXNlTWVtbykoKCk9Pm5ldyAoMCwgJGNBbjVmJFNlbGVjdGlvbk1hbmFnZXIpKGNvbGxlY3Rpb24sIHNlbGVjdGlvblN0YXRlKSwgW1xuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBzZWxlY3Rpb25TdGF0ZVxuICAgIF0pO1xuICAgIC8vIFJlc2V0IGZvY3VzZWQga2V5IGlmIHRoYXQgaXRlbSBpcyBkZWxldGVkIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgY29uc3QgY2FjaGVkQ29sbGVjdGlvbiA9ICgwLCAkY0FuNWYkdXNlUmVmKShudWxsKTtcbiAgICAoMCwgJGNBbjVmJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkgIT0gbnVsbCAmJiAhY29sbGVjdGlvbi5nZXRJdGVtKHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50LmdldEl0ZW0oc2VsZWN0aW9uU3RhdGUuZm9jdXNlZEtleSk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRLZXkgIT0gbnVsbCAmJiAobm9kZS50eXBlID09PSBcImNlbGxcIiB8fCBub2RlLnR5cGUgPT09IFwicm93aGVhZGVyXCIgfHwgbm9kZS50eXBlID09PSBcImNvbHVtblwiKSA/IGNhY2hlZENvbGxlY3Rpb24uY3VycmVudC5nZXRJdGVtKG5vZGUucGFyZW50S2V5KSA6IG5vZGU7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWRSb3dzID0gY2FjaGVkQ29sbGVjdGlvbi5jdXJyZW50LnJvd3M7XG4gICAgICAgICAgICBjb25zdCByb3dzID0gY29sbGVjdGlvbi5yb3dzO1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGNhY2hlZFJvd3MubGVuZ3RoIC0gcm93cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBNYXRoLm1pbihkaWZmID4gMSA/IE1hdGgubWF4KHBhcmVudE5vZGUuaW5kZXggLSBkaWZmICsgMSwgMCkgOiBwYXJlbnROb2RlLmluZGV4LCByb3dzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgbGV0IG5ld1JvdztcbiAgICAgICAgICAgIHdoaWxlKGluZGV4ID49IDApe1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0aW9uTWFuYWdlci5pc0Rpc2FibGVkKHJvd3NbaW5kZXhdLmtleSkgJiYgcm93c1tpbmRleF0udHlwZSAhPT0gXCJoZWFkZXJyb3dcIikge1xuICAgICAgICAgICAgICAgICAgICBuZXdSb3cgPSByb3dzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbmQgbmV4dCwgbm90IGRpc2FibGVkIHJvdy5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCByb3dzLmxlbmd0aCAtIDEpIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IHBhcmVudE5vZGUuaW5kZXgpIGluZGV4ID0gcGFyZW50Tm9kZS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3Um93KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IG5ld1Jvdy5oYXNDaGlsZE5vZGVzID8gW1xuICAgICAgICAgICAgICAgICAgICAuLi4oMCwgJGNBbjVmJGdldENoaWxkTm9kZXMpKG5ld1JvdywgY29sbGVjdGlvbilcbiAgICAgICAgICAgICAgICBdIDogW107XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5VG9Gb2N1cyA9IG5ld1Jvdy5oYXNDaGlsZE5vZGVzICYmIHBhcmVudE5vZGUgIT09IG5vZGUgJiYgbm9kZS5pbmRleCA8IGNoaWxkTm9kZXMubGVuZ3RoID8gY2hpbGROb2Rlc1tub2RlLmluZGV4XS5rZXkgOiBuZXdSb3cua2V5O1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXRlLnNldEZvY3VzZWRLZXkoa2V5VG9Gb2N1cyk7XG4gICAgICAgICAgICB9IGVsc2Ugc2VsZWN0aW9uU3RhdGUuc2V0Rm9jdXNlZEtleShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZWRDb2xsZWN0aW9uLmN1cnJlbnQgPSBjb2xsZWN0aW9uO1xuICAgIH0sIFtcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgc2VsZWN0aW9uTWFuYWdlcixcbiAgICAgICAgc2VsZWN0aW9uU3RhdGUsXG4gICAgICAgIHNlbGVjdGlvblN0YXRlLmZvY3VzZWRLZXlcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5cyxcbiAgICAgICAgaXNLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXJcbiAgICB9O1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkMTY4MDViMWIxODA5M2M1ZiRleHBvcnQkZGUzZmRmNjQ5M2MzNTNkIHtcbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHlpZWxkKiBbXG4gICAgICAgICAgICAuLi50aGlzLnJvd3NcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLnJvd3NcbiAgICAgICAgXS5sZW5ndGg7XG4gICAgfVxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5rZXlzKCk7XG4gICAgfVxuICAgIGdldEtleUJlZm9yZShrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLnByZXZLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRLZXlBZnRlcihrZXkpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmtleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLm5leHRLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRGaXJzdEtleSgpIHtcbiAgICAgICAgdmFyIF87XG4gICAgICAgIHJldHVybiAoXyA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMucm93c1xuICAgICAgICBdWzBdKSA9PT0gbnVsbCB8fCBfID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfLmtleTtcbiAgICB9XG4gICAgZ2V0TGFzdEtleSgpIHtcbiAgICAgICAgdmFyIF9yb3dzXztcbiAgICAgICAgbGV0IHJvd3MgPSBbXG4gICAgICAgICAgICAuLi50aGlzLnJvd3NcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChfcm93c18gPSByb3dzW3Jvd3MubGVuZ3RoIC0gMV0pID09PSBudWxsIHx8IF9yb3dzXyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Jvd3NfLmtleTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgIH1cbiAgICBhdChpZHgpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0S2V5cygpXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZW0oa2V5c1tpZHhdKTtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4oa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNoaWxkTm9kZXMpIHx8IFtdO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRzKXtcbiAgICAgICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbHVtbkNvdW50ID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmNvbHVtbkNvdW50O1xuICAgICAgICB0aGlzLnJvd3MgPSBbXTtcbiAgICAgICAgbGV0IHZpc2l0ID0gKG5vZGUpPT57XG4gICAgICAgICAgICAvLyBJZiB0aGUgbm9kZSBpcyB0aGUgc2FtZSBvYmplY3QgYXMgdGhlIHByZXZpb3VzIG5vZGUgZm9yIHRoZSBzYW1lIGtleSxcbiAgICAgICAgICAgIC8vIHdlIGNhbiBza2lwIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBXZSBhbHdheXMgdmlzaXQgY29sdW1ucyB0aG91Z2gsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGRlcGVuZCBvbiBvcmRlciB0byBidWlsZCB0aGUgY29sdW1ucyBhcnJheS5cbiAgICAgICAgICAgIGxldCBwcmV2Tm9kZSA9IHRoaXMua2V5TWFwLmdldChub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAob3B0cy52aXNpdE5vZGUpIG5vZGUgPSBvcHRzLnZpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgICAgIHRoaXMua2V5TWFwLnNldChub2RlLmtleSwgbm9kZSk7XG4gICAgICAgICAgICBsZXQgY2hpbGRLZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpe1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImNlbGxcIiAmJiBjaGlsZC5wYXJlbnRLZXkgPT0gbnVsbCkgLy8gaWYgY2hpbGQgaXMgYSBjZWxsIHBhcmVudCBrZXkgaXNuJ3QgYWxyZWFkeSBlc3RhYmxpc2hlZCBieSB0aGUgY29sbGVjdGlvbiwgbWF0Y2ggY2hpbGQgbm9kZSB0byBwYXJlbnQgcm93XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50S2V5ID0gbm9kZS5rZXk7XG4gICAgICAgICAgICAgICAgY2hpbGRLZXlzLmFkZChjaGlsZC5rZXkpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQucHJldktleSA9IGxhc3Qua2V5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBjaGlsZC5wcmV2S2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2aXNpdChjaGlsZCk7XG4gICAgICAgICAgICAgICAgbGFzdCA9IGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3QpIGxhc3QubmV4dEtleSA9IG51bGw7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZGVsZXRlZCBub2RlcyBhbmQgdGhlaXIgY2hpbGRyZW4gZnJvbSB0aGUga2V5IG1hcFxuICAgICAgICAgICAgaWYgKHByZXZOb2RlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgcHJldk5vZGUuY2hpbGROb2RlcylpZiAoIWNoaWxkS2V5cy5oYXMoY2hpbGQua2V5KSkgcmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlbW92ZSA9IChub2RlKT0+e1xuICAgICAgICAgICAgdGhpcy5rZXlNYXAuZGVsZXRlKG5vZGUua2V5KTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2RlcylpZiAodGhpcy5rZXlNYXAuZ2V0KGNoaWxkLmtleSkgPT09IGNoaWxkKSByZW1vdmUoY2hpbGQpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgb3B0cy5pdGVtcy5mb3JFYWNoKChub2RlLCBpKT0+e1xuICAgICAgICAgICAgbGV0IHJvd05vZGUgPSB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICAgICAga2V5OiBcInJvdy1cIiArIGksXG4gICAgICAgICAgICAgICAgdHlwZTogXCJyb3dcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogW1xuICAgICAgICAgICAgICAgICAgICAuLi5ub2RlLmNoaWxkTm9kZXNcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdGV4dFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLi4ubm9kZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgbGFzdC5uZXh0S2V5ID0gcm93Tm9kZS5rZXk7XG4gICAgICAgICAgICAgICAgcm93Tm9kZS5wcmV2S2V5ID0gbGFzdC5rZXk7XG4gICAgICAgICAgICB9IGVsc2Ugcm93Tm9kZS5wcmV2S2V5ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucm93cy5wdXNoKHJvd05vZGUpO1xuICAgICAgICAgICAgdmlzaXQocm93Tm9kZSk7XG4gICAgICAgICAgICBsYXN0ID0gcm93Tm9kZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsYXN0KSBsYXN0Lm5leHRLZXkgPSBudWxsO1xuICAgIH1cbn1cblxuXG5cblxuZXhwb3J0IHskNjI5NjdkMTI2ZjNhYTgyMyRleHBvcnQkNDAwN2FjMDlmZjljNjhlZCBhcyB1c2VHcmlkU3RhdGUsICQxNjgwNWIxYjE4MDkzYzVmJGV4cG9ydCRkZTNmZGY2NDkzYzM1M2QgYXMgR3JpZENvbGxlY3Rpb259O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbImdldENoaWxkTm9kZXMiLCIkY0FuNWYkZ2V0Q2hpbGROb2RlcyIsImdldExhc3RJdGVtIiwiJGNBbjVmJGdldExhc3RJdGVtIiwiZ2V0Rmlyc3RJdGVtIiwiJGNBbjVmJGdldEZpcnN0SXRlbSIsInVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUiLCIkY0FuNWYkdXNlTXVsdGlwbGVTZWxlY3Rpb25TdGF0ZSIsIlNlbGVjdGlvbk1hbmFnZXIiLCIkY0FuNWYkU2VsZWN0aW9uTWFuYWdlciIsInVzZU1lbW8iLCIkY0FuNWYkdXNlTWVtbyIsInVzZVJlZiIsIiRjQW41ZiR1c2VSZWYiLCJ1c2VFZmZlY3QiLCIkY0FuNWYkdXNlRWZmZWN0IiwiJDYyOTY3ZDEyNmYzYWE4MjMkZXhwb3J0JDQwMDdhYzA5ZmY5YzY4ZWQiLCJwcm9wcyIsImNvbGxlY3Rpb24iLCJmb2N1c01vZGUiLCJzZWxlY3Rpb25TdGF0ZSIsImRpc2FibGVkS2V5cyIsIlNldCIsInNldEZvY3VzZWRLZXkiLCJrZXkiLCJjaGlsZCIsIml0ZW0iLCJnZXRJdGVtIiwidHlwZSIsIl9nZXRMYXN0SXRlbSIsIl9nZXRGaXJzdEl0ZW0iLCJjaGlsZHJlbiIsInNlbGVjdGlvbk1hbmFnZXIiLCJjYWNoZWRDb2xsZWN0aW9uIiwiZm9jdXNlZEtleSIsIm5vZGUiLCJjdXJyZW50IiwicGFyZW50Tm9kZSIsInBhcmVudEtleSIsImNhY2hlZFJvd3MiLCJyb3dzIiwiZGlmZiIsImxlbmd0aCIsImluZGV4IiwiTWF0aCIsIm1pbiIsIm1heCIsIm5ld1JvdyIsImlzRGlzYWJsZWQiLCJjaGlsZE5vZGVzIiwiaGFzQ2hpbGROb2RlcyIsImtleVRvRm9jdXMiLCJpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkIiwiJDE2ODA1YjFiMTgwOTNjNWYkZXhwb3J0JGRlM2ZkZjY0OTNjMzUzZCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwic2l6ZSIsImdldEtleXMiLCJrZXlNYXAiLCJrZXlzIiwiZ2V0S2V5QmVmb3JlIiwiZ2V0IiwicHJldktleSIsImdldEtleUFmdGVyIiwibmV4dEtleSIsImdldEZpcnN0S2V5IiwiXyIsImdldExhc3RLZXkiLCJfcm93c18iLCJhdCIsImlkeCIsImdldENoaWxkcmVuIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiTWFwIiwiY29sdW1uQ291bnQiLCJ2aXNpdCIsInByZXZOb2RlIiwidmlzaXROb2RlIiwic2V0IiwiY2hpbGRLZXlzIiwibGFzdCIsImFkZCIsImhhcyIsInJlbW92ZSIsImRlbGV0ZSIsIml0ZW1zIiwiZm9yRWFjaCIsImkiLCJyb3dOb2RlIiwibGV2ZWwiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsInJlbmRlcmVkIiwidGV4dFZhbHVlIiwicHVzaCIsInVzZUdyaWRTdGF0ZSIsIkdyaWRDb2xsZWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/grid/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/selection/dist/import.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@react-stately/selection/dist/import.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SelectionManager: () => (/* binding */ $d496c0a20b6e58ec$export$6c8a5aaad13c9852),\n/* harmony export */   useMultipleSelectionState: () => (/* binding */ $7af3f5b51489e0b5$export$253fe78d46329472)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $e40ea825a81a3709$export$52baac22726c72bf extends Set {\n    constructor(keys, anchorKey, currentKey){\n        super(keys);\n        if (keys instanceof $e40ea825a81a3709$export$52baac22726c72bf) {\n            this.anchorKey = anchorKey || keys.anchorKey;\n            this.currentKey = currentKey || keys.currentKey;\n        } else {\n            this.anchorKey = anchorKey;\n            this.currentKey = currentKey;\n        }\n    }\n}\nfunction $7af3f5b51489e0b5$var$equalSets(setA, setB) {\n    if (setA.size !== setB.size) return false;\n    for (let item of setA){\n        if (!setB.has(item)) return false;\n    }\n    return true;\n}\nfunction $7af3f5b51489e0b5$export$253fe78d46329472(props) {\n    let { selectionMode: selectionMode = \"none\", disallowEmptySelection: disallowEmptySelection, allowDuplicateSelectionEvents: allowDuplicateSelectionEvents, selectionBehavior: selectionBehaviorProp = \"toggle\", disabledBehavior: disabledBehavior = \"all\" } = props;\n    // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n    // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n    let isFocusedRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    let [, setFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let focusedKeyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let childFocusStrategyRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    let [, setFocusedKey] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let selectedKeysProp = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [\n        props.selectedKeys\n    ]);\n    let defaultSelectedKeys = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [\n        props.defaultSelectedKeys\n    ]);\n    let [selectedKeys, setSelectedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_1__.useControlledState)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);\n    let disabledKeysProp = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let [selectionBehavior, setSelectionBehavior] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(selectionBehaviorProp);\n    // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n    // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n    if (selectionBehaviorProp === \"replace\" && selectionBehavior === \"toggle\" && typeof selectedKeys === \"object\" && selectedKeys.size === 0) setSelectionBehavior(\"replace\");\n    // If the selectionBehavior prop changes, update the state as well.\n    let lastSelectionBehavior = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selectionBehaviorProp);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n            setSelectionBehavior(selectionBehaviorProp);\n            lastSelectionBehavior.current = selectionBehaviorProp;\n        }\n    }, [\n        selectionBehaviorProp\n    ]);\n    return {\n        selectionMode: selectionMode,\n        disallowEmptySelection: disallowEmptySelection,\n        selectionBehavior: selectionBehavior,\n        setSelectionBehavior: setSelectionBehavior,\n        get isFocused () {\n            return isFocusedRef.current;\n        },\n        setFocused (f) {\n            isFocusedRef.current = f;\n            setFocused(f);\n        },\n        get focusedKey () {\n            return focusedKeyRef.current;\n        },\n        get childFocusStrategy () {\n            return childFocusStrategyRef.current;\n        },\n        setFocusedKey (k, childFocusStrategy = \"first\") {\n            focusedKeyRef.current = k;\n            childFocusStrategyRef.current = childFocusStrategy;\n            setFocusedKey(k);\n        },\n        selectedKeys: selectedKeys,\n        setSelectedKeys (keys) {\n            if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys)) setSelectedKeys(keys);\n        },\n        disabledKeys: disabledKeysProp,\n        disabledBehavior: disabledBehavior\n    };\n}\nfunction $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {\n    if (!selection) return defaultValue;\n    return selection === \"all\" ? \"all\" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $d496c0a20b6e58ec$export$6c8a5aaad13c9852 {\n    /**\n   * The type of selection that is allowed in the collection.\n   */ get selectionMode() {\n        return this.state.selectionMode;\n    }\n    /**\n   * Whether the collection allows empty selection.\n   */ get disallowEmptySelection() {\n        return this.state.disallowEmptySelection;\n    }\n    /**\n   * The selection behavior for the collection.\n   */ get selectionBehavior() {\n        return this.state.selectionBehavior;\n    }\n    /**\n   * Sets the selection behavior for the collection.\n   */ setSelectionBehavior(selectionBehavior) {\n        this.state.setSelectionBehavior(selectionBehavior);\n    }\n    /**\n   * Whether the collection is currently focused.\n   */ get isFocused() {\n        return this.state.isFocused;\n    }\n    /**\n   * Sets whether the collection is focused.\n   */ setFocused(isFocused) {\n        this.state.setFocused(isFocused);\n    }\n    /**\n   * The current focused key in the collection.\n   */ get focusedKey() {\n        return this.state.focusedKey;\n    }\n    /** Whether the first or last child of the focused key should receive focus. */ get childFocusStrategy() {\n        return this.state.childFocusStrategy;\n    }\n    /**\n   * Sets the focused key.\n   */ setFocusedKey(key, childFocusStrategy) {\n        if (key == null || this.collection.getItem(key)) this.state.setFocusedKey(key, childFocusStrategy);\n    }\n    /**\n   * The currently selected keys in the collection.\n   */ get selectedKeys() {\n        return this.state.selectedKeys === \"all\" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n    }\n    /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */ get rawSelection() {\n        return this.state.selectedKeys;\n    }\n    /**\n   * Returns whether a key is selected.\n   */ isSelected(key) {\n        if (this.state.selectionMode === \"none\") return false;\n        key = this.getKey(key);\n        return this.state.selectedKeys === \"all\" ? this.canSelectItem(key) : this.state.selectedKeys.has(key);\n    }\n    /**\n   * Whether the selection is empty.\n   */ get isEmpty() {\n        return this.state.selectedKeys !== \"all\" && this.state.selectedKeys.size === 0;\n    }\n    /**\n   * Whether all items in the collection are selected.\n   */ get isSelectAll() {\n        if (this.isEmpty) return false;\n        if (this.state.selectedKeys === \"all\") return true;\n        if (this._isSelectAll != null) return this._isSelectAll;\n        let allKeys = this.getSelectAllKeys();\n        let selectedKeys = this.state.selectedKeys;\n        this._isSelectAll = allKeys.every((k)=>selectedKeys.has(k));\n        return this._isSelectAll;\n    }\n    get firstSelectedKey() {\n        let first = null;\n        for (let key of this.state.selectedKeys){\n            let item = this.collection.getItem(key);\n            if (!first || item && (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, item, first) < 0) first = item;\n        }\n        return first === null || first === void 0 ? void 0 : first.key;\n    }\n    get lastSelectedKey() {\n        let last = null;\n        for (let key of this.state.selectedKeys){\n            let item = this.collection.getItem(key);\n            if (!last || item && (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, item, last) > 0) last = item;\n        }\n        return last === null || last === void 0 ? void 0 : last.key;\n    }\n    get disabledKeys() {\n        return this.state.disabledKeys;\n    }\n    get disabledBehavior() {\n        return this.state.disabledBehavior;\n    }\n    /**\n   * Extends the selection to the given key.\n   */ extendSelection(toKey) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\") {\n            this.replaceSelection(toKey);\n            return;\n        }\n        toKey = this.getKey(toKey);\n        let selection;\n        // Only select the one key if coming from a select all.\n        if (this.state.selectedKeys === \"all\") selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)([\n            toKey\n        ], toKey, toKey);\n        else {\n            let selectedKeys = this.state.selectedKeys;\n            let anchorKey = selectedKeys.anchorKey || toKey;\n            selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);\n            for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey))selection.delete(key);\n            for (let key of this.getKeyRange(toKey, anchorKey))if (this.canSelectItem(key)) selection.add(key);\n        }\n        this.state.setSelectedKeys(selection);\n    }\n    getKeyRange(from, to) {\n        let fromItem = this.collection.getItem(from);\n        let toItem = this.collection.getItem(to);\n        if (fromItem && toItem) {\n            if ((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.compareNodeOrder)(this.collection, fromItem, toItem) <= 0) return this.getKeyRangeInternal(from, to);\n            return this.getKeyRangeInternal(to, from);\n        }\n        return [];\n    }\n    getKeyRangeInternal(from, to) {\n        let keys = [];\n        let key = from;\n        while(key){\n            let item = this.collection.getItem(key);\n            if (item && item.type === \"item\" || item.type === \"cell\" && this.allowsCellSelection) keys.push(key);\n            if (key === to) return keys;\n            key = this.collection.getKeyAfter(key);\n        }\n        return [];\n    }\n    getKey(key) {\n        let item = this.collection.getItem(key);\n        if (!item) return key;\n        // If cell selection is allowed, just return the key.\n        if (item.type === \"cell\" && this.allowsCellSelection) return key;\n        // Find a parent item to select\n        while(item.type !== \"item\" && item.parentKey != null)item = this.collection.getItem(item.parentKey);\n        if (!item || item.type !== \"item\") return null;\n        return item.key;\n    }\n    /**\n   * Toggles whether the given key is selected.\n   */ toggleSelection(key) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\" && !this.isSelected(key)) {\n            this.replaceSelection(key);\n            return;\n        }\n        key = this.getKey(key);\n        if (key == null) return;\n        let keys = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(this.state.selectedKeys === \"all\" ? this.getSelectAllKeys() : this.state.selectedKeys);\n        if (keys.has(key)) keys.delete(key);\n        else if (this.canSelectItem(key)) {\n            keys.add(key);\n            keys.anchorKey = key;\n            keys.currentKey = key;\n        }\n        if (this.disallowEmptySelection && keys.size === 0) return;\n        this.state.setSelectedKeys(keys);\n    }\n    /**\n   * Replaces the selection with only the given key.\n   */ replaceSelection(key) {\n        if (this.selectionMode === \"none\") return;\n        key = this.getKey(key);\n        if (key == null) return;\n        let selection = this.canSelectItem(key) ? new (0, $e40ea825a81a3709$export$52baac22726c72bf)([\n            key\n        ], key, key) : new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n        this.state.setSelectedKeys(selection);\n    }\n    /**\n   * Replaces the selection with the given keys.\n   */ setSelectedKeys(keys) {\n        if (this.selectionMode === \"none\") return;\n        let selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)();\n        for (let key of keys){\n            key = this.getKey(key);\n            if (key != null) {\n                selection.add(key);\n                if (this.selectionMode === \"single\") break;\n            }\n        }\n        this.state.setSelectedKeys(selection);\n    }\n    getSelectAllKeys() {\n        let keys = [];\n        let addKeys = (key)=>{\n            while(key){\n                if (this.canSelectItem(key)) {\n                    let item = this.collection.getItem(key);\n                    if (item.type === \"item\") keys.push(key);\n                    // Add child keys. If cell selection is allowed, then include item children too.\n                    if (item.hasChildNodes && (this.allowsCellSelection || item.type !== \"item\")) addKeys((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)((0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getChildNodes)(item, this.collection)).key);\n                }\n                key = this.collection.getKeyAfter(key);\n            }\n        };\n        addKeys(this.collection.getFirstKey());\n        return keys;\n    }\n    /**\n   * Selects all items in the collection.\n   */ selectAll() {\n        if (!this.isSelectAll && this.selectionMode === \"multiple\") this.state.setSelectedKeys(\"all\");\n    }\n    /**\n   * Removes all keys from the selection.\n   */ clearSelection() {\n        if (!this.disallowEmptySelection && (this.state.selectedKeys === \"all\" || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new (0, $e40ea825a81a3709$export$52baac22726c72bf)());\n    }\n    /**\n   * Toggles between select all and an empty selection.\n   */ toggleSelectAll() {\n        if (this.isSelectAll) this.clearSelection();\n        else this.selectAll();\n    }\n    select(key, e) {\n        if (this.selectionMode === \"none\") return;\n        if (this.selectionMode === \"single\") {\n            if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);\n            else this.replaceSelection(key);\n        } else if (this.selectionBehavior === \"toggle\" || e && (e.pointerType === \"touch\" || e.pointerType === \"virtual\")) this.toggleSelection(key);\n        else this.replaceSelection(key);\n    }\n    /**\n   * Returns whether the current selection is equal to the given selection.\n   */ isSelectionEqual(selection) {\n        if (selection === this.state.selectedKeys) return true;\n        // Check if the set of keys match.\n        let selectedKeys = this.selectedKeys;\n        if (selection.size !== selectedKeys.size) return false;\n        for (let key of selection){\n            if (!selectedKeys.has(key)) return false;\n        }\n        for (let key of selectedKeys){\n            if (!selection.has(key)) return false;\n        }\n        return true;\n    }\n    canSelectItem(key) {\n        if (this.state.selectionMode === \"none\" || this.state.disabledKeys.has(key)) return false;\n        let item = this.collection.getItem(key);\n        if (!item || item.type === \"cell\" && !this.allowsCellSelection) return false;\n        return true;\n    }\n    isDisabled(key) {\n        return this.state.disabledKeys.has(key) && this.state.disabledBehavior === \"all\";\n    }\n    isLink(key) {\n        var _this_collection_getItem_props, _this_collection_getItem;\n        return !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.href);\n    }\n    constructor(collection, state, options){\n        this.collection = collection;\n        this.state = state;\n        var _options_allowsCellSelection;\n        this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;\n        this._isSelectAll = null;\n    }\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvc2VsZWN0aW9uL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRjtBQUNnRDtBQUM4QjtBQUVuSzs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FBRyxNQUFNZ0Isa0RBQWtEQztJQUN4REMsWUFBWUMsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsQ0FBQztRQUNwQyxLQUFLLENBQUNGO1FBQ04sSUFBSUEsZ0JBQWdCSCwyQ0FBMkM7WUFDM0QsSUFBSSxDQUFDSSxTQUFTLEdBQUdBLGFBQWFELEtBQUtDLFNBQVM7WUFDNUMsSUFBSSxDQUFDQyxVQUFVLEdBQUdBLGNBQWNGLEtBQUtFLFVBQVU7UUFDbkQsT0FBTztZQUNILElBQUksQ0FBQ0QsU0FBUyxHQUFHQTtZQUNqQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDdEI7SUFDSjtBQUNKO0FBS0EsU0FBU0MsZ0NBQWdDQyxJQUFJLEVBQUVDLElBQUk7SUFDL0MsSUFBSUQsS0FBS0UsSUFBSSxLQUFLRCxLQUFLQyxJQUFJLEVBQUUsT0FBTztJQUNwQyxLQUFLLElBQUlDLFFBQVFILEtBQUs7UUFDbEIsSUFBSSxDQUFDQyxLQUFLRyxHQUFHLENBQUNELE9BQU8sT0FBTztJQUNoQztJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVNFLDBDQUEwQ0MsS0FBSztJQUNwRCxJQUFJLEVBQUVDLGVBQWVBLGdCQUFnQixNQUFNLEVBQUVDLHdCQUF3QkEsc0JBQXNCLEVBQUVDLCtCQUErQkEsNkJBQTZCLEVBQUVDLG1CQUFtQkMsd0JBQXdCLFFBQVEsRUFBRUMsa0JBQWtCQSxtQkFBbUIsS0FBSyxFQUFFLEdBQUdOO0lBQy9QLDhGQUE4RjtJQUM5RixrR0FBa0c7SUFDbEcsSUFBSU8sZUFBZSxDQUFDLEdBQUdqQyx5Q0FBWSxFQUFHO0lBQ3RDLElBQUksR0FBR2tDLFdBQVcsR0FBRyxDQUFD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YWNrOi8vemV1cy1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS9zZWxlY3Rpb24vZGlzdC9pbXBvcnQubWpzP2FlZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJFFzdG8yJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5pbXBvcnQge3VzZVJlZiBhcyAkUXN0bzIkdXNlUmVmLCB1c2VTdGF0ZSBhcyAkUXN0bzIkdXNlU3RhdGUsIHVzZU1lbW8gYXMgJFFzdG8yJHVzZU1lbW8sIHVzZUVmZmVjdCBhcyAkUXN0bzIkdXNlRWZmZWN0fSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7Y29tcGFyZU5vZGVPcmRlciBhcyAkUXN0bzIkY29tcGFyZU5vZGVPcmRlciwgZ2V0Rmlyc3RJdGVtIGFzICRRc3RvMiRnZXRGaXJzdEl0ZW0sIGdldENoaWxkTm9kZXMgYXMgJFFzdG8yJGdldENoaWxkTm9kZXN9IGZyb20gXCJAcmVhY3Qtc3RhdGVseS9jb2xsZWN0aW9uc1wiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZiBleHRlbmRzIFNldCB7XG4gICAgY29uc3RydWN0b3Ioa2V5cywgYW5jaG9yS2V5LCBjdXJyZW50S2V5KXtcbiAgICAgICAgc3VwZXIoa2V5cyk7XG4gICAgICAgIGlmIChrZXlzIGluc3RhbmNlb2YgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yS2V5ID0gYW5jaG9yS2V5IHx8IGtleXMuYW5jaG9yS2V5O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50S2V5ID0gY3VycmVudEtleSB8fCBrZXlzLmN1cnJlbnRLZXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvcktleSA9IGFuY2hvcktleTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEtleSA9IGN1cnJlbnRLZXk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG5cbmZ1bmN0aW9uICQ3YWYzZjViNTE0ODllMGI1JHZhciRlcXVhbFNldHMoc2V0QSwgc2V0Qikge1xuICAgIGlmIChzZXRBLnNpemUgIT09IHNldEIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGl0ZW0gb2Ygc2V0QSl7XG4gICAgICAgIGlmICghc2V0Qi5oYXMoaXRlbSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkN2FmM2Y1YjUxNDg5ZTBiNSRleHBvcnQkMjUzZmU3OGQ0NjMyOTQ3Mihwcm9wcykge1xuICAgIGxldCB7IHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUgPSBcIm5vbmVcIiwgZGlzYWxsb3dFbXB0eVNlbGVjdGlvbjogZGlzYWxsb3dFbXB0eVNlbGVjdGlvbiwgYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHM6IGFsbG93RHVwbGljYXRlU2VsZWN0aW9uRXZlbnRzLCBzZWxlY3Rpb25CZWhhdmlvcjogc2VsZWN0aW9uQmVoYXZpb3JQcm9wID0gXCJ0b2dnbGVcIiwgZGlzYWJsZWRCZWhhdmlvcjogZGlzYWJsZWRCZWhhdmlvciA9IFwiYWxsXCIgfSA9IHByb3BzO1xuICAgIC8vIFdlIHdhbnQgc3luY2hyb25vdXMgdXBkYXRlcyB0byBgaXNGb2N1c2VkYCBhbmQgYGZvY3VzZWRLZXlgIGFmdGVyIHRoZWlyIHNldHRlcnMgYXJlIGNhbGxlZC5cbiAgICAvLyBCdXQgd2UgYWxzbyBuZWVkIHRvIHRyaWdnZXIgYSByZWFjdCByZS1yZW5kZXIuIFNvLCB3ZSBoYXZlIGJvdGggYSByZWYgKHN5bmMpIGFuZCBzdGF0ZSAoYXN5bmMpLlxuICAgIGxldCBpc0ZvY3VzZWRSZWYgPSAoMCwgJFFzdG8yJHVzZVJlZikoZmFsc2UpO1xuICAgIGxldCBbLCBzZXRGb2N1c2VkXSA9ICgwLCAkUXN0bzIkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgZm9jdXNlZEtleVJlZiA9ICgwLCAkUXN0bzIkdXNlUmVmKShudWxsKTtcbiAgICBsZXQgY2hpbGRGb2N1c1N0cmF0ZWd5UmVmID0gKDAsICRRc3RvMiR1c2VSZWYpKG51bGwpO1xuICAgIGxldCBbLCBzZXRGb2N1c2VkS2V5XSA9ICgwLCAkUXN0bzIkdXNlU3RhdGUpKG51bGwpO1xuICAgIGxldCBzZWxlY3RlZEtleXNQcm9wID0gKDAsICRRc3RvMiR1c2VNZW1vKSgoKT0+JDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGNvbnZlcnRTZWxlY3Rpb24ocHJvcHMuc2VsZWN0ZWRLZXlzKSwgW1xuICAgICAgICBwcm9wcy5zZWxlY3RlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgZGVmYXVsdFNlbGVjdGVkS2V5cyA9ICgwLCAkUXN0bzIkdXNlTWVtbykoKCk9PiQ3YWYzZjViNTE0ODllMGI1JHZhciRjb252ZXJ0U2VsZWN0aW9uKHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleXMsIG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKCkpLCBbXG4gICAgICAgIHByb3BzLmRlZmF1bHRTZWxlY3RlZEtleXNcbiAgICBdKTtcbiAgICBsZXQgW3NlbGVjdGVkS2V5cywgc2V0U2VsZWN0ZWRLZXlzXSA9ICgwLCAkUXN0bzIkdXNlQ29udHJvbGxlZFN0YXRlKShzZWxlY3RlZEtleXNQcm9wLCBkZWZhdWx0U2VsZWN0ZWRLZXlzLCBwcm9wcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgbGV0IGRpc2FibGVkS2V5c1Byb3AgPSAoMCwgJFFzdG8yJHVzZU1lbW8pKCgpPT5wcm9wcy5kaXNhYmxlZEtleXMgPyBuZXcgU2V0KHByb3BzLmRpc2FibGVkS2V5cykgOiBuZXcgU2V0KCksIFtcbiAgICAgICAgcHJvcHMuZGlzYWJsZWRLZXlzXG4gICAgXSk7XG4gICAgbGV0IFtzZWxlY3Rpb25CZWhhdmlvciwgc2V0U2VsZWN0aW9uQmVoYXZpb3JdID0gKDAsICRRc3RvMiR1c2VTdGF0ZSkoc2VsZWN0aW9uQmVoYXZpb3JQcm9wKTtcbiAgICAvLyBJZiB0aGUgc2VsZWN0aW9uQmVoYXZpb3IgcHJvcCBpcyBzZXQgdG8gcmVwbGFjZSwgYnV0IHRoZSBjdXJyZW50IHN0YXRlIGlzIHRvZ2dsZSAoZS5nLiBkdWUgdG8gbG9uZyBwcmVzc1xuICAgIC8vIHRvIGVudGVyIHNlbGVjdGlvbiBtb2RlIG9uIHRvdWNoKSwgYW5kIHRoZSBzZWxlY3Rpb24gYmVjb21lcyBlbXB0eSwgcmVzZXQgdGhlIHNlbGVjdGlvbiBiZWhhdmlvci5cbiAgICBpZiAoc2VsZWN0aW9uQmVoYXZpb3JQcm9wID09PSBcInJlcGxhY2VcIiAmJiBzZWxlY3Rpb25CZWhhdmlvciA9PT0gXCJ0b2dnbGVcIiAmJiB0eXBlb2Ygc2VsZWN0ZWRLZXlzID09PSBcIm9iamVjdFwiICYmIHNlbGVjdGVkS2V5cy5zaXplID09PSAwKSBzZXRTZWxlY3Rpb25CZWhhdmlvcihcInJlcGxhY2VcIik7XG4gICAgLy8gSWYgdGhlIHNlbGVjdGlvbkJlaGF2aW9yIHByb3AgY2hhbmdlcywgdXBkYXRlIHRoZSBzdGF0ZSBhcyB3ZWxsLlxuICAgIGxldCBsYXN0U2VsZWN0aW9uQmVoYXZpb3IgPSAoMCwgJFFzdG8yJHVzZVJlZikoc2VsZWN0aW9uQmVoYXZpb3JQcm9wKTtcbiAgICAoMCwgJFFzdG8yJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgaWYgKHNlbGVjdGlvbkJlaGF2aW9yUHJvcCAhPT0gbGFzdFNlbGVjdGlvbkJlaGF2aW9yLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbkJlaGF2aW9yKHNlbGVjdGlvbkJlaGF2aW9yUHJvcCk7XG4gICAgICAgICAgICBsYXN0U2VsZWN0aW9uQmVoYXZpb3IuY3VycmVudCA9IHNlbGVjdGlvbkJlaGF2aW9yUHJvcDtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgc2VsZWN0aW9uQmVoYXZpb3JQcm9wXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSxcbiAgICAgICAgZGlzYWxsb3dFbXB0eVNlbGVjdGlvbjogZGlzYWxsb3dFbXB0eVNlbGVjdGlvbixcbiAgICAgICAgc2VsZWN0aW9uQmVoYXZpb3I6IHNlbGVjdGlvbkJlaGF2aW9yLFxuICAgICAgICBzZXRTZWxlY3Rpb25CZWhhdmlvcjogc2V0U2VsZWN0aW9uQmVoYXZpb3IsXG4gICAgICAgIGdldCBpc0ZvY3VzZWQgKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRm9jdXNlZFJlZi5jdXJyZW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXRGb2N1c2VkIChmKSB7XG4gICAgICAgICAgICBpc0ZvY3VzZWRSZWYuY3VycmVudCA9IGY7XG4gICAgICAgICAgICBzZXRGb2N1c2VkKGYpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgZm9jdXNlZEtleSAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9jdXNlZEtleVJlZi5jdXJyZW50O1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRGb2N1c1N0cmF0ZWd5ICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZEZvY3VzU3RyYXRlZ3lSZWYuY3VycmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Rm9jdXNlZEtleSAoaywgY2hpbGRGb2N1c1N0cmF0ZWd5ID0gXCJmaXJzdFwiKSB7XG4gICAgICAgICAgICBmb2N1c2VkS2V5UmVmLmN1cnJlbnQgPSBrO1xuICAgICAgICAgICAgY2hpbGRGb2N1c1N0cmF0ZWd5UmVmLmN1cnJlbnQgPSBjaGlsZEZvY3VzU3RyYXRlZ3k7XG4gICAgICAgICAgICBzZXRGb2N1c2VkS2V5KGspO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RlZEtleXM6IHNlbGVjdGVkS2V5cyxcbiAgICAgICAgc2V0U2VsZWN0ZWRLZXlzIChrZXlzKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHMgfHwgISQ3YWYzZjViNTE0ODllMGI1JHZhciRlcXVhbFNldHMoa2V5cywgc2VsZWN0ZWRLZXlzKSkgc2V0U2VsZWN0ZWRLZXlzKGtleXMpO1xuICAgICAgICB9LFxuICAgICAgICBkaXNhYmxlZEtleXM6IGRpc2FibGVkS2V5c1Byb3AsXG4gICAgICAgIGRpc2FibGVkQmVoYXZpb3I6IGRpc2FibGVkQmVoYXZpb3JcbiAgICB9O1xufVxuZnVuY3Rpb24gJDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGNvbnZlcnRTZWxlY3Rpb24oc2VsZWN0aW9uLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoIXNlbGVjdGlvbikgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICByZXR1cm4gc2VsZWN0aW9uID09PSBcImFsbFwiID8gXCJhbGxcIiA6IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKHNlbGVjdGlvbik7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5jbGFzcyAkZDQ5NmMwYTIwYjZlNThlYyRleHBvcnQkNmM4YTVhYWFkMTNjOTg1MiB7XG4gICAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHNlbGVjdGlvbiB0aGF0IGlzIGFsbG93ZWQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqLyBnZXQgc2VsZWN0aW9uTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0aW9uTW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNvbGxlY3Rpb24gYWxsb3dzIGVtcHR5IHNlbGVjdGlvbi5cbiAgICovIGdldCBkaXNhbGxvd0VtcHR5U2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kaXNhbGxvd0VtcHR5U2VsZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIHNlbGVjdGlvbiBiZWhhdmlvciBmb3IgdGhlIGNvbGxlY3Rpb24uXG4gICAqLyBnZXQgc2VsZWN0aW9uQmVoYXZpb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGlvbkJlaGF2aW9yO1xuICAgIH1cbiAgICAvKipcbiAgICogU2V0cyB0aGUgc2VsZWN0aW9uIGJlaGF2aW9yIGZvciB0aGUgY29sbGVjdGlvbi5cbiAgICovIHNldFNlbGVjdGlvbkJlaGF2aW9yKHNlbGVjdGlvbkJlaGF2aW9yKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2VsZWN0aW9uQmVoYXZpb3Ioc2VsZWN0aW9uQmVoYXZpb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICogV2hldGhlciB0aGUgY29sbGVjdGlvbiBpcyBjdXJyZW50bHkgZm9jdXNlZC5cbiAgICovIGdldCBpc0ZvY3VzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRm9jdXNlZDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0aGUgY29sbGVjdGlvbiBpcyBmb2N1c2VkLlxuICAgKi8gc2V0Rm9jdXNlZChpc0ZvY3VzZWQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRGb2N1c2VkKGlzRm9jdXNlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgY3VycmVudCBmb2N1c2VkIGtleSBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovIGdldCBmb2N1c2VkS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5mb2N1c2VkS2V5O1xuICAgIH1cbiAgICAvKiogV2hldGhlciB0aGUgZmlyc3Qgb3IgbGFzdCBjaGlsZCBvZiB0aGUgZm9jdXNlZCBrZXkgc2hvdWxkIHJlY2VpdmUgZm9jdXMuICovIGdldCBjaGlsZEZvY3VzU3RyYXRlZ3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNoaWxkRm9jdXNTdHJhdGVneTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNldHMgdGhlIGZvY3VzZWQga2V5LlxuICAgKi8gc2V0Rm9jdXNlZEtleShrZXksIGNoaWxkRm9jdXNTdHJhdGVneSkge1xuICAgICAgICBpZiAoa2V5ID09IG51bGwgfHwgdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KSkgdGhpcy5zdGF0ZS5zZXRGb2N1c2VkS2V5KGtleSwgY2hpbGRGb2N1c1N0cmF0ZWd5KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQga2V5cyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICovIGdldCBzZWxlY3RlZEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIiA/IG5ldyBTZXQodGhpcy5nZXRTZWxlY3RBbGxLZXlzKCkpIDogdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXM7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgcmF3IHNlbGVjdGlvbiB2YWx1ZSBmb3IgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEVpdGhlciAnYWxsJyBmb3Igc2VsZWN0IGFsbCwgb3IgYSBzZXQgb2Yga2V5cy5cbiAgICovIGdldCByYXdTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhIGtleSBpcyBzZWxlY3RlZC5cbiAgICovIGlzU2VsZWN0ZWQoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyA9PT0gXCJhbGxcIiA/IHRoaXMuY2FuU2VsZWN0SXRlbShrZXkpIDogdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMuaGFzKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkuXG4gICAqLyBnZXQgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzICE9PSBcImFsbFwiICYmIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzLnNpemUgPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgKiBXaGV0aGVyIGFsbCBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbiBhcmUgc2VsZWN0ZWQuXG4gICAqLyBnZXQgaXNTZWxlY3RBbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0QWxsICE9IG51bGwpIHJldHVybiB0aGlzLl9pc1NlbGVjdEFsbDtcbiAgICAgICAgbGV0IGFsbEtleXMgPSB0aGlzLmdldFNlbGVjdEFsbEtleXMoKTtcbiAgICAgICAgbGV0IHNlbGVjdGVkS2V5cyA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdEFsbCA9IGFsbEtleXMuZXZlcnkoKGspPT5zZWxlY3RlZEtleXMuaGFzKGspKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0QWxsO1xuICAgIH1cbiAgICBnZXQgZmlyc3RTZWxlY3RlZEtleSgpIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzKXtcbiAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgIGlmICghZmlyc3QgfHwgaXRlbSAmJiAoMCwgJFFzdG8yJGNvbXBhcmVOb2RlT3JkZXIpKHRoaXMuY29sbGVjdGlvbiwgaXRlbSwgZmlyc3QpIDwgMCkgZmlyc3QgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaXJzdCA9PT0gbnVsbCB8fCBmaXJzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyc3Qua2V5O1xuICAgIH1cbiAgICBnZXQgbGFzdFNlbGVjdGVkS2V5KCkge1xuICAgICAgICBsZXQgbGFzdCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyl7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBpZiAoIWxhc3QgfHwgaXRlbSAmJiAoMCwgJFFzdG8yJGNvbXBhcmVOb2RlT3JkZXIpKHRoaXMuY29sbGVjdGlvbiwgaXRlbSwgbGFzdCkgPiAwKSBsYXN0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdCA9PT0gbnVsbCB8fCBsYXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0LmtleTtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZGlzYWJsZWRLZXlzO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWRCZWhhdmlvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZGlzYWJsZWRCZWhhdmlvcjtcbiAgICB9XG4gICAgLyoqXG4gICAqIEV4dGVuZHMgdGhlIHNlbGVjdGlvbiB0byB0aGUgZ2l2ZW4ga2V5LlxuICAgKi8gZXh0ZW5kU2VsZWN0aW9uKHRvS2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwic2luZ2xlXCIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbih0b0tleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdG9LZXkgPSB0aGlzLmdldEtleSh0b0tleSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb247XG4gICAgICAgIC8vIE9ubHkgc2VsZWN0IHRoZSBvbmUga2V5IGlmIGNvbWluZyBmcm9tIGEgc2VsZWN0IGFsbC5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiKSBzZWxlY3Rpb24gPSBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKShbXG4gICAgICAgICAgICB0b0tleVxuICAgICAgICBdLCB0b0tleSwgdG9LZXkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZEtleXMgPSB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cztcbiAgICAgICAgICAgIGxldCBhbmNob3JLZXkgPSBzZWxlY3RlZEtleXMuYW5jaG9yS2V5IHx8IHRvS2V5O1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoc2VsZWN0ZWRLZXlzLCBhbmNob3JLZXksIHRvS2V5KTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLmdldEtleVJhbmdlKGFuY2hvcktleSwgc2VsZWN0ZWRLZXlzLmN1cnJlbnRLZXkgfHwgdG9LZXkpKXNlbGVjdGlvbi5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLmdldEtleVJhbmdlKHRvS2V5LCBhbmNob3JLZXkpKWlmICh0aGlzLmNhblNlbGVjdEl0ZW0oa2V5KSkgc2VsZWN0aW9uLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2VsZWN0ZWRLZXlzKHNlbGVjdGlvbik7XG4gICAgfVxuICAgIGdldEtleVJhbmdlKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBmcm9tSXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGZyb20pO1xuICAgICAgICBsZXQgdG9JdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0odG8pO1xuICAgICAgICBpZiAoZnJvbUl0ZW0gJiYgdG9JdGVtKSB7XG4gICAgICAgICAgICBpZiAoKDAsICRRc3RvMiRjb21wYXJlTm9kZU9yZGVyKSh0aGlzLmNvbGxlY3Rpb24sIGZyb21JdGVtLCB0b0l0ZW0pIDw9IDApIHJldHVybiB0aGlzLmdldEtleVJhbmdlSW50ZXJuYWwoZnJvbSwgdG8pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5UmFuZ2VJbnRlcm5hbCh0bywgZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBnZXRLZXlSYW5nZUludGVybmFsKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBrZXlzID0gW107XG4gICAgICAgIGxldCBrZXkgPSBmcm9tO1xuICAgICAgICB3aGlsZShrZXkpe1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS50eXBlID09PSBcIml0ZW1cIiB8fCBpdGVtLnR5cGUgPT09IFwiY2VsbFwiICYmIHRoaXMuYWxsb3dzQ2VsbFNlbGVjdGlvbikga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB0bykgcmV0dXJuIGtleXM7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmNvbGxlY3Rpb24uZ2V0S2V5QWZ0ZXIoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGdldEtleShrZXkpIHtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uZ2V0SXRlbShrZXkpO1xuICAgICAgICBpZiAoIWl0ZW0pIC8vIMKvXFxfKOODhClfL8KvXG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIC8vIElmIGNlbGwgc2VsZWN0aW9uIGlzIGFsbG93ZWQsIGp1c3QgcmV0dXJuIHRoZSBrZXkuXG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwiY2VsbFwiICYmIHRoaXMuYWxsb3dzQ2VsbFNlbGVjdGlvbikgcmV0dXJuIGtleTtcbiAgICAgICAgLy8gRmluZCBhIHBhcmVudCBpdGVtIHRvIHNlbGVjdFxuICAgICAgICB3aGlsZShpdGVtLnR5cGUgIT09IFwiaXRlbVwiICYmIGl0ZW0ucGFyZW50S2V5ICE9IG51bGwpaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGl0ZW0ucGFyZW50S2V5KTtcbiAgICAgICAgaWYgKCFpdGVtIHx8IGl0ZW0udHlwZSAhPT0gXCJpdGVtXCIpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gaXRlbS5rZXk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUb2dnbGVzIHdoZXRoZXIgdGhlIGdpdmVuIGtleSBpcyBzZWxlY3RlZC5cbiAgICovIHRvZ2dsZVNlbGVjdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJzaW5nbGVcIiAmJiAhdGhpcy5pc1NlbGVjdGVkKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbihrZXkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSk7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBsZXQga2V5cyA9IG5ldyAoMCwgJGU0MGVhODI1YTgxYTM3MDkkZXhwb3J0JDUyYmFhYzIyNzI2YzcyYmYpKHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiID8gdGhpcy5nZXRTZWxlY3RBbGxLZXlzKCkgOiB0aGlzLnN0YXRlLnNlbGVjdGVkS2V5cyk7XG4gICAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSBrZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmNhblNlbGVjdEl0ZW0oa2V5KSkge1xuICAgICAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGtleXMuYW5jaG9yS2V5ID0ga2V5O1xuICAgICAgICAgICAga2V5cy5jdXJyZW50S2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2FsbG93RW1wdHlTZWxlY3Rpb24gJiYga2V5cy5zaXplID09PSAwKSByZXR1cm47XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2VsZWN0ZWRLZXlzKGtleXMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHNlbGVjdGlvbiB3aXRoIG9ubHkgdGhlIGdpdmVuIGtleS5cbiAgICovIHJlcGxhY2VTZWxlY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm47XG4gICAgICAgIGtleSA9IHRoaXMuZ2V0S2V5KGtleSk7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5jYW5TZWxlY3RJdGVtKGtleSkgPyBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKShbXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgXSwga2V5LCBrZXkpIDogbmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMoc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4ga2V5cy5cbiAgICovIHNldFNlbGVjdGVkS2V5cyhrZXlzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibm9uZVwiKSByZXR1cm47XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBuZXcgKDAsICRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmKSgpO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cyl7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmdldEtleShrZXkpO1xuICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwic2luZ2xlXCIpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2VsZWN0ZWRLZXlzKHNlbGVjdGlvbik7XG4gICAgfVxuICAgIGdldFNlbGVjdEFsbEtleXMoKSB7XG4gICAgICAgIGxldCBrZXlzID0gW107XG4gICAgICAgIGxldCBhZGRLZXlzID0gKGtleSk9PntcbiAgICAgICAgICAgIHdoaWxlKGtleSl7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuU2VsZWN0SXRlbShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5jb2xsZWN0aW9uLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJpdGVtXCIpIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY2hpbGQga2V5cy4gSWYgY2VsbCBzZWxlY3Rpb24gaXMgYWxsb3dlZCwgdGhlbiBpbmNsdWRlIGl0ZW0gY2hpbGRyZW4gdG9vLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5oYXNDaGlsZE5vZGVzICYmICh0aGlzLmFsbG93c0NlbGxTZWxlY3Rpb24gfHwgaXRlbS50eXBlICE9PSBcIml0ZW1cIikpIGFkZEtleXMoKDAsICRRc3RvMiRnZXRGaXJzdEl0ZW0pKCgwLCAkUXN0bzIkZ2V0Q2hpbGROb2RlcykoaXRlbSwgdGhpcy5jb2xsZWN0aW9uKSkua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5jb2xsZWN0aW9uLmdldEtleUFmdGVyKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFkZEtleXModGhpcy5jb2xsZWN0aW9uLmdldEZpcnN0S2V5KCkpO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgLyoqXG4gICAqIFNlbGVjdHMgYWxsIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgKi8gc2VsZWN0QWxsKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTZWxlY3RBbGwgJiYgdGhpcy5zZWxlY3Rpb25Nb2RlID09PSBcIm11bHRpcGxlXCIpIHRoaXMuc3RhdGUuc2V0U2VsZWN0ZWRLZXlzKFwiYWxsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmVtb3ZlcyBhbGwga2V5cyBmcm9tIHRoZSBzZWxlY3Rpb24uXG4gICAqLyBjbGVhclNlbGVjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FsbG93RW1wdHlTZWxlY3Rpb24gJiYgKHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzID09PSBcImFsbFwiIHx8IHRoaXMuc3RhdGUuc2VsZWN0ZWRLZXlzLnNpemUgPiAwKSkgdGhpcy5zdGF0ZS5zZXRTZWxlY3RlZEtleXMobmV3ICgwLCAkZTQwZWE4MjVhODFhMzcwOSRleHBvcnQkNTJiYWFjMjI3MjZjNzJiZikoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUb2dnbGVzIGJldHdlZW4gc2VsZWN0IGFsbCBhbmQgYW4gZW1wdHkgc2VsZWN0aW9uLlxuICAgKi8gdG9nZ2xlU2VsZWN0QWxsKCkge1xuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdEFsbCkgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICBlbHNlIHRoaXMuc2VsZWN0QWxsKCk7XG4gICAgfVxuICAgIHNlbGVjdChrZXksIGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJub25lXCIpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJzaW5nbGVcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZChrZXkpICYmICF0aGlzLmRpc2FsbG93RW1wdHlTZWxlY3Rpb24pIHRoaXMudG9nZ2xlU2VsZWN0aW9uKGtleSk7XG4gICAgICAgICAgICBlbHNlIHRoaXMucmVwbGFjZVNlbGVjdGlvbihrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uQmVoYXZpb3IgPT09IFwidG9nZ2xlXCIgfHwgZSAmJiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwidmlydHVhbFwiKSkgLy8gaWYgdG91Y2ggb3IgdmlydHVhbCAoVk8pIHRoZW4gd2UganVzdCB3YW50IHRvIHRvZ2dsZSwgb3RoZXJ3aXNlIGl0J3MgaW1wb3NzaWJsZSB0byBtdWx0aSBzZWxlY3QgYmVjYXVzZSB0aGV5IGRvbid0IGhhdmUgbW9kaWZpZXIga2V5c1xuICAgICAgICB0aGlzLnRvZ2dsZVNlbGVjdGlvbihrZXkpO1xuICAgICAgICBlbHNlIHRoaXMucmVwbGFjZVNlbGVjdGlvbihrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gc2VsZWN0aW9uLlxuICAgKi8gaXNTZWxlY3Rpb25FcXVhbChzZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiA9PT0gdGhpcy5zdGF0ZS5zZWxlY3RlZEtleXMpIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2V0IG9mIGtleXMgbWF0Y2guXG4gICAgICAgIGxldCBzZWxlY3RlZEtleXMgPSB0aGlzLnNlbGVjdGVkS2V5cztcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5zaXplICE9PSBzZWxlY3RlZEtleXMuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2Ygc2VsZWN0aW9uKXtcbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWRLZXlzLmhhcyhrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHNlbGVjdGVkS2V5cyl7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYW5TZWxlY3RJdGVtKGtleSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zZWxlY3Rpb25Nb2RlID09PSBcIm5vbmVcIiB8fCB0aGlzLnN0YXRlLmRpc2FibGVkS2V5cy5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmICghaXRlbSB8fCBpdGVtLnR5cGUgPT09IFwiY2VsbFwiICYmICF0aGlzLmFsbG93c0NlbGxTZWxlY3Rpb24pIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzRGlzYWJsZWQoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRpc2FibGVkS2V5cy5oYXMoa2V5KSAmJiB0aGlzLnN0YXRlLmRpc2FibGVkQmVoYXZpb3IgPT09IFwiYWxsXCI7XG4gICAgfVxuICAgIGlzTGluayhrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbV9wcm9wcywgX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtO1xuICAgICAgICByZXR1cm4gISEoKF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbSA9IHRoaXMuY29sbGVjdGlvbi5nZXRJdGVtKGtleSkpID09PSBudWxsIHx8IF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbV9wcm9wcyA9IF90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbS5wcm9wcykgPT09IG51bGwgfHwgX3RoaXNfY29sbGVjdGlvbl9nZXRJdGVtX3Byb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19jb2xsZWN0aW9uX2dldEl0ZW1fcHJvcHMuaHJlZik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvbGxlY3Rpb24sIHN0YXRlLCBvcHRpb25zKXtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB2YXIgX29wdGlvbnNfYWxsb3dzQ2VsbFNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5hbGxvd3NDZWxsU2VsZWN0aW9uID0gKF9vcHRpb25zX2FsbG93c0NlbGxTZWxlY3Rpb24gPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWxsb3dzQ2VsbFNlbGVjdGlvbikgIT09IG51bGwgJiYgX29wdGlvbnNfYWxsb3dzQ2VsbFNlbGVjdGlvbiAhPT0gdm9pZCAwID8gX29wdGlvbnNfYWxsb3dzQ2VsbFNlbGVjdGlvbiA6IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NlbGVjdEFsbCA9IG51bGw7XG4gICAgfVxufVxuXG5cblxuXG5leHBvcnQgeyQ3YWYzZjViNTE0ODllMGI1JGV4cG9ydCQyNTNmZTc4ZDQ2MzI5NDcyIGFzIHVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUsICRkNDk2YzBhMjBiNmU1OGVjJGV4cG9ydCQ2YzhhNWFhYWQxM2M5ODUyIGFzIFNlbGVjdGlvbk1hbmFnZXJ9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiRRc3RvMiR1c2VDb250cm9sbGVkU3RhdGUiLCJ1c2VSZWYiLCIkUXN0bzIkdXNlUmVmIiwidXNlU3RhdGUiLCIkUXN0bzIkdXNlU3RhdGUiLCJ1c2VNZW1vIiwiJFFzdG8yJHVzZU1lbW8iLCJ1c2VFZmZlY3QiLCIkUXN0bzIkdXNlRWZmZWN0IiwiY29tcGFyZU5vZGVPcmRlciIsIiRRc3RvMiRjb21wYXJlTm9kZU9yZGVyIiwiZ2V0Rmlyc3RJdGVtIiwiJFFzdG8yJGdldEZpcnN0SXRlbSIsImdldENoaWxkTm9kZXMiLCIkUXN0bzIkZ2V0Q2hpbGROb2RlcyIsIiRlNDBlYTgyNWE4MWEzNzA5JGV4cG9ydCQ1MmJhYWMyMjcyNmM3MmJmIiwiU2V0IiwiY29uc3RydWN0b3IiLCJrZXlzIiwiYW5jaG9yS2V5IiwiY3VycmVudEtleSIsIiQ3YWYzZjViNTE0ODllMGI1JHZhciRlcXVhbFNldHMiLCJzZXRBIiwic2V0QiIsInNpemUiLCJpdGVtIiwiaGFzIiwiJDdhZjNmNWI1MTQ4OWUwYjUkZXhwb3J0JDI1M2ZlNzhkNDYzMjk0NzIiLCJwcm9wcyIsInNlbGVjdGlvbk1vZGUiLCJkaXNhbGxvd0VtcHR5U2VsZWN0aW9uIiwiYWxsb3dEdXBsaWNhdGVTZWxlY3Rpb25FdmVudHMiLCJzZWxlY3Rpb25CZWhhdmlvciIsInNlbGVjdGlvbkJlaGF2aW9yUHJvcCIsImRpc2FibGVkQmVoYXZpb3IiLCJpc0ZvY3VzZWRSZWYiLCJzZXRGb2N1c2VkIiwiZm9jdXNlZEtleVJlZiIsImNoaWxkRm9jdXNTdHJhdGVneVJlZiIsInNldEZvY3VzZWRLZXkiLCJzZWxlY3RlZEtleXNQcm9wIiwiJDdhZjNmNWI1MTQ4OWUwYjUkdmFyJGNvbnZlcnRTZWxlY3Rpb24iLCJzZWxlY3RlZEtleXMiLCJkZWZhdWx0U2VsZWN0ZWRLZXlzIiwic2V0U2VsZWN0ZWRLZXlzIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJkaXNhYmxlZEtleXNQcm9wIiwiZGlzYWJsZWRLZXlzIiwic2V0U2VsZWN0aW9uQmVoYXZpb3IiLCJsYXN0U2VsZWN0aW9uQmVoYXZpb3IiLCJjdXJyZW50IiwiaXNGb2N1c2VkIiwiZiIsImZvY3VzZWRLZXkiLCJjaGlsZEZvY3VzU3RyYXRlZ3kiLCJrIiwic2VsZWN0aW9uIiwiZGVmYXVsdFZhbHVlIiwiJGQ0OTZjMGEyMGI2ZTU4ZWMkZXhwb3J0JDZjOGE1YWFhZDEzYzk4NTIiLCJzdGF0ZSIsImtleSIsImNvbGxlY3Rpb24iLCJnZXRJdGVtIiwiZ2V0U2VsZWN0QWxsS2V5cyIsInJhd1NlbGVjdGlvbiIsImlzU2VsZWN0ZWQiLCJnZXRLZXkiLCJjYW5TZWxlY3RJdGVtIiwiaXNFbXB0eSIsImlzU2VsZWN0QWxsIiwiX2lzU2VsZWN0QWxsIiwiYWxsS2V5cyIsImV2ZXJ5IiwiZmlyc3RTZWxlY3RlZEtleSIsImZpcnN0IiwibGFzdFNlbGVjdGVkS2V5IiwibGFzdCIsImV4dGVuZFNlbGVjdGlvbiIsInRvS2V5IiwicmVwbGFjZVNlbGVjdGlvbiIsImdldEtleVJhbmdlIiwiZGVsZXRlIiwiYWRkIiwiZnJvbSIsInRvIiwiZnJvbUl0ZW0iLCJ0b0l0ZW0iLCJnZXRLZXlSYW5nZUludGVybmFsIiwidHlwZSIsImFsbG93c0NlbGxTZWxlY3Rpb24iLCJwdXNoIiwiZ2V0S2V5QWZ0ZXIiLCJwYXJlbnRLZXkiLCJ0b2dnbGVTZWxlY3Rpb24iLCJhZGRLZXlzIiwiaGFzQ2hpbGROb2RlcyIsImdldEZpcnN0S2V5Iiwic2VsZWN0QWxsIiwiY2xlYXJTZWxlY3Rpb24iLCJ0b2dnbGVTZWxlY3RBbGwiLCJzZWxlY3QiLCJlIiwicG9pbnRlclR5cGUiLCJpc1NlbGVjdGlvbkVxdWFsIiwiaXNEaXNhYmxlZCIsImlzTGluayIsIl90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbV9wcm9wcyIsIl90aGlzX2NvbGxlY3Rpb25fZ2V0SXRlbSIsImhyZWYiLCJvcHRpb25zIiwiX29wdGlvbnNfYWxsb3dzQ2VsbFNlbGVjdGlvbiIsInVzZU11bHRpcGxlU2VsZWN0aW9uU3RhdGUiLCJTZWxlY3Rpb25NYW5hZ2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/selection/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/table/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/table/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: () => (/* binding */ $941d1d9a6a28982a$export$f6f0c3fe4ec306ea),\n/* harmony export */   Column: () => (/* binding */ $1cd244557c2f97d5$export$816b5d811295e6bc),\n/* harmony export */   Row: () => (/* binding */ $70d70eb16ea48428$export$b59bdbef9ce70de2),\n/* harmony export */   Section: () => (/* reexport safe */ _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.Section),\n/* harmony export */   TableBody: () => (/* binding */ $4ae5314bf50db1a3$export$76ccd210b9029917),\n/* harmony export */   TableCollection: () => (/* binding */ $788781baa30117fa$export$596e1b2e2cf93690),\n/* harmony export */   TableColumnLayout: () => (/* binding */ $a9e7ae544a4e41dd$export$7ff77a162970b30e),\n/* harmony export */   TableHeader: () => (/* binding */ $312ae3b56a94a86e$export$f850895b287ef28e),\n/* harmony export */   UNSTABLE_useTreeGridState: () => (/* binding */ $ee65a0057fd99531$export$34dfa8a1622185a4),\n/* harmony export */   buildHeaderRows: () => (/* binding */ $788781baa30117fa$export$7c127db850d4e81e),\n/* harmony export */   useTableColumnResizeState: () => (/* binding */ $292bc4e09cd0eb62$export$cb895dcf85db1319),\n/* harmony export */   useTableState: () => (/* binding */ $4a0dd036d492cee4$export$907bcc6c48325fd6)\n/* harmony export */ });\n/* harmony import */ var _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-stately/collections */ \"(ssr)/./node_modules/@react-stately/collections/dist/import.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-stately/grid */ \"(ssr)/./node_modules/@react-stately/grid/dist/import.mjs\");\n/* harmony import */ var _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-stately/flags */ \"(ssr)/./node_modules/@react-stately/flags/dist/import.mjs\");\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $6818b1c4fc67028d$export$1994a077b98ee0d5(width) {\n    return width != null && (!isNaN(width) || String(width).match(/^(\\d+)(?=%$)/) !== null);\n}\nfunction $6818b1c4fc67028d$export$9078bad4c3934604(width) {\n    if (!width) return 1;\n    let match = width.match(/^(.+)(?=fr$)/);\n    // if width is the incorrect format, just default it to a 1fr\n    if (!match) {\n        console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, \"defaulting to '1fr'\");\n        return 1;\n    }\n    return parseFloat(match[0]);\n}\nfunction $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, tableWidth) {\n    if (typeof width === \"string\") {\n        let match = width.match(/^(\\d+)(?=%$)/);\n        if (!match) throw new Error(\"Only percentages or numbers are supported for static column widths\");\n        return tableWidth * (parseFloat(match[0]) / 100);\n    }\n    return width;\n}\nfunction $6818b1c4fc67028d$export$59185c62a7544aa0(maxWidth, tableWidth) {\n    return maxWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;\n}\nfunction $6818b1c4fc67028d$export$f556054ce4358701(minWidth, tableWidth) {\n    return minWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(minWidth, tableWidth) : 0;\n}\nfunction $6818b1c4fc67028d$export$55d50dc687385491(availableWidth, columns, changedColumns, getDefaultWidth, getDefaultMinWidth) {\n    let hasNonFrozenItems = false;\n    let flexItems = columns.map((column, index)=>{\n        var _column_width, _ref, _ref1;\n        let width = changedColumns.get(column.key) != null ? changedColumns.get(column.key) : (_ref1 = (_ref = (_column_width = column.width) !== null && _column_width !== void 0 ? _column_width : column.defaultWidth) !== null && _ref !== void 0 ? _ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(index)) !== null && _ref1 !== void 0 ? _ref1 : \"1fr\";\n        let frozen = false;\n        let baseSize = 0;\n        let flex = 0;\n        let targetMainSize = null;\n        if ($6818b1c4fc67028d$export$1994a077b98ee0d5(width)) {\n            baseSize = $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, availableWidth);\n            frozen = true;\n        } else {\n            flex = $6818b1c4fc67028d$export$9078bad4c3934604(width);\n            if (flex <= 0) frozen = true;\n        }\n        var _column_minWidth, _ref2;\n        let min = $6818b1c4fc67028d$export$f556054ce4358701((_ref2 = (_column_minWidth = column.minWidth) !== null && _column_minWidth !== void 0 ? _column_minWidth : getDefaultMinWidth === null || getDefaultMinWidth === void 0 ? void 0 : getDefaultMinWidth(index)) !== null && _ref2 !== void 0 ? _ref2 : 0, availableWidth);\n        let max = $6818b1c4fc67028d$export$59185c62a7544aa0(column.maxWidth, availableWidth);\n        let hypotheticalMainSize = Math.max(min, Math.min(baseSize, max));\n        // 9.7.1\n        // We don't make use of flex basis, it's always 0, so we are always in 'grow' mode.\n        // 9.7.2\n        if (frozen) targetMainSize = hypotheticalMainSize;\n        else if (baseSize > hypotheticalMainSize) {\n            frozen = true;\n            targetMainSize = hypotheticalMainSize;\n        }\n        // 9.7.3\n        if (!frozen) hasNonFrozenItems = true;\n        return {\n            frozen: frozen,\n            baseSize: baseSize,\n            hypotheticalMainSize: hypotheticalMainSize,\n            min: min,\n            max: max,\n            flex: flex,\n            targetMainSize: targetMainSize,\n            violation: 0\n        };\n    });\n    // 9.7.4\n    // 9.7.4.a\n    while(hasNonFrozenItems){\n        // 9.7.4.b\n        /**\n     * Calculate the remaining free space as for initial free space,\n     * above (9.7.3). If the sum of the unfrozen flex itemsâ€™ flex factors is\n     * less than one, multiply the initial free space by this sum (of flex factors).\n     * If the magnitude of this value is less than the magnitude of\n     * the remaining free space, use this as the remaining free space.\n     */ let usedWidth = 0;\n        let flexFactors = 0;\n        flexItems.forEach((item)=>{\n            if (item.frozen) usedWidth += item.targetMainSize;\n            else {\n                usedWidth += item.baseSize;\n                flexFactors += item.flex;\n            }\n        });\n        let remainingFreeSpace = availableWidth - usedWidth;\n        // we only support integer FR's, and because of hasNonFrozenItems, we know that flexFactors > 0\n        // so no need to check for flexFactors < 1\n        // 9.7.4.c\n        /**\n     * If the remaining free space is zero\n     * - Do nothing.\n     * Else // remember, we're always in grow mode\n     * - Find the ratio of the itemâ€™s flex grow factor to the\n     * sum of the flex grow factors of all unfrozen items on\n     * the line. Set the itemâ€™s target main size to its flex\n     * base size plus a fraction of the remaining free space\n     * proportional to the ratio.\n     */ if (remainingFreeSpace > 0) flexItems.forEach((item)=>{\n            if (!item.frozen) {\n                let ratio = item.flex / flexFactors;\n                item.targetMainSize = item.baseSize + ratio * remainingFreeSpace;\n            }\n        });\n        // 9.7.4.d\n        /**\n     * Fix min/max violations. Clamp each non-frozen itemâ€™s\n     * target main size by its used min and max main sizes\n     * and floor its content-box size at zero. If the itemâ€™s\n     * target main size was made smaller by this, itâ€™s a max\n     * violation. If the itemâ€™s target main size was made\n     * larger by this, itâ€™s a min violation.\n     */ let totalViolation = 0;\n        flexItems.forEach((item)=>{\n            item.violation = 0;\n            if (!item.frozen) {\n                let { min: min, max: max, targetMainSize: targetMainSize } = item;\n                item.targetMainSize = Math.max(min, Math.min(targetMainSize, max));\n                item.violation = item.targetMainSize - targetMainSize;\n                totalViolation += item.violation;\n            }\n        });\n        // 9.7.4.e\n        /**\n     * Freeze over-flexed items. The total violation is the\n     * sum of the adjustments from the previous step\n     * âˆ‘(clamped size - unclamped size). If the total violation is:\n     * Zero\n     * - Freeze all items.\n     *\n     * Positive\n     * - Freeze all the items with min violations.\n     *\n     * Negative\n     * - Freeze all the items with max violations.\n     */ hasNonFrozenItems = false;\n        flexItems.forEach((item)=>{\n            if (totalViolation === 0 || Math.sign(totalViolation) === Math.sign(item.violation)) item.frozen = true;\n            else if (!item.frozen) hasNonFrozenItems = true;\n        });\n    }\n    return $6818b1c4fc67028d$var$cascadeRounding(flexItems);\n}\nfunction $6818b1c4fc67028d$var$cascadeRounding(flexItems) {\n    /*\n  Given an array of floats that sum to an integer, this rounds the floats\n  and returns an array of integers with the same sum.\n  */ let fpTotal = 0;\n    let intTotal = 0;\n    let roundedArray = [];\n    flexItems.forEach(function(item) {\n        let float = item.targetMainSize;\n        let integer = Math.round(float + fpTotal) - intTotal;\n        fpTotal += float;\n        intTotal += integer;\n        roundedArray.push(integer);\n    });\n    return roundedArray;\n}\nclass $a9e7ae544a4e41dd$export$7ff77a162970b30e {\n    /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */ splitColumnsIntoControlledAndUncontrolled(columns) {\n        return columns.reduce((acc, col)=>{\n            if (col.props.width != null) acc[0].set(col.key, col);\n            else acc[1].set(col.key, col);\n            return acc;\n        }, [\n            new Map(),\n            new Map()\n        ]);\n    }\n    /** Takes uncontrolled and controlled widths and joins them into a single Map. */ recombineColumns(columns, uncontrolledWidths, uncontrolledColumns, controlledColumns) {\n        return new Map(columns.map((col)=>{\n            if (uncontrolledColumns.has(col.key)) return [\n                col.key,\n                uncontrolledWidths.get(col.key)\n            ];\n            else return [\n                col.key,\n                controlledColumns.get(col.key).props.width\n            ];\n        }));\n    }\n    /** Used to make an initial Map of the uncontrolled widths based on default widths. */ getInitialUncontrolledWidths(uncontrolledColumns) {\n        return new Map(Array.from(uncontrolledColumns).map(([key, col])=>{\n            var _this_getDefaultWidth, _this;\n            var _col_props_defaultWidth, _ref;\n            return [\n                key,\n                (_ref = (_col_props_defaultWidth = col.props.defaultWidth) !== null && _col_props_defaultWidth !== void 0 ? _col_props_defaultWidth : (_this_getDefaultWidth = (_this = this).getDefaultWidth) === null || _this_getDefaultWidth === void 0 ? void 0 : _this_getDefaultWidth.call(_this, col)) !== null && _ref !== void 0 ? _ref : \"1fr\"\n            ];\n        }));\n    }\n    getColumnWidth(key) {\n        var _this_columnWidths_get;\n        return (_this_columnWidths_get = this.columnWidths.get(key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;\n    }\n    getColumnMinWidth(key) {\n        return this.columnMinWidths.get(key);\n    }\n    getColumnMaxWidth(key) {\n        return this.columnMaxWidths.get(key);\n    }\n    resizeColumnWidth(tableWidth, collection, controlledWidths, uncontrolledWidths, col = null, width) {\n        let prevColumnWidths = this.columnWidths;\n        // resizing a column\n        let resizeIndex = Infinity;\n        let resizingChanged = new Map([\n            ...controlledWidths,\n            ...uncontrolledWidths\n        ]);\n        let percentKeys = new Map();\n        let frKeysToTheRight = new Map();\n        let minWidths = new Map();\n        // freeze columns to the left to their previous pixel value\n        collection.columns.forEach((column, i)=>{\n            var _column_props_width_endsWith, _column_props_width;\n            let frKey;\n            let frValue;\n            minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));\n            if (col !== column.key && !column.props.width && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(uncontrolledWidths.get(column.key))) {\n                // uncontrolled don't have props.width for us, so instead get from our state\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(uncontrolledWidths.get(column.key));\n            } else if (col !== column.key && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(column.props.width) && !uncontrolledWidths.get(column.key)) {\n                // controlledWidths will be the same in the collection\n                frKey = column.key;\n                frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(column.props.width);\n            } else if (col !== column.key && ((_column_props_width = column.props.width) === null || _column_props_width === void 0 ? void 0 : (_column_props_width_endsWith = _column_props_width.endsWith) === null || _column_props_width_endsWith === void 0 ? void 0 : _column_props_width_endsWith.call(_column_props_width, \"%\"))) percentKeys.set(column.key, column.props.width);\n            // don't freeze columns to the right of the resizing one\n            if (resizeIndex < i) {\n                if (frKey) frKeysToTheRight.set(frKey, frValue);\n                return;\n            }\n            // we already know the new size of the resizing column\n            if (column.key === col) {\n                resizeIndex = i;\n                resizingChanged.set(column.key, Math.floor(width));\n                return;\n            }\n            // freeze column to previous value\n            resizingChanged.set(column.key, prevColumnWidths.get(column.key));\n        });\n        // predict pixels sizes for all columns based on resize\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), resizingChanged, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // set all new column widths for onResize event\n        // columns going in will be the same order as the columns coming out\n        let newWidths = new Map();\n        // set all column widths based on calculateColumnSize\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            newWidths.set(key, width);\n        });\n        // add FR's back as they were to columns to the right\n        Array.from(frKeysToTheRight).forEach(([key])=>{\n            newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);\n        });\n        // put back in percents\n        Array.from(percentKeys).forEach(([key, width])=>{\n            // resizing locks a column to a px width\n            if (key === col) return;\n            newWidths.set(key, width);\n        });\n        return newWidths;\n    }\n    buildColumnWidths(tableWidth, collection, widths) {\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        // initial layout or table/window resizing\n        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({\n                ...col.props,\n                key: col.key\n            })), widths, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));\n        // columns going in will be the same order as the columns coming out\n        columnWidths.forEach((width, index)=>{\n            let key = collection.columns[index].key;\n            let column = collection.columns[index];\n            this.columnWidths.set(key, width);\n            var _column_props_minWidth;\n            this.columnMinWidths.set(key, (0, $6818b1c4fc67028d$export$f556054ce4358701)((_column_props_minWidth = column.props.minWidth) !== null && _column_props_minWidth !== void 0 ? _column_props_minWidth : this.getDefaultMinWidth(column), tableWidth));\n            this.columnMaxWidths.set(key, (0, $6818b1c4fc67028d$export$59185c62a7544aa0)(column.props.maxWidth, tableWidth));\n        });\n        return this.columnWidths;\n    }\n    constructor(options){\n        this.columnWidths = new Map();\n        this.columnMinWidths = new Map();\n        this.columnMaxWidths = new Map();\n        var _options_getDefaultWidth;\n        this.getDefaultWidth = (_options_getDefaultWidth = options === null || options === void 0 ? void 0 : options.getDefaultWidth) !== null && _options_getDefaultWidth !== void 0 ? _options_getDefaultWidth : ()=>\"1fr\";\n        var _options_getDefaultMinWidth;\n        this.getDefaultMinWidth = (_options_getDefaultMinWidth = options === null || options === void 0 ? void 0 : options.getDefaultMinWidth) !== null && _options_getDefaultMinWidth !== void 0 ? _options_getDefaultMinWidth : ()=>75;\n    }\n}\nfunction $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {\n    let { getDefaultWidth: getDefaultWidth, getDefaultMinWidth: getDefaultMinWidth, tableWidth: tableWidth = 0 } = props;\n    let [resizingColumn, setResizingColumn] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    let columnLayout = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $a9e7ae544a4e41dd$export$7ff77a162970b30e)({\n            getDefaultWidth: getDefaultWidth,\n            getDefaultMinWidth: getDefaultMinWidth\n        }), [\n        getDefaultWidth,\n        getDefaultMinWidth\n    ]);\n    let [controlledColumns, uncontrolledColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns), [\n        state.collection.columns,\n        columnLayout\n    ]);\n    // uncontrolled column widths\n    let [uncontrolledWidths, setUncontrolledWidths] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>columnLayout.getInitialUncontrolledWidths(uncontrolledColumns));\n    // Update uncontrolled widths if the columns changed.\n    let [lastColumns, setLastColumns] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(state.collection.columns);\n    if (state.collection.columns !== lastColumns) {\n        if (state.collection.columns.length !== lastColumns.length || state.collection.columns.some((c, i)=>c.key !== lastColumns[i].key)) {\n            let newUncontrolledWidths = columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);\n            setUncontrolledWidths(newUncontrolledWidths);\n        }\n        setLastColumns(state.collection.columns);\n    }\n    // combine columns back into one map that maintains same order as the columns\n    let colWidths = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns), [\n        state.collection.columns,\n        uncontrolledWidths,\n        uncontrolledColumns,\n        controlledColumns,\n        columnLayout\n    ]);\n    let startResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key)=>{\n        setResizingColumn(key);\n    }, [\n        setResizingColumn\n    ]);\n    let updateResizedColumns = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key, width)=>{\n        let newControlled = new Map(Array.from(controlledColumns).map(([key, entry])=>[\n                key,\n                entry.props.width\n            ]));\n        let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);\n        let map = new Map(Array.from(uncontrolledColumns).map(([key])=>[\n                key,\n                newSizes.get(key)\n            ]));\n        map.set(key, width);\n        setUncontrolledWidths(map);\n        return newSizes;\n    }, [\n        controlledColumns,\n        uncontrolledColumns,\n        setUncontrolledWidths,\n        tableWidth,\n        columnLayout,\n        state.collection,\n        uncontrolledWidths\n    ]);\n    let endResize = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setResizingColumn(null);\n    }, [\n        setResizingColumn\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths), [\n        tableWidth,\n        state.collection,\n        colWidths,\n        columnLayout\n    ]);\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            resizingColumn: resizingColumn,\n            updateResizedColumns: updateResizedColumns,\n            startResize: startResize,\n            endResize: endResize,\n            getColumnWidth: (key)=>columnLayout.getColumnWidth(key),\n            getColumnMinWidth: (key)=>columnLayout.getColumnMinWidth(key),\n            getColumnMaxWidth: (key)=>columnLayout.getColumnMaxWidth(key),\n            tableState: state\n        }), [\n        columnLayout,\n        resizingColumn,\n        updateResizedColumns,\n        startResize,\n        endResize,\n        state\n    ]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = \"row-header-column-\" + Math.random().toString(36).slice(2);\nlet $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nwhile($788781baa30117fa$var$ROW_HEADER_COLUMN_KEY === $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG)$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = \"row-header-column-\" + Math.random().toString(36).slice(2);\nfunction $788781baa30117fa$export$7c127db850d4e81e(keyMap, columnNodes) {\n    if (columnNodes.length === 0) return [];\n    let columns = [];\n    let seen = new Map();\n    for (let column of columnNodes){\n        let parentKey = column.parentKey;\n        let col = [\n            column\n        ];\n        while(parentKey){\n            let parent = keyMap.get(parentKey);\n            if (!parent) break;\n            // If we've already seen this parent, than it is shared\n            // with a previous column. If the current column is taller\n            // than the previous column, than we need to shift the parent\n            // in the previous column so it's level with the current column.\n            if (seen.has(parent)) {\n                parent.colspan++;\n                let { column: column, index: index } = seen.get(parent);\n                if (index > col.length) break;\n                for(let i = index; i < col.length; i++)column.splice(i, 0, null);\n                // Adjust shifted indices\n                for(let i = col.length; i < column.length; i++)if (column[i] && seen.has(column[i])) seen.get(column[i]).index = i;\n            } else {\n                parent.colspan = 1;\n                col.push(parent);\n                seen.set(parent, {\n                    column: col,\n                    index: col.length - 1\n                });\n            }\n            parentKey = parent.parentKey;\n        }\n        columns.push(col);\n        column.index = columns.length - 1;\n    }\n    let maxLength = Math.max(...columns.map((c)=>c.length));\n    let headerRows = Array(maxLength).fill(0).map(()=>[]);\n    // Convert columns into rows.\n    let colIndex = 0;\n    for (let column of columns){\n        let i = maxLength - 1;\n        for (let item of column){\n            if (item) {\n                // Fill the space up until the current column with a placeholder\n                let row = headerRows[i];\n                let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n                if (rowLength < colIndex) {\n                    let placeholder = {\n                        type: \"placeholder\",\n                        key: \"placeholder-\" + item.key,\n                        colspan: colIndex - rowLength,\n                        index: rowLength,\n                        value: null,\n                        rendered: null,\n                        level: i,\n                        hasChildNodes: false,\n                        childNodes: [],\n                        textValue: null\n                    };\n                    // eslint-disable-next-line max-depth\n                    if (row.length > 0) {\n                        row[row.length - 1].nextKey = placeholder.key;\n                        placeholder.prevKey = row[row.length - 1].key;\n                    }\n                    row.push(placeholder);\n                }\n                if (row.length > 0) {\n                    row[row.length - 1].nextKey = item.key;\n                    item.prevKey = row[row.length - 1].key;\n                }\n                item.level = i;\n                item.colIndex = colIndex;\n                row.push(item);\n            }\n            i--;\n        }\n        colIndex++;\n    }\n    // Add placeholders at the end of each row that is shorter than the maximum\n    let i = 0;\n    for (let row of headerRows){\n        let rowLength = row.reduce((p, c)=>p + c.colspan, 0);\n        if (rowLength < columnNodes.length) {\n            let placeholder = {\n                type: \"placeholder\",\n                key: \"placeholder-\" + row[row.length - 1].key,\n                colspan: columnNodes.length - rowLength,\n                index: rowLength,\n                value: null,\n                rendered: null,\n                level: i,\n                hasChildNodes: false,\n                childNodes: [],\n                textValue: null,\n                prevKey: row[row.length - 1].key\n            };\n            row.push(placeholder);\n        }\n        i++;\n    }\n    return headerRows.map((childNodes, index)=>{\n        let row = {\n            type: \"headerrow\",\n            key: \"headerrow-\" + index,\n            index: index,\n            value: null,\n            rendered: null,\n            level: 0,\n            hasChildNodes: true,\n            childNodes: childNodes,\n            textValue: null\n        };\n        return row;\n    });\n}\nclass $788781baa30117fa$export$596e1b2e2cf93690 extends (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.GridCollection) {\n    *[Symbol.iterator]() {\n        yield* this.body.childNodes;\n    }\n    get size() {\n        return this._size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        var _getFirstItem;\n        return (_getFirstItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getFirstItem)(this.body.childNodes)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;\n    }\n    getLastKey() {\n        var _getLastItem;\n        return (_getLastItem = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.getLastItem)(this.body.childNodes)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getTextValue(key) {\n        let row = this.getItem(key);\n        if (!row) return \"\";\n        // If the row has a textValue, use that.\n        if (row.textValue) return row.textValue;\n        // Otherwise combine the text of each of the row header columns.\n        let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n        if (rowHeaderColumnKeys) {\n            let text = [];\n            for (let cell of row.childNodes){\n                let column = this.columns[cell.index];\n                if (rowHeaderColumnKeys.has(column.key) && cell.textValue) text.push(cell.textValue);\n                if (text.length === rowHeaderColumnKeys.size) break;\n            }\n            return text.join(\" \");\n        }\n        return \"\";\n    }\n    constructor(nodes, prev, opts){\n        let rowHeaderColumnKeys = new Set();\n        let body;\n        let columns = [];\n        // Add cell for selection checkboxes if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) ? 1 : 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        // Add cell for drag buttons if needed.\n        if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) {\n            let rowHeaderColumn = {\n                type: \"column\",\n                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG,\n                value: null,\n                textValue: \"\",\n                level: 0,\n                index: 0,\n                hasChildNodes: false,\n                rendered: null,\n                childNodes: [],\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            columns.unshift(rowHeaderColumn);\n        }\n        let rows = [];\n        let columnKeyMap = new Map();\n        let visit = (node)=>{\n            switch(node.type){\n                case \"body\":\n                    body = node;\n                    break;\n                case \"column\":\n                    columnKeyMap.set(node.key, node);\n                    if (!node.hasChildNodes) {\n                        columns.push(node);\n                        if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n                    }\n                    break;\n                case \"item\":\n                    rows.push(node);\n                    return; // do not go into childNodes\n            }\n            for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let headerRows = $788781baa30117fa$export$7c127db850d4e81e(columnKeyMap, columns);\n        headerRows.forEach((row, i)=>rows.splice(i, 0, row));\n        super({\n            columnCount: columns.length,\n            items: rows,\n            visitNode: (node)=>{\n                node.column = columns[node.index];\n                return node;\n            }\n        });\n        this._size = 0;\n        this.columns = columns;\n        this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n        this.body = body;\n        this.headerRows = headerRows;\n        this._size = [\n            ...body.childNodes\n        ].length;\n        // Default row header column to the first one.\n        if (this.rowHeaderColumnKeys.size === 0) {\n            if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n                if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) this.rowHeaderColumnKeys.add(this.columns[2].key);\n                else this.rowHeaderColumnKeys.add(this.columns[1].key);\n            } else this.rowHeaderColumnKeys.add(this.columns[0].key);\n        }\n    }\n}\nconst $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {\n    ascending: \"descending\",\n    descending: \"ascending\"\n};\nfunction $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {\n    let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons } = props;\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        props.children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let collection = (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.useCollection)(props, (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nodes)=>new (0, $788781baa30117fa$export$596e1b2e2cf93690)(nodes, null, context), [\n        context\n    ]), context);\n    let { disabledKeys: disabledKeys, selectionManager: selectionManager } = (0, _react_stately_grid__WEBPACK_IMPORTED_MODULE_1__.useGridState)({\n        ...props,\n        collection: collection,\n        disabledBehavior: props.disabledBehavior || \"selection\"\n    });\n    return {\n        collection: collection,\n        disabledKeys: disabledKeys,\n        selectionManager: selectionManager,\n        showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n        sortDescriptor: props.sortDescriptor,\n        isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n        setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,\n        sort (columnKey, direction) {\n            var _props_sortDescriptor;\n            props.onSortChange({\n                column: columnKey,\n                direction: direction !== null && direction !== void 0 ? direction : ((_props_sortDescriptor = props.sortDescriptor) === null || _props_sortDescriptor === void 0 ? void 0 : _props_sortDescriptor.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : \"ascending\"\n            });\n        }\n    };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $312ae3b56a94a86e$var$TableHeader(props) {\n    return null;\n}\n$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, columns: columns } = props;\n    // Clear columns so they aren't double added in strict mode.\n    context.columns = [];\n    if (typeof children === \"function\") {\n        if (!columns) throw new Error(\"props.children was a function but props.columns is missing\");\n        for (let column of columns)yield {\n            type: \"column\",\n            value: column,\n            renderer: children\n        };\n    } else {\n        let columns = [];\n        (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (column)=>{\n            columns.push({\n                type: \"column\",\n                element: column\n            });\n        });\n        yield* columns;\n    }\n};\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $4ae5314bf50db1a3$var$TableBody(props) {\n    return null;\n}\n$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children, items: items } = props;\n    yield {\n        type: \"body\",\n        hasChildNodes: true,\n        props: props,\n        *childNodes () {\n            if (typeof children === \"function\") {\n                if (!items) throw new Error(\"props.children was a function but props.items is missing\");\n                for (let item of items)yield {\n                    type: \"item\",\n                    value: item,\n                    renderer: children\n                };\n            } else {\n                let items = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (item)=>{\n                    items.push({\n                        type: \"item\",\n                        element: item\n                    });\n                });\n                yield* items;\n            }\n        }\n    };\n};\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $1cd244557c2f97d5$var$Column(props) {\n    return null;\n}\n$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode(props, context) {\n    let { title: title, children: children, childColumns: childColumns } = props;\n    let rendered = title || children;\n    let textValue = props.textValue || (typeof rendered === \"string\" ? rendered : \"\") || props[\"aria-label\"];\n    let fullNodes = yield {\n        type: \"column\",\n        hasChildNodes: !!childColumns || title && (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.count(children) > 0,\n        rendered: rendered,\n        textValue: textValue,\n        props: props,\n        *childNodes () {\n            if (childColumns) for (let child of childColumns)yield {\n                type: \"column\",\n                value: child\n            };\n            else if (title) {\n                let childColumns = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (child)=>{\n                    childColumns.push({\n                        type: \"column\",\n                        element: child\n                    });\n                });\n                yield* childColumns;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // This is a bit of a hack, but it works.\n            // If this method is called, then there's a cached version of this node available.\n            // But, we need to keep the list of columns in the new context up to date.\n            updateContext(newContext);\n            return false;\n        }\n    };\n    let updateContext = (context)=>{\n        // register leaf columns on the context so that <Row> can access them\n        for (let node of fullNodes)if (!node.hasChildNodes) context.columns.push(node);\n    };\n    updateContext(context);\n};\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $70d70eb16ea48428$var$Row(props) {\n    return null;\n}\n$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode(props, context) {\n    let { children: children, textValue: textValue, UNSTABLE_childItems: UNSTABLE_childItems } = props;\n    yield {\n        type: \"item\",\n        props: props,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: true,\n        *childNodes () {\n            // Process cells first\n            if (context.showDragButtons) yield {\n                type: \"cell\",\n                key: \"header-drag\",\n                props: {\n                    isDragButtonCell: true\n                }\n            };\n            if (context.showSelectionCheckboxes && context.selectionMode !== \"none\") yield {\n                type: \"cell\",\n                key: \"header\",\n                props: {\n                    isSelectionCell: true\n                }\n            };\n            if (typeof children === \"function\") {\n                for (let column of context.columns)yield {\n                    type: \"cell\",\n                    element: children(column.key),\n                    key: column.key // this is combined with the row key by CollectionBuilder\n                };\n                if (UNSTABLE_childItems) for (let child of UNSTABLE_childItems)// the parent renderer and use that to build the full node of this child row, using the value provided here to generate the cells\n                yield {\n                    type: \"item\",\n                    value: child\n                };\n            } else {\n                let cells = [];\n                let childRows = [];\n                (0, react__WEBPACK_IMPORTED_MODULE_0__).Children.forEach(children, (node)=>{\n                    if (node.type === $70d70eb16ea48428$var$Row) {\n                        if (cells.length < context.columns.length) throw new Error(\"All of a Row's child Cells must be positioned before any child Rows.\");\n                        childRows.push({\n                            type: \"item\",\n                            element: node\n                        });\n                    } else cells.push({\n                        type: \"cell\",\n                        element: node\n                    });\n                });\n                if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);\n                yield* cells;\n                yield* childRows;\n            }\n        },\n        shouldInvalidate (newContext) {\n            // Invalidate all rows if the columns changed.\n            return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i)=>c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.showDragButtons !== context.showDragButtons || newContext.selectionMode !== context.selectionMode;\n        }\n    };\n};\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $941d1d9a6a28982a$var$Cell(props) {\n    return null;\n}\n$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode(props) {\n    let { children: children } = props;\n    let textValue = props.textValue || (typeof children === \"string\" ? children : \"\") || props[\"aria-label\"] || \"\";\n    yield {\n        type: \"cell\",\n        props: props,\n        rendered: children,\n        textValue: textValue,\n        \"aria-label\": props[\"aria-label\"],\n        hasChildNodes: false\n    };\n};\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */ // We don't want getCollectionNode to show up in the type definition\nlet $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $ee65a0057fd99531$export$34dfa8a1622185a4(props) {\n    let { selectionMode: selectionMode = \"none\", showSelectionCheckboxes: showSelectionCheckboxes, showDragButtons: showDragButtons, UNSTABLE_expandedKeys: propExpandedKeys, UNSTABLE_defaultExpandedKeys: propDefaultExpandedKeys, UNSTABLE_onExpandedChange: UNSTABLE_onExpandedChange, children: children } = props;\n    if (!(0, _react_stately_flags__WEBPACK_IMPORTED_MODULE_3__.tableNestedRows)()) throw new Error(\"Feature flag for table nested rows must be enabled to use useTreeGridState.\");\n    let [expandedKeys, setExpandedKeys] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_4__.useControlledState)(propExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propExpandedKeys) : undefined, propDefaultExpandedKeys ? $ee65a0057fd99531$var$convertExpanded(propDefaultExpandedKeys) : new Set(), UNSTABLE_onExpandedChange);\n    let context = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== \"none\",\n            showDragButtons: showDragButtons,\n            selectionMode: selectionMode,\n            columns: []\n        }), [\n        children,\n        showSelectionCheckboxes,\n        selectionMode,\n        showDragButtons\n    ]);\n    let builder = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, _react_stately_collections__WEBPACK_IMPORTED_MODULE_2__.CollectionBuilder)(), []);\n    let nodes = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>builder.build({\n            children: children\n        }, context), [\n        builder,\n        children,\n        context\n    ]);\n    let treeGridCollection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return $ee65a0057fd99531$var$generateTreeGridCollection(nodes, {\n            showSelectionCheckboxes: showSelectionCheckboxes,\n            showDragButtons: showDragButtons,\n            expandedKeys: expandedKeys\n        });\n    }, [\n        nodes,\n        showSelectionCheckboxes,\n        showDragButtons,\n        expandedKeys\n    ]);\n    let onToggle = (key)=>{\n        setExpandedKeys($ee65a0057fd99531$var$toggleKey(expandedKeys, key, treeGridCollection));\n    };\n    let collection = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return new (0, $788781baa30117fa$export$596e1b2e2cf93690)(treeGridCollection.tableNodes, null, context);\n    }, [\n        context,\n        treeGridCollection.tableNodes\n    ]);\n    let tableState = (0, $4a0dd036d492cee4$export$907bcc6c48325fd6)({\n        ...props,\n        collection: collection\n    });\n    return {\n        ...tableState,\n        keyMap: treeGridCollection.keyMap,\n        userColumnCount: treeGridCollection.userColumnCount,\n        expandedKeys: expandedKeys,\n        toggleKey: onToggle\n    };\n}\nfunction $ee65a0057fd99531$var$toggleKey(currentExpandedKeys, key, collection) {\n    let updatedExpandedKeys;\n    if (currentExpandedKeys === \"all\") {\n        updatedExpandedKeys = new Set(collection.flattenedRows.filter((row)=>row.props.UNSTABLE_childItems || row.props.children.length > collection.userColumnCount).map((row)=>row.key));\n        updatedExpandedKeys.delete(key);\n    } else {\n        updatedExpandedKeys = new Set(currentExpandedKeys);\n        if (updatedExpandedKeys.has(key)) updatedExpandedKeys.delete(key);\n        else updatedExpandedKeys.add(key);\n    }\n    return updatedExpandedKeys;\n}\nfunction $ee65a0057fd99531$var$convertExpanded(expanded) {\n    if (!expanded) return new Set();\n    return expanded === \"all\" ? \"all\" : new Set(expanded);\n}\nfunction $ee65a0057fd99531$var$generateTreeGridCollection(nodes, opts) {\n    let { expandedKeys: expandedKeys = new Set() } = opts;\n    let body;\n    let flattenedRows = [];\n    let columnCount = 0;\n    let userColumnCount = 0;\n    let originalColumns = [];\n    let keyMap = new Map();\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) columnCount++;\n    if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) columnCount++;\n    let topLevelRows = [];\n    let visit = (node)=>{\n        switch(node.type){\n            case \"body\":\n                body = node;\n                keyMap.set(body.key, body);\n                break;\n            case \"column\":\n                if (!node.hasChildNodes) userColumnCount++;\n                break;\n            case \"item\":\n                topLevelRows.push(node);\n                return;\n        }\n        for (let child of node.childNodes)visit(child);\n    };\n    for (let node of nodes){\n        if (node.type === \"column\") originalColumns.push(node);\n        visit(node);\n    }\n    columnCount += userColumnCount;\n    // Update each grid node in the treegrid table with values specific to a treegrid structure. Also store a set of flattened row nodes for TableCollection to consume\n    let globalRowCount = 0;\n    let visitNode = (node, i)=>{\n        // Clone row node and its children so modifications to the node for treegrid specific values aren't applied on the nodes provided\n        // to TableCollection. Index, level, and parent keys are all changed to reflect a flattened row structure rather than the treegrid structure\n        // values automatically calculated via CollectionBuilder\n        if (node.type === \"item\") {\n            let childNodes = [];\n            for (let child of node.childNodes)if (child.type === \"cell\") {\n                let cellClone = {\n                    ...child\n                };\n                if (cellClone.index + 1 === columnCount) cellClone.nextKey = null;\n                childNodes.push({\n                    ...cellClone\n                });\n            }\n            let clone = {\n                ...node,\n                childNodes: childNodes,\n                parentKey: body.key,\n                level: 1,\n                index: globalRowCount++\n            };\n            flattenedRows.push(clone);\n        }\n        let newProps = {};\n        // Assign indexOfType to cells and rows for aria-posinset\n        if (node.type !== \"placeholder\" && node.type !== \"column\") newProps[\"indexOfType\"] = i;\n        // Use Object.assign instead of spread to preserve object reference for keyMap. Also ensures retrieving nodes\n        // via .childNodes returns the same object as the one found via keyMap look up\n        Object.assign(node, newProps);\n        keyMap.set(node.key, node);\n        let lastNode;\n        let rowIndex = 0;\n        for (let child of node.childNodes)if (!(child.type === \"item\" && expandedKeys !== \"all\" && !expandedKeys.has(node.key))) {\n            if (child.parentKey == null) child.parentKey = node.key;\n            if (lastNode) {\n                lastNode.nextKey = child.key;\n                child.prevKey = lastNode.key;\n            } else child.prevKey = null;\n            if (child.type === \"item\") visitNode(child, rowIndex++);\n            else visitNode(child, child.index);\n            lastNode = child;\n        }\n        if (lastNode) lastNode.nextKey = null;\n    };\n    let last;\n    topLevelRows.forEach((node, i)=>{\n        visitNode(node, i);\n        if (last) {\n            last.nextKey = node.key;\n            node.prevKey = last.key;\n        } else node.prevKey = null;\n        last = node;\n    });\n    if (last) last.nextKey = null;\n    return {\n        keyMap: keyMap,\n        userColumnCount: userColumnCount,\n        flattenedRows: flattenedRows,\n        tableNodes: [\n            ...originalColumns,\n            {\n                ...body,\n                childNodes: flattenedRows\n            }\n        ]\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdGFibGUvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdQO0FBQzFIO0FBQ2I7QUFDbEM7QUFDTTtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHOzs7Ozs7Ozs7O0NBVUgsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQUcsU0FBU3lCLDBDQUEwQ0MsS0FBSztJQUN4RCxPQUFPQSxTQUFTLFFBQVMsRUFBQ0MsTUFBTUQsVUFBVUUsT0FBT0YsT0FBT0csS0FBSyxDQUFDLG9CQUFvQixJQUFHO0FBQ3pGO0FBQ0EsU0FBU0MsMENBQTBDSixLQUFLO0lBQ3BELElBQUksQ0FBQ0EsT0FBTyxPQUFPO0lBQ25CLElBQUlHLFFBQVFILE1BQU1HLEtBQUssQ0FBQztJQUN4Qiw2REFBNkQ7SUFDN0QsSUFBSSxDQUFDQSxPQUFPO1FBQ1JFLFFBQVFDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRU4sTUFBTSw2R0FBNkcsQ0FBQyxFQUFFO1FBQzdJLE9BQU87SUFDWDtJQUNBLE9BQU9PLFdBQVdKLEtBQUssQ0FBQyxFQUFFO0FBQzlCO0FBQ0EsU0FBU0ssMENBQTBDUixLQUFLLEVBQUVTLFVBQVU7SUFDaEUsSUFBSSxPQUFPVCxVQUFVLFVBQVU7UUFDM0IsSUFBSUcsUUFBUUgsTUFBTUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQ0EsT0FBTyxNQUFNLElBQUlPLE1BQU07UUFDNUIsT0FBT0QsYUFBY0YsQ0FBQUEsV0FBV0osS0FBSyxDQUFDLEVBQUUsSUFBSSxHQUFFO0lBQ2xEO0lBQ0EsT0FBT0g7QUFDWDtBQUNBLFNBQVNXLDBDQUEwQ0MsUUFBUSxFQUFFSCxVQUFVO0lBQ25FLE9BQU9HLFlBQVksT0FBT0osMENBQTBDSSxVQUFVSCxjQUFjSSxPQUFPQyxnQkFBZ0I7QUFDdkg7QUFDQSxTQUFTQywwQ0FBMENDLFFBQVEsRUFBRVAsVUFBVTtJ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Q2hCO1NBQ0g7SUFDTDtBQUNKO0FBSzRzQixDQUM1c0Isa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemV1cy1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS90YWJsZS9kaXN0L2ltcG9ydC5tanM/NmNkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1NlY3Rpb24gYXMgJDY1NTUxMDRmZjA4NWJlZjQkcmVfZXhwb3J0JFNlY3Rpb24sIHVzZUNvbGxlY3Rpb24gYXMgJDFCZmpXJHVzZUNvbGxlY3Rpb24sIGdldEZpcnN0SXRlbSBhcyAkMUJmalckZ2V0Rmlyc3RJdGVtLCBnZXRMYXN0SXRlbSBhcyAkMUJmalckZ2V0TGFzdEl0ZW0sIENvbGxlY3Rpb25CdWlsZGVyIGFzICQxQmZqVyRDb2xsZWN0aW9uQnVpbGRlcn0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI7XG5pbXBvcnQgJDFCZmpXJHJlYWN0LCB7dXNlU3RhdGUgYXMgJDFCZmpXJHVzZVN0YXRlLCB1c2VNZW1vIGFzICQxQmZqVyR1c2VNZW1vLCB1c2VDYWxsYmFjayBhcyAkMUJmalckdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHt1c2VHcmlkU3RhdGUgYXMgJDFCZmpXJHVzZUdyaWRTdGF0ZSwgR3JpZENvbGxlY3Rpb24gYXMgJDFCZmpXJEdyaWRDb2xsZWN0aW9ufSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvZ3JpZFwiO1xuaW1wb3J0IHt0YWJsZU5lc3RlZFJvd3MgYXMgJDFCZmpXJHRhYmxlTmVzdGVkUm93c30gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2ZsYWdzXCI7XG5pbXBvcnQge3VzZUNvbnRyb2xsZWRTdGF0ZSBhcyAkMUJmalckdXNlQ29udHJvbGxlZFN0YXRlfSBmcm9tIFwiQHJlYWN0LXN0YXRlbHkvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMiBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjIgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQxOTk0YTA3N2I5OGVlMGQ1KHdpZHRoKSB7XG4gICAgcmV0dXJuIHdpZHRoICE9IG51bGwgJiYgKCFpc05hTih3aWR0aCkgfHwgU3RyaW5nKHdpZHRoKS5tYXRjaCgvXihcXGQrKSg/PSUkKS8pICE9PSBudWxsKTtcbn1cbmZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0KHdpZHRoKSB7XG4gICAgaWYgKCF3aWR0aCkgcmV0dXJuIDE7XG4gICAgbGV0IG1hdGNoID0gd2lkdGgubWF0Y2goL14oLispKD89ZnIkKS8pO1xuICAgIC8vIGlmIHdpZHRoIGlzIHRoZSBpbmNvcnJlY3QgZm9ybWF0LCBqdXN0IGRlZmF1bHQgaXQgdG8gYSAxZnJcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgd2lkdGg6ICR7d2lkdGh9IGlzIG5vdCBhIHN1cHBvcnRlZCBmb3JtYXQsIHdpZHRoIHNob3VsZCBiZSBhIG51bWJlciAoZXguIDE1MCksIHBlcmNlbnRhZ2UgKGV4LiAnNTAlJykgb3IgZnIgdW5pdCAoZXguICcyZnInKWAsIFwiZGVmYXVsdGluZyB0byAnMWZyJ1wiKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoWzBdKTtcbn1cbmZ1bmN0aW9uICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ3YmJhZDI3ODk2ZjdhZTlmKHdpZHRoLCB0YWJsZVdpZHRoKSB7XG4gICAgaWYgKHR5cGVvZiB3aWR0aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsZXQgbWF0Y2ggPSB3aWR0aC5tYXRjaCgvXihcXGQrKSg/PSUkKS8pO1xuICAgICAgICBpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHBlcmNlbnRhZ2VzIG9yIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBmb3Igc3RhdGljIGNvbHVtbiB3aWR0aHNcIik7XG4gICAgICAgIHJldHVybiB0YWJsZVdpZHRoICogKHBhcnNlRmxvYXQobWF0Y2hbMF0pIC8gMTAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDU5MTg1YzYyYTc1NDRhYTAobWF4V2lkdGgsIHRhYmxlV2lkdGgpIHtcbiAgICByZXR1cm4gbWF4V2lkdGggIT0gbnVsbCA/ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ3YmJhZDI3ODk2ZjdhZTlmKG1heFdpZHRoLCB0YWJsZVdpZHRoKSA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JGY1NTYwNTRjZTQzNTg3MDEobWluV2lkdGgsIHRhYmxlV2lkdGgpIHtcbiAgICByZXR1cm4gbWluV2lkdGggIT0gbnVsbCA/ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ3YmJhZDI3ODk2ZjdhZTlmKG1pbldpZHRoLCB0YWJsZVdpZHRoKSA6IDA7XG59XG5mdW5jdGlvbiAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTVkNTBkYzY4NzM4NTQ5MShhdmFpbGFibGVXaWR0aCwgY29sdW1ucywgY2hhbmdlZENvbHVtbnMsIGdldERlZmF1bHRXaWR0aCwgZ2V0RGVmYXVsdE1pbldpZHRoKSB7XG4gICAgbGV0IGhhc05vbkZyb3plbkl0ZW1zID0gZmFsc2U7XG4gICAgbGV0IGZsZXhJdGVtcyA9IGNvbHVtbnMubWFwKChjb2x1bW4sIGluZGV4KT0+e1xuICAgICAgICB2YXIgX2NvbHVtbl93aWR0aCwgX3JlZiwgX3JlZjE7XG4gICAgICAgIGxldCB3aWR0aCA9IGNoYW5nZWRDb2x1bW5zLmdldChjb2x1bW4ua2V5KSAhPSBudWxsID8gY2hhbmdlZENvbHVtbnMuZ2V0KGNvbHVtbi5rZXkpIDogKF9yZWYxID0gKF9yZWYgPSAoX2NvbHVtbl93aWR0aCA9IGNvbHVtbi53aWR0aCkgIT09IG51bGwgJiYgX2NvbHVtbl93aWR0aCAhPT0gdm9pZCAwID8gX2NvbHVtbl93aWR0aCA6IGNvbHVtbi5kZWZhdWx0V2lkdGgpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBnZXREZWZhdWx0V2lkdGggPT09IG51bGwgfHwgZ2V0RGVmYXVsdFdpZHRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXREZWZhdWx0V2lkdGgoaW5kZXgpKSAhPT0gbnVsbCAmJiBfcmVmMSAhPT0gdm9pZCAwID8gX3JlZjEgOiBcIjFmclwiO1xuICAgICAgICBsZXQgZnJvemVuID0gZmFsc2U7XG4gICAgICAgIGxldCBiYXNlU2l6ZSA9IDA7XG4gICAgICAgIGxldCBmbGV4ID0gMDtcbiAgICAgICAgbGV0IHRhcmdldE1haW5TaXplID0gbnVsbDtcbiAgICAgICAgaWYgKCQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQxOTk0YTA3N2I5OGVlMGQ1KHdpZHRoKSkge1xuICAgICAgICAgICAgYmFzZVNpemUgPSAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkN2JiYWQyNzg5NmY3YWU5Zih3aWR0aCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICAgICAgZnJvemVuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsZXggPSAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkOTA3OGJhZDRjMzkzNDYwNCh3aWR0aCk7XG4gICAgICAgICAgICBpZiAoZmxleCA8PSAwKSBmcm96ZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfY29sdW1uX21pbldpZHRoLCBfcmVmMjtcbiAgICAgICAgbGV0IG1pbiA9ICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCRmNTU2MDU0Y2U0MzU4NzAxKChfcmVmMiA9IChfY29sdW1uX21pbldpZHRoID0gY29sdW1uLm1pbldpZHRoKSAhPT0gbnVsbCAmJiBfY29sdW1uX21pbldpZHRoICE9PSB2b2lkIDAgPyBfY29sdW1uX21pbldpZHRoIDogZ2V0RGVmYXVsdE1pbldpZHRoID09PSBudWxsIHx8IGdldERlZmF1bHRNaW5XaWR0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0RGVmYXVsdE1pbldpZHRoKGluZGV4KSkgIT09IG51bGwgJiYgX3JlZjIgIT09IHZvaWQgMCA/IF9yZWYyIDogMCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBsZXQgbWF4ID0gJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDU5MTg1YzYyYTc1NDRhYTAoY29sdW1uLm1heFdpZHRoLCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgIGxldCBoeXBvdGhldGljYWxNYWluU2l6ZSA9IE1hdGgubWF4KG1pbiwgTWF0aC5taW4oYmFzZVNpemUsIG1heCkpO1xuICAgICAgICAvLyA5LjcuMVxuICAgICAgICAvLyBXZSBkb24ndCBtYWtlIHVzZSBvZiBmbGV4IGJhc2lzLCBpdCdzIGFsd2F5cyAwLCBzbyB3ZSBhcmUgYWx3YXlzIGluICdncm93JyBtb2RlLlxuICAgICAgICAvLyA5LjcuMlxuICAgICAgICBpZiAoZnJvemVuKSB0YXJnZXRNYWluU2l6ZSA9IGh5cG90aGV0aWNhbE1haW5TaXplO1xuICAgICAgICBlbHNlIGlmIChiYXNlU2l6ZSA+IGh5cG90aGV0aWNhbE1haW5TaXplKSB7XG4gICAgICAgICAgICBmcm96ZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGFyZ2V0TWFpblNpemUgPSBoeXBvdGhldGljYWxNYWluU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyA5LjcuM1xuICAgICAgICBpZiAoIWZyb3plbikgaGFzTm9uRnJvemVuSXRlbXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvemVuOiBmcm96ZW4sXG4gICAgICAgICAgICBiYXNlU2l6ZTogYmFzZVNpemUsXG4gICAgICAgICAgICBoeXBvdGhldGljYWxNYWluU2l6ZTogaHlwb3RoZXRpY2FsTWFpblNpemUsXG4gICAgICAgICAgICBtaW46IG1pbixcbiAgICAgICAgICAgIG1heDogbWF4LFxuICAgICAgICAgICAgZmxleDogZmxleCxcbiAgICAgICAgICAgIHRhcmdldE1haW5TaXplOiB0YXJnZXRNYWluU2l6ZSxcbiAgICAgICAgICAgIHZpb2xhdGlvbjogMFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8vIDkuNy40XG4gICAgLy8gOS43LjQuYVxuICAgIHdoaWxlKGhhc05vbkZyb3plbkl0ZW1zKXtcbiAgICAgICAgLy8gOS43LjQuYlxuICAgICAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHJlbWFpbmluZyBmcmVlIHNwYWNlIGFzIGZvciBpbml0aWFsIGZyZWUgc3BhY2UsXG4gICAgICogYWJvdmUgKDkuNy4zKS4gSWYgdGhlIHN1bSBvZiB0aGUgdW5mcm96ZW4gZmxleCBpdGVtc+KAmSBmbGV4IGZhY3RvcnMgaXNcbiAgICAgKiBsZXNzIHRoYW4gb25lLCBtdWx0aXBseSB0aGUgaW5pdGlhbCBmcmVlIHNwYWNlIGJ5IHRoaXMgc3VtIChvZiBmbGV4IGZhY3RvcnMpLlxuICAgICAqIElmIHRoZSBtYWduaXR1ZGUgb2YgdGhpcyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1hZ25pdHVkZSBvZlxuICAgICAqIHRoZSByZW1haW5pbmcgZnJlZSBzcGFjZSwgdXNlIHRoaXMgYXMgdGhlIHJlbWFpbmluZyBmcmVlIHNwYWNlLlxuICAgICAqLyBsZXQgdXNlZFdpZHRoID0gMDtcbiAgICAgICAgbGV0IGZsZXhGYWN0b3JzID0gMDtcbiAgICAgICAgZmxleEl0ZW1zLmZvckVhY2goKGl0ZW0pPT57XG4gICAgICAgICAgICBpZiAoaXRlbS5mcm96ZW4pIHVzZWRXaWR0aCArPSBpdGVtLnRhcmdldE1haW5TaXplO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXNlZFdpZHRoICs9IGl0ZW0uYmFzZVNpemU7XG4gICAgICAgICAgICAgICAgZmxleEZhY3RvcnMgKz0gaXRlbS5mbGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJlbWFpbmluZ0ZyZWVTcGFjZSA9IGF2YWlsYWJsZVdpZHRoIC0gdXNlZFdpZHRoO1xuICAgICAgICAvLyB3ZSBvbmx5IHN1cHBvcnQgaW50ZWdlciBGUidzLCBhbmQgYmVjYXVzZSBvZiBoYXNOb25Gcm96ZW5JdGVtcywgd2Uga25vdyB0aGF0IGZsZXhGYWN0b3JzID4gMFxuICAgICAgICAvLyBzbyBubyBuZWVkIHRvIGNoZWNrIGZvciBmbGV4RmFjdG9ycyA8IDFcbiAgICAgICAgLy8gOS43LjQuY1xuICAgICAgICAvKipcbiAgICAgKiBJZiB0aGUgcmVtYWluaW5nIGZyZWUgc3BhY2UgaXMgemVyb1xuICAgICAqIC0gRG8gbm90aGluZy5cbiAgICAgKiBFbHNlIC8vIHJlbWVtYmVyLCB3ZSdyZSBhbHdheXMgaW4gZ3JvdyBtb2RlXG4gICAgICogLSBGaW5kIHRoZSByYXRpbyBvZiB0aGUgaXRlbeKAmXMgZmxleCBncm93IGZhY3RvciB0byB0aGVcbiAgICAgKiBzdW0gb2YgdGhlIGZsZXggZ3JvdyBmYWN0b3JzIG9mIGFsbCB1bmZyb3plbiBpdGVtcyBvblxuICAgICAqIHRoZSBsaW5lLiBTZXQgdGhlIGl0ZW3igJlzIHRhcmdldCBtYWluIHNpemUgdG8gaXRzIGZsZXhcbiAgICAgKiBiYXNlIHNpemUgcGx1cyBhIGZyYWN0aW9uIG9mIHRoZSByZW1haW5pbmcgZnJlZSBzcGFjZVxuICAgICAqIHByb3BvcnRpb25hbCB0byB0aGUgcmF0aW8uXG4gICAgICovIGlmIChyZW1haW5pbmdGcmVlU3BhY2UgPiAwKSBmbGV4SXRlbXMuZm9yRWFjaCgoaXRlbSk9PntcbiAgICAgICAgICAgIGlmICghaXRlbS5mcm96ZW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgcmF0aW8gPSBpdGVtLmZsZXggLyBmbGV4RmFjdG9ycztcbiAgICAgICAgICAgICAgICBpdGVtLnRhcmdldE1haW5TaXplID0gaXRlbS5iYXNlU2l6ZSArIHJhdGlvICogcmVtYWluaW5nRnJlZVNwYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gOS43LjQuZFxuICAgICAgICAvKipcbiAgICAgKiBGaXggbWluL21heCB2aW9sYXRpb25zLiBDbGFtcCBlYWNoIG5vbi1mcm96ZW4gaXRlbeKAmXNcbiAgICAgKiB0YXJnZXQgbWFpbiBzaXplIGJ5IGl0cyB1c2VkIG1pbiBhbmQgbWF4IG1haW4gc2l6ZXNcbiAgICAgKiBhbmQgZmxvb3IgaXRzIGNvbnRlbnQtYm94IHNpemUgYXQgemVyby4gSWYgdGhlIGl0ZW3igJlzXG4gICAgICogdGFyZ2V0IG1haW4gc2l6ZSB3YXMgbWFkZSBzbWFsbGVyIGJ5IHRoaXMsIGl04oCZcyBhIG1heFxuICAgICAqIHZpb2xhdGlvbi4gSWYgdGhlIGl0ZW3igJlzIHRhcmdldCBtYWluIHNpemUgd2FzIG1hZGVcbiAgICAgKiBsYXJnZXIgYnkgdGhpcywgaXTigJlzIGEgbWluIHZpb2xhdGlvbi5cbiAgICAgKi8gbGV0IHRvdGFsVmlvbGF0aW9uID0gMDtcbiAgICAgICAgZmxleEl0ZW1zLmZvckVhY2goKGl0ZW0pPT57XG4gICAgICAgICAgICBpdGVtLnZpb2xhdGlvbiA9IDA7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uZnJvemVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbWluOiBtaW4sIG1heDogbWF4LCB0YXJnZXRNYWluU2l6ZTogdGFyZ2V0TWFpblNpemUgfSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgaXRlbS50YXJnZXRNYWluU2l6ZSA9IE1hdGgubWF4KG1pbiwgTWF0aC5taW4odGFyZ2V0TWFpblNpemUsIG1heCkpO1xuICAgICAgICAgICAgICAgIGl0ZW0udmlvbGF0aW9uID0gaXRlbS50YXJnZXRNYWluU2l6ZSAtIHRhcmdldE1haW5TaXplO1xuICAgICAgICAgICAgICAgIHRvdGFsVmlvbGF0aW9uICs9IGl0ZW0udmlvbGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gOS43LjQuZVxuICAgICAgICAvKipcbiAgICAgKiBGcmVlemUgb3Zlci1mbGV4ZWQgaXRlbXMuIFRoZSB0b3RhbCB2aW9sYXRpb24gaXMgdGhlXG4gICAgICogc3VtIG9mIHRoZSBhZGp1c3RtZW50cyBmcm9tIHRoZSBwcmV2aW91cyBzdGVwXG4gICAgICog4oiRKGNsYW1wZWQgc2l6ZSAtIHVuY2xhbXBlZCBzaXplKS4gSWYgdGhlIHRvdGFsIHZpb2xhdGlvbiBpczpcbiAgICAgKiBaZXJvXG4gICAgICogLSBGcmVlemUgYWxsIGl0ZW1zLlxuICAgICAqXG4gICAgICogUG9zaXRpdmVcbiAgICAgKiAtIEZyZWV6ZSBhbGwgdGhlIGl0ZW1zIHdpdGggbWluIHZpb2xhdGlvbnMuXG4gICAgICpcbiAgICAgKiBOZWdhdGl2ZVxuICAgICAqIC0gRnJlZXplIGFsbCB0aGUgaXRlbXMgd2l0aCBtYXggdmlvbGF0aW9ucy5cbiAgICAgKi8gaGFzTm9uRnJvemVuSXRlbXMgPSBmYWxzZTtcbiAgICAgICAgZmxleEl0ZW1zLmZvckVhY2goKGl0ZW0pPT57XG4gICAgICAgICAgICBpZiAodG90YWxWaW9sYXRpb24gPT09IDAgfHwgTWF0aC5zaWduKHRvdGFsVmlvbGF0aW9uKSA9PT0gTWF0aC5zaWduKGl0ZW0udmlvbGF0aW9uKSkgaXRlbS5mcm96ZW4gPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWl0ZW0uZnJvemVuKSBoYXNOb25Gcm96ZW5JdGVtcyA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gJDY4MThiMWM0ZmM2NzAyOGQkdmFyJGNhc2NhZGVSb3VuZGluZyhmbGV4SXRlbXMpO1xufVxuZnVuY3Rpb24gJDY4MThiMWM0ZmM2NzAyOGQkdmFyJGNhc2NhZGVSb3VuZGluZyhmbGV4SXRlbXMpIHtcbiAgICAvKlxuICBHaXZlbiBhbiBhcnJheSBvZiBmbG9hdHMgdGhhdCBzdW0gdG8gYW4gaW50ZWdlciwgdGhpcyByb3VuZHMgdGhlIGZsb2F0c1xuICBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBpbnRlZ2VycyB3aXRoIHRoZSBzYW1lIHN1bS5cbiAgKi8gbGV0IGZwVG90YWwgPSAwO1xuICAgIGxldCBpbnRUb3RhbCA9IDA7XG4gICAgbGV0IHJvdW5kZWRBcnJheSA9IFtdO1xuICAgIGZsZXhJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgbGV0IGZsb2F0ID0gaXRlbS50YXJnZXRNYWluU2l6ZTtcbiAgICAgICAgbGV0IGludGVnZXIgPSBNYXRoLnJvdW5kKGZsb2F0ICsgZnBUb3RhbCkgLSBpbnRUb3RhbDtcbiAgICAgICAgZnBUb3RhbCArPSBmbG9hdDtcbiAgICAgICAgaW50VG90YWwgKz0gaW50ZWdlcjtcbiAgICAgICAgcm91bmRlZEFycmF5LnB1c2goaW50ZWdlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvdW5kZWRBcnJheTtcbn1cblxuXG5jbGFzcyAkYTllN2FlNTQ0YTRlNDFkZCRleHBvcnQkN2ZmNzdhMTYyOTcwYjMwZSB7XG4gICAgLyoqIFRha2VzIGFuIGFycmF5IG9mIGNvbHVtbnMgYW5kIHNwbGl0cyBpdCBpbnRvIDIgbWFwcyBvZiBjb2x1bW5zIHdpdGggY29udHJvbGxlZCBhbmQgY29sdW1ucyB3aXRoIHVuY29udHJvbGxlZCB3aWR0aHMuICovIHNwbGl0Q29sdW1uc0ludG9Db250cm9sbGVkQW5kVW5jb250cm9sbGVkKGNvbHVtbnMpIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMucmVkdWNlKChhY2MsIGNvbCk9PntcbiAgICAgICAgICAgIGlmIChjb2wucHJvcHMud2lkdGggIT0gbnVsbCkgYWNjWzBdLnNldChjb2wua2V5LCBjb2wpO1xuICAgICAgICAgICAgZWxzZSBhY2NbMV0uc2V0KGNvbC5rZXksIGNvbCk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXG4gICAgICAgICAgICBuZXcgTWFwKCksXG4gICAgICAgICAgICBuZXcgTWFwKClcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKiBUYWtlcyB1bmNvbnRyb2xsZWQgYW5kIGNvbnRyb2xsZWQgd2lkdGhzIGFuZCBqb2lucyB0aGVtIGludG8gYSBzaW5nbGUgTWFwLiAqLyByZWNvbWJpbmVDb2x1bW5zKGNvbHVtbnMsIHVuY29udHJvbGxlZFdpZHRocywgdW5jb250cm9sbGVkQ29sdW1ucywgY29udHJvbGxlZENvbHVtbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoY29sdW1ucy5tYXAoKGNvbCk9PntcbiAgICAgICAgICAgIGlmICh1bmNvbnRyb2xsZWRDb2x1bW5zLmhhcyhjb2wua2V5KSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBjb2wua2V5LFxuICAgICAgICAgICAgICAgIHVuY29udHJvbGxlZFdpZHRocy5nZXQoY29sLmtleSlcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBlbHNlIHJldHVybiBbXG4gICAgICAgICAgICAgICAgY29sLmtleSxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVkQ29sdW1ucy5nZXQoY29sLmtleSkucHJvcHMud2lkdGhcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqIFVzZWQgdG8gbWFrZSBhbiBpbml0aWFsIE1hcCBvZiB0aGUgdW5jb250cm9sbGVkIHdpZHRocyBiYXNlZCBvbiBkZWZhdWx0IHdpZHRocy4gKi8gZ2V0SW5pdGlhbFVuY29udHJvbGxlZFdpZHRocyh1bmNvbnRyb2xsZWRDb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKEFycmF5LmZyb20odW5jb250cm9sbGVkQ29sdW1ucykubWFwKChba2V5LCBjb2xdKT0+e1xuICAgICAgICAgICAgdmFyIF90aGlzX2dldERlZmF1bHRXaWR0aCwgX3RoaXM7XG4gICAgICAgICAgICB2YXIgX2NvbF9wcm9wc19kZWZhdWx0V2lkdGgsIF9yZWY7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAoX3JlZiA9IChfY29sX3Byb3BzX2RlZmF1bHRXaWR0aCA9IGNvbC5wcm9wcy5kZWZhdWx0V2lkdGgpICE9PSBudWxsICYmIF9jb2xfcHJvcHNfZGVmYXVsdFdpZHRoICE9PSB2b2lkIDAgPyBfY29sX3Byb3BzX2RlZmF1bHRXaWR0aCA6IChfdGhpc19nZXREZWZhdWx0V2lkdGggPSAoX3RoaXMgPSB0aGlzKS5nZXREZWZhdWx0V2lkdGgpID09PSBudWxsIHx8IF90aGlzX2dldERlZmF1bHRXaWR0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfZ2V0RGVmYXVsdFdpZHRoLmNhbGwoX3RoaXMsIGNvbCkpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiBcIjFmclwiXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldENvbHVtbldpZHRoKGtleSkge1xuICAgICAgICB2YXIgX3RoaXNfY29sdW1uV2lkdGhzX2dldDtcbiAgICAgICAgcmV0dXJuIChfdGhpc19jb2x1bW5XaWR0aHNfZ2V0ID0gdGhpcy5jb2x1bW5XaWR0aHMuZ2V0KGtleSkpICE9PSBudWxsICYmIF90aGlzX2NvbHVtbldpZHRoc19nZXQgIT09IHZvaWQgMCA/IF90aGlzX2NvbHVtbldpZHRoc19nZXQgOiAwO1xuICAgIH1cbiAgICBnZXRDb2x1bW5NaW5XaWR0aChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uTWluV2lkdGhzLmdldChrZXkpO1xuICAgIH1cbiAgICBnZXRDb2x1bW5NYXhXaWR0aChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uTWF4V2lkdGhzLmdldChrZXkpO1xuICAgIH1cbiAgICByZXNpemVDb2x1bW5XaWR0aCh0YWJsZVdpZHRoLCBjb2xsZWN0aW9uLCBjb250cm9sbGVkV2lkdGhzLCB1bmNvbnRyb2xsZWRXaWR0aHMsIGNvbCA9IG51bGwsIHdpZHRoKSB7XG4gICAgICAgIGxldCBwcmV2Q29sdW1uV2lkdGhzID0gdGhpcy5jb2x1bW5XaWR0aHM7XG4gICAgICAgIC8vIHJlc2l6aW5nIGEgY29sdW1uXG4gICAgICAgIGxldCByZXNpemVJbmRleCA9IEluZmluaXR5O1xuICAgICAgICBsZXQgcmVzaXppbmdDaGFuZ2VkID0gbmV3IE1hcChbXG4gICAgICAgICAgICAuLi5jb250cm9sbGVkV2lkdGhzLFxuICAgICAgICAgICAgLi4udW5jb250cm9sbGVkV2lkdGhzXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgcGVyY2VudEtleXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBmcktleXNUb1RoZVJpZ2h0ID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgbWluV2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBmcmVlemUgY29sdW1ucyB0byB0aGUgbGVmdCB0byB0aGVpciBwcmV2aW91cyBwaXhlbCB2YWx1ZVxuICAgICAgICBjb2xsZWN0aW9uLmNvbHVtbnMuZm9yRWFjaCgoY29sdW1uLCBpKT0+e1xuICAgICAgICAgICAgdmFyIF9jb2x1bW5fcHJvcHNfd2lkdGhfZW5kc1dpdGgsIF9jb2x1bW5fcHJvcHNfd2lkdGg7XG4gICAgICAgICAgICBsZXQgZnJLZXk7XG4gICAgICAgICAgICBsZXQgZnJWYWx1ZTtcbiAgICAgICAgICAgIG1pbldpZHRocy5zZXQoY29sdW1uLmtleSwgdGhpcy5nZXREZWZhdWx0TWluV2lkdGgoY29sbGVjdGlvbi5jb2x1bW5zW2ldKSk7XG4gICAgICAgICAgICBpZiAoY29sICE9PSBjb2x1bW4ua2V5ICYmICFjb2x1bW4ucHJvcHMud2lkdGggJiYgISgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkMTk5NGEwNzdiOThlZTBkNSkodW5jb250cm9sbGVkV2lkdGhzLmdldChjb2x1bW4ua2V5KSkpIHtcbiAgICAgICAgICAgICAgICAvLyB1bmNvbnRyb2xsZWQgZG9uJ3QgaGF2ZSBwcm9wcy53aWR0aCBmb3IgdXMsIHNvIGluc3RlYWQgZ2V0IGZyb20gb3VyIHN0YXRlXG4gICAgICAgICAgICAgICAgZnJLZXkgPSBjb2x1bW4ua2V5O1xuICAgICAgICAgICAgICAgIGZyVmFsdWUgPSAoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDkwNzhiYWQ0YzM5MzQ2MDQpKHVuY29udHJvbGxlZFdpZHRocy5nZXQoY29sdW1uLmtleSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgIT09IGNvbHVtbi5rZXkgJiYgISgwLCAkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkMTk5NGEwNzdiOThlZTBkNSkoY29sdW1uLnByb3BzLndpZHRoKSAmJiAhdW5jb250cm9sbGVkV2lkdGhzLmdldChjb2x1bW4ua2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnRyb2xsZWRXaWR0aHMgd2lsbCBiZSB0aGUgc2FtZSBpbiB0aGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgIGZyS2V5ID0gY29sdW1uLmtleTtcbiAgICAgICAgICAgICAgICBmclZhbHVlID0gKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0KShjb2x1bW4ucHJvcHMud2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgIT09IGNvbHVtbi5rZXkgJiYgKChfY29sdW1uX3Byb3BzX3dpZHRoID0gY29sdW1uLnByb3BzLndpZHRoKSA9PT0gbnVsbCB8fCBfY29sdW1uX3Byb3BzX3dpZHRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2NvbHVtbl9wcm9wc193aWR0aF9lbmRzV2l0aCA9IF9jb2x1bW5fcHJvcHNfd2lkdGguZW5kc1dpdGgpID09PSBudWxsIHx8IF9jb2x1bW5fcHJvcHNfd2lkdGhfZW5kc1dpdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2x1bW5fcHJvcHNfd2lkdGhfZW5kc1dpdGguY2FsbChfY29sdW1uX3Byb3BzX3dpZHRoLCBcIiVcIikpKSBwZXJjZW50S2V5cy5zZXQoY29sdW1uLmtleSwgY29sdW1uLnByb3BzLndpZHRoKTtcbiAgICAgICAgICAgIC8vIGRvbid0IGZyZWV6ZSBjb2x1bW5zIHRvIHRoZSByaWdodCBvZiB0aGUgcmVzaXppbmcgb25lXG4gICAgICAgICAgICBpZiAocmVzaXplSW5kZXggPCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyS2V5KSBmcktleXNUb1RoZVJpZ2h0LnNldChmcktleSwgZnJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgYWxyZWFkeSBrbm93IHRoZSBuZXcgc2l6ZSBvZiB0aGUgcmVzaXppbmcgY29sdW1uXG4gICAgICAgICAgICBpZiAoY29sdW1uLmtleSA9PT0gY29sKSB7XG4gICAgICAgICAgICAgICAgcmVzaXplSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHJlc2l6aW5nQ2hhbmdlZC5zZXQoY29sdW1uLmtleSwgTWF0aC5mbG9vcih3aWR0aCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZyZWV6ZSBjb2x1bW4gdG8gcHJldmlvdXMgdmFsdWVcbiAgICAgICAgICAgIHJlc2l6aW5nQ2hhbmdlZC5zZXQoY29sdW1uLmtleSwgcHJldkNvbHVtbldpZHRocy5nZXQoY29sdW1uLmtleSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcHJlZGljdCBwaXhlbHMgc2l6ZXMgZm9yIGFsbCBjb2x1bW5zIGJhc2VkIG9uIHJlc2l6ZVxuICAgICAgICBsZXQgY29sdW1uV2lkdGhzID0gKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1NWQ1MGRjNjg3Mzg1NDkxKSh0YWJsZVdpZHRoLCBjb2xsZWN0aW9uLmNvbHVtbnMubWFwKChjb2wpPT4oe1xuICAgICAgICAgICAgICAgIC4uLmNvbC5wcm9wcyxcbiAgICAgICAgICAgICAgICBrZXk6IGNvbC5rZXlcbiAgICAgICAgICAgIH0pKSwgcmVzaXppbmdDaGFuZ2VkLCAoaSk9PnRoaXMuZ2V0RGVmYXVsdFdpZHRoKGNvbGxlY3Rpb24uY29sdW1uc1tpXSksIChpKT0+dGhpcy5nZXREZWZhdWx0TWluV2lkdGgoY29sbGVjdGlvbi5jb2x1bW5zW2ldKSk7XG4gICAgICAgIC8vIHNldCBhbGwgbmV3IGNvbHVtbiB3aWR0aHMgZm9yIG9uUmVzaXplIGV2ZW50XG4gICAgICAgIC8vIGNvbHVtbnMgZ29pbmcgaW4gd2lsbCBiZSB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY29sdW1ucyBjb21pbmcgb3V0XG4gICAgICAgIGxldCBuZXdXaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIHNldCBhbGwgY29sdW1uIHdpZHRocyBiYXNlZCBvbiBjYWxjdWxhdGVDb2x1bW5TaXplXG4gICAgICAgIGNvbHVtbldpZHRocy5mb3JFYWNoKCh3aWR0aCwgaW5kZXgpPT57XG4gICAgICAgICAgICBsZXQga2V5ID0gY29sbGVjdGlvbi5jb2x1bW5zW2luZGV4XS5rZXk7XG4gICAgICAgICAgICBuZXdXaWR0aHMuc2V0KGtleSwgd2lkdGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gYWRkIEZSJ3MgYmFjayBhcyB0aGV5IHdlcmUgdG8gY29sdW1ucyB0byB0aGUgcmlnaHRcbiAgICAgICAgQXJyYXkuZnJvbShmcktleXNUb1RoZVJpZ2h0KS5mb3JFYWNoKChba2V5XSk9PntcbiAgICAgICAgICAgIG5ld1dpZHRocy5zZXQoa2V5LCBgJHtmcktleXNUb1RoZVJpZ2h0LmdldChrZXkpfWZyYCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBwdXQgYmFjayBpbiBwZXJjZW50c1xuICAgICAgICBBcnJheS5mcm9tKHBlcmNlbnRLZXlzKS5mb3JFYWNoKChba2V5LCB3aWR0aF0pPT57XG4gICAgICAgICAgICAvLyByZXNpemluZyBsb2NrcyBhIGNvbHVtbiB0byBhIHB4IHdpZHRoXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBjb2wpIHJldHVybjtcbiAgICAgICAgICAgIG5ld1dpZHRocy5zZXQoa2V5LCB3aWR0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3V2lkdGhzO1xuICAgIH1cbiAgICBidWlsZENvbHVtbldpZHRocyh0YWJsZVdpZHRoLCBjb2xsZWN0aW9uLCB3aWR0aHMpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5XaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29sdW1uTWluV2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbHVtbk1heFdpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gaW5pdGlhbCBsYXlvdXQgb3IgdGFibGUvd2luZG93IHJlc2l6aW5nXG4gICAgICAgIGxldCBjb2x1bW5XaWR0aHMgPSAoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDU1ZDUwZGM2ODczODU0OTEpKHRhYmxlV2lkdGgsIGNvbGxlY3Rpb24uY29sdW1ucy5tYXAoKGNvbCk9Pih7XG4gICAgICAgICAgICAgICAgLi4uY29sLnByb3BzLFxuICAgICAgICAgICAgICAgIGtleTogY29sLmtleVxuICAgICAgICAgICAgfSkpLCB3aWR0aHMsIChpKT0+dGhpcy5nZXREZWZhdWx0V2lkdGgoY29sbGVjdGlvbi5jb2x1bW5zW2ldKSwgKGkpPT50aGlzLmdldERlZmF1bHRNaW5XaWR0aChjb2xsZWN0aW9uLmNvbHVtbnNbaV0pKTtcbiAgICAgICAgLy8gY29sdW1ucyBnb2luZyBpbiB3aWxsIGJlIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBjb2x1bW5zIGNvbWluZyBvdXRcbiAgICAgICAgY29sdW1uV2lkdGhzLmZvckVhY2goKHdpZHRoLCBpbmRleCk9PntcbiAgICAgICAgICAgIGxldCBrZXkgPSBjb2xsZWN0aW9uLmNvbHVtbnNbaW5kZXhdLmtleTtcbiAgICAgICAgICAgIGxldCBjb2x1bW4gPSBjb2xsZWN0aW9uLmNvbHVtbnNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5XaWR0aHMuc2V0KGtleSwgd2lkdGgpO1xuICAgICAgICAgICAgdmFyIF9jb2x1bW5fcHJvcHNfbWluV2lkdGg7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbk1pbldpZHRocy5zZXQoa2V5LCAoMCwgJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JGY1NTYwNTRjZTQzNTg3MDEpKChfY29sdW1uX3Byb3BzX21pbldpZHRoID0gY29sdW1uLnByb3BzLm1pbldpZHRoKSAhPT0gbnVsbCAmJiBfY29sdW1uX3Byb3BzX21pbldpZHRoICE9PSB2b2lkIDAgPyBfY29sdW1uX3Byb3BzX21pbldpZHRoIDogdGhpcy5nZXREZWZhdWx0TWluV2lkdGgoY29sdW1uKSwgdGFibGVXaWR0aCkpO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5NYXhXaWR0aHMuc2V0KGtleSwgKDAsICQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ1OTE4NWM2MmE3NTQ0YWEwKShjb2x1bW4ucHJvcHMubWF4V2lkdGgsIHRhYmxlV2lkdGgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbldpZHRocztcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyl7XG4gICAgICAgIHRoaXMuY29sdW1uV2lkdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbHVtbk1pbldpZHRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5NYXhXaWR0aHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBfb3B0aW9uc19nZXREZWZhdWx0V2lkdGg7XG4gICAgICAgIHRoaXMuZ2V0RGVmYXVsdFdpZHRoID0gKF9vcHRpb25zX2dldERlZmF1bHRXaWR0aCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5nZXREZWZhdWx0V2lkdGgpICE9PSBudWxsICYmIF9vcHRpb25zX2dldERlZmF1bHRXaWR0aCAhPT0gdm9pZCAwID8gX29wdGlvbnNfZ2V0RGVmYXVsdFdpZHRoIDogKCk9PlwiMWZyXCI7XG4gICAgICAgIHZhciBfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGg7XG4gICAgICAgIHRoaXMuZ2V0RGVmYXVsdE1pbldpZHRoID0gKF9vcHRpb25zX2dldERlZmF1bHRNaW5XaWR0aCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5nZXREZWZhdWx0TWluV2lkdGgpICE9PSBudWxsICYmIF9vcHRpb25zX2dldERlZmF1bHRNaW5XaWR0aCAhPT0gdm9pZCAwID8gX29wdGlvbnNfZ2V0RGVmYXVsdE1pbldpZHRoIDogKCk9Pjc1O1xuICAgIH1cbn1cblxuXG5cbmZ1bmN0aW9uICQyOTJiYzRlMDljZDBlYjYyJGV4cG9ydCRjYjg5NWRjZjg1ZGIxMzE5KHByb3BzLCBzdGF0ZSkge1xuICAgIGxldCB7IGdldERlZmF1bHRXaWR0aDogZ2V0RGVmYXVsdFdpZHRoLCBnZXREZWZhdWx0TWluV2lkdGg6IGdldERlZmF1bHRNaW5XaWR0aCwgdGFibGVXaWR0aDogdGFibGVXaWR0aCA9IDAgfSA9IHByb3BzO1xuICAgIGxldCBbcmVzaXppbmdDb2x1bW4sIHNldFJlc2l6aW5nQ29sdW1uXSA9ICgwLCAkMUJmalckdXNlU3RhdGUpKG51bGwpO1xuICAgIGxldCBjb2x1bW5MYXlvdXQgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5uZXcgKDAsICRhOWU3YWU1NDRhNGU0MWRkJGV4cG9ydCQ3ZmY3N2ExNjI5NzBiMzBlKSh7XG4gICAgICAgICAgICBnZXREZWZhdWx0V2lkdGg6IGdldERlZmF1bHRXaWR0aCxcbiAgICAgICAgICAgIGdldERlZmF1bHRNaW5XaWR0aDogZ2V0RGVmYXVsdE1pbldpZHRoXG4gICAgICAgIH0pLCBbXG4gICAgICAgIGdldERlZmF1bHRXaWR0aCxcbiAgICAgICAgZ2V0RGVmYXVsdE1pbldpZHRoXG4gICAgXSk7XG4gICAgbGV0IFtjb250cm9sbGVkQ29sdW1ucywgdW5jb250cm9sbGVkQ29sdW1uc10gPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5jb2x1bW5MYXlvdXQuc3BsaXRDb2x1bW5zSW50b0NvbnRyb2xsZWRBbmRVbmNvbnRyb2xsZWQoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zKSwgW1xuICAgICAgICBzdGF0ZS5jb2xsZWN0aW9uLmNvbHVtbnMsXG4gICAgICAgIGNvbHVtbkxheW91dFxuICAgIF0pO1xuICAgIC8vIHVuY29udHJvbGxlZCBjb2x1bW4gd2lkdGhzXG4gICAgbGV0IFt1bmNvbnRyb2xsZWRXaWR0aHMsIHNldFVuY29udHJvbGxlZFdpZHRoc10gPSAoMCwgJDFCZmpXJHVzZVN0YXRlKSgoKT0+Y29sdW1uTGF5b3V0LmdldEluaXRpYWxVbmNvbnRyb2xsZWRXaWR0aHModW5jb250cm9sbGVkQ29sdW1ucykpO1xuICAgIC8vIFVwZGF0ZSB1bmNvbnRyb2xsZWQgd2lkdGhzIGlmIHRoZSBjb2x1bW5zIGNoYW5nZWQuXG4gICAgbGV0IFtsYXN0Q29sdW1ucywgc2V0TGFzdENvbHVtbnNdID0gKDAsICQxQmZqVyR1c2VTdGF0ZSkoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zKTtcbiAgICBpZiAoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zICE9PSBsYXN0Q29sdW1ucykge1xuICAgICAgICBpZiAoc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zLmxlbmd0aCAhPT0gbGFzdENvbHVtbnMubGVuZ3RoIHx8IHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucy5zb21lKChjLCBpKT0+Yy5rZXkgIT09IGxhc3RDb2x1bW5zW2ldLmtleSkpIHtcbiAgICAgICAgICAgIGxldCBuZXdVbmNvbnRyb2xsZWRXaWR0aHMgPSBjb2x1bW5MYXlvdXQuZ2V0SW5pdGlhbFVuY29udHJvbGxlZFdpZHRocyh1bmNvbnRyb2xsZWRDb2x1bW5zKTtcbiAgICAgICAgICAgIHNldFVuY29udHJvbGxlZFdpZHRocyhuZXdVbmNvbnRyb2xsZWRXaWR0aHMpO1xuICAgICAgICB9XG4gICAgICAgIHNldExhc3RDb2x1bW5zKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucyk7XG4gICAgfVxuICAgIC8vIGNvbWJpbmUgY29sdW1ucyBiYWNrIGludG8gb25lIG1hcCB0aGF0IG1haW50YWlucyBzYW1lIG9yZGVyIGFzIHRoZSBjb2x1bW5zXG4gICAgbGV0IGNvbFdpZHRocyA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9PmNvbHVtbkxheW91dC5yZWNvbWJpbmVDb2x1bW5zKHN0YXRlLmNvbGxlY3Rpb24uY29sdW1ucywgdW5jb250cm9sbGVkV2lkdGhzLCB1bmNvbnRyb2xsZWRDb2x1bW5zLCBjb250cm9sbGVkQ29sdW1ucyksIFtcbiAgICAgICAgc3RhdGUuY29sbGVjdGlvbi5jb2x1bW5zLFxuICAgICAgICB1bmNvbnRyb2xsZWRXaWR0aHMsXG4gICAgICAgIHVuY29udHJvbGxlZENvbHVtbnMsXG4gICAgICAgIGNvbnRyb2xsZWRDb2x1bW5zLFxuICAgICAgICBjb2x1bW5MYXlvdXRcbiAgICBdKTtcbiAgICBsZXQgc3RhcnRSZXNpemUgPSAoMCwgJDFCZmpXJHVzZUNhbGxiYWNrKSgoa2V5KT0+e1xuICAgICAgICBzZXRSZXNpemluZ0NvbHVtbihrZXkpO1xuICAgIH0sIFtcbiAgICAgICAgc2V0UmVzaXppbmdDb2x1bW5cbiAgICBdKTtcbiAgICBsZXQgdXBkYXRlUmVzaXplZENvbHVtbnMgPSAoMCwgJDFCZmpXJHVzZUNhbGxiYWNrKSgoa2V5LCB3aWR0aCk9PntcbiAgICAgICAgbGV0IG5ld0NvbnRyb2xsZWQgPSBuZXcgTWFwKEFycmF5LmZyb20oY29udHJvbGxlZENvbHVtbnMpLm1hcCgoW2tleSwgZW50cnldKT0+W1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBlbnRyeS5wcm9wcy53aWR0aFxuICAgICAgICAgICAgXSkpO1xuICAgICAgICBsZXQgbmV3U2l6ZXMgPSBjb2x1bW5MYXlvdXQucmVzaXplQ29sdW1uV2lkdGgodGFibGVXaWR0aCwgc3RhdGUuY29sbGVjdGlvbiwgbmV3Q29udHJvbGxlZCwgdW5jb250cm9sbGVkV2lkdGhzLCBrZXksIHdpZHRoKTtcbiAgICAgICAgbGV0IG1hcCA9IG5ldyBNYXAoQXJyYXkuZnJvbSh1bmNvbnRyb2xsZWRDb2x1bW5zKS5tYXAoKFtrZXldKT0+W1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBuZXdTaXplcy5nZXQoa2V5KVxuICAgICAgICAgICAgXSkpO1xuICAgICAgICBtYXAuc2V0KGtleSwgd2lkdGgpO1xuICAgICAgICBzZXRVbmNvbnRyb2xsZWRXaWR0aHMobWFwKTtcbiAgICAgICAgcmV0dXJuIG5ld1NpemVzO1xuICAgIH0sIFtcbiAgICAgICAgY29udHJvbGxlZENvbHVtbnMsXG4gICAgICAgIHVuY29udHJvbGxlZENvbHVtbnMsXG4gICAgICAgIHNldFVuY29udHJvbGxlZFdpZHRocyxcbiAgICAgICAgdGFibGVXaWR0aCxcbiAgICAgICAgY29sdW1uTGF5b3V0LFxuICAgICAgICBzdGF0ZS5jb2xsZWN0aW9uLFxuICAgICAgICB1bmNvbnRyb2xsZWRXaWR0aHNcbiAgICBdKTtcbiAgICBsZXQgZW5kUmVzaXplID0gKDAsICQxQmZqVyR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgc2V0UmVzaXppbmdDb2x1bW4obnVsbCk7XG4gICAgfSwgW1xuICAgICAgICBzZXRSZXNpemluZ0NvbHVtblxuICAgIF0pO1xuICAgICgwLCAkMUJmalckdXNlTWVtbykoKCk9PmNvbHVtbkxheW91dC5idWlsZENvbHVtbldpZHRocyh0YWJsZVdpZHRoLCBzdGF0ZS5jb2xsZWN0aW9uLCBjb2xXaWR0aHMpLCBbXG4gICAgICAgIHRhYmxlV2lkdGgsXG4gICAgICAgIHN0YXRlLmNvbGxlY3Rpb24sXG4gICAgICAgIGNvbFdpZHRocyxcbiAgICAgICAgY29sdW1uTGF5b3V0XG4gICAgXSk7XG4gICAgcmV0dXJuICgwLCAkMUJmalckdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICByZXNpemluZ0NvbHVtbjogcmVzaXppbmdDb2x1bW4sXG4gICAgICAgICAgICB1cGRhdGVSZXNpemVkQ29sdW1uczogdXBkYXRlUmVzaXplZENvbHVtbnMsXG4gICAgICAgICAgICBzdGFydFJlc2l6ZTogc3RhcnRSZXNpemUsXG4gICAgICAgICAgICBlbmRSZXNpemU6IGVuZFJlc2l6ZSxcbiAgICAgICAgICAgIGdldENvbHVtbldpZHRoOiAoa2V5KT0+Y29sdW1uTGF5b3V0LmdldENvbHVtbldpZHRoKGtleSksXG4gICAgICAgICAgICBnZXRDb2x1bW5NaW5XaWR0aDogKGtleSk9PmNvbHVtbkxheW91dC5nZXRDb2x1bW5NaW5XaWR0aChrZXkpLFxuICAgICAgICAgICAgZ2V0Q29sdW1uTWF4V2lkdGg6IChrZXkpPT5jb2x1bW5MYXlvdXQuZ2V0Q29sdW1uTWF4V2lkdGgoa2V5KSxcbiAgICAgICAgICAgIHRhYmxlU3RhdGU6IHN0YXRlXG4gICAgICAgIH0pLCBbXG4gICAgICAgIGNvbHVtbkxheW91dCxcbiAgICAgICAgcmVzaXppbmdDb2x1bW4sXG4gICAgICAgIHVwZGF0ZVJlc2l6ZWRDb2x1bW5zLFxuICAgICAgICBzdGFydFJlc2l6ZSxcbiAgICAgICAgZW5kUmVzaXplLFxuICAgICAgICBzdGF0ZVxuICAgIF0pO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuXG5jb25zdCAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZID0gXCJyb3ctaGVhZGVyLWNvbHVtbi1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xubGV0ICQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVlfRFJBRyA9IFwicm93LWhlYWRlci1jb2x1bW4tXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbndoaWxlKCQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVkgPT09ICQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVlfRFJBRykkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZX0RSQUcgPSBcInJvdy1oZWFkZXItY29sdW1uLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5mdW5jdGlvbiAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkN2MxMjdkYjg1MGQ0ZTgxZShrZXlNYXAsIGNvbHVtbk5vZGVzKSB7XG4gICAgaWYgKGNvbHVtbk5vZGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICAgIGxldCBjb2x1bW5zID0gW107XG4gICAgbGV0IHNlZW4gPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgY29sdW1uIG9mIGNvbHVtbk5vZGVzKXtcbiAgICAgICAgbGV0IHBhcmVudEtleSA9IGNvbHVtbi5wYXJlbnRLZXk7XG4gICAgICAgIGxldCBjb2wgPSBbXG4gICAgICAgICAgICBjb2x1bW5cbiAgICAgICAgXTtcbiAgICAgICAgd2hpbGUocGFyZW50S2V5KXtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBrZXlNYXAuZ2V0KHBhcmVudEtleSk7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCkgYnJlYWs7XG4gICAgICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHNlZW4gdGhpcyBwYXJlbnQsIHRoYW4gaXQgaXMgc2hhcmVkXG4gICAgICAgICAgICAvLyB3aXRoIGEgcHJldmlvdXMgY29sdW1uLiBJZiB0aGUgY3VycmVudCBjb2x1bW4gaXMgdGFsbGVyXG4gICAgICAgICAgICAvLyB0aGFuIHRoZSBwcmV2aW91cyBjb2x1bW4sIHRoYW4gd2UgbmVlZCB0byBzaGlmdCB0aGUgcGFyZW50XG4gICAgICAgICAgICAvLyBpbiB0aGUgcHJldmlvdXMgY29sdW1uIHNvIGl0J3MgbGV2ZWwgd2l0aCB0aGUgY3VycmVudCBjb2x1bW4uXG4gICAgICAgICAgICBpZiAoc2Vlbi5oYXMocGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5jb2xzcGFuKys7XG4gICAgICAgICAgICAgICAgbGV0IHsgY29sdW1uOiBjb2x1bW4sIGluZGV4OiBpbmRleCB9ID0gc2Vlbi5nZXQocGFyZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiBjb2wubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSBpbmRleDsgaSA8IGNvbC5sZW5ndGg7IGkrKyljb2x1bW4uc3BsaWNlKGksIDAsIG51bGwpO1xuICAgICAgICAgICAgICAgIC8vIEFkanVzdCBzaGlmdGVkIGluZGljZXNcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSBjb2wubGVuZ3RoOyBpIDwgY29sdW1uLmxlbmd0aDsgaSsrKS8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uW2ldICYmIHNlZW4uaGFzKGNvbHVtbltpXSkpIHNlZW4uZ2V0KGNvbHVtbltpXSkuaW5kZXggPSBpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY29sc3BhbiA9IDE7XG4gICAgICAgICAgICAgICAgY29sLnB1c2gocGFyZW50KTtcbiAgICAgICAgICAgICAgICBzZWVuLnNldChwYXJlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBjb2wubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50S2V5ID0gcGFyZW50LnBhcmVudEtleTtcbiAgICAgICAgfVxuICAgICAgICBjb2x1bW5zLnB1c2goY29sKTtcbiAgICAgICAgY29sdW1uLmluZGV4ID0gY29sdW1ucy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBsZXQgbWF4TGVuZ3RoID0gTWF0aC5tYXgoLi4uY29sdW1ucy5tYXAoKGMpPT5jLmxlbmd0aCkpO1xuICAgIGxldCBoZWFkZXJSb3dzID0gQXJyYXkobWF4TGVuZ3RoKS5maWxsKDApLm1hcCgoKT0+W10pO1xuICAgIC8vIENvbnZlcnQgY29sdW1ucyBpbnRvIHJvd3MuXG4gICAgbGV0IGNvbEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBjb2x1bW4gb2YgY29sdW1ucyl7XG4gICAgICAgIGxldCBpID0gbWF4TGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBjb2x1bW4pe1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvLyBGaWxsIHRoZSBzcGFjZSB1cCB1bnRpbCB0aGUgY3VycmVudCBjb2x1bW4gd2l0aCBhIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgbGV0IHJvdyA9IGhlYWRlclJvd3NbaV07XG4gICAgICAgICAgICAgICAgbGV0IHJvd0xlbmd0aCA9IHJvdy5yZWR1Y2UoKHAsIGMpPT5wICsgYy5jb2xzcGFuLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAocm93TGVuZ3RoIDwgY29sSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsYWNlaG9sZGVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcInBsYWNlaG9sZGVyLVwiICsgaXRlbS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xzcGFuOiBjb2xJbmRleCAtIHJvd0xlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiByb3dMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFZhbHVlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dbcm93Lmxlbmd0aCAtIDFdLm5leHRLZXkgPSBwbGFjZWhvbGRlci5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlci5wcmV2S2V5ID0gcm93W3Jvdy5sZW5ndGggLSAxXS5rZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2gocGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm93Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcm93W3Jvdy5sZW5ndGggLSAxXS5uZXh0S2V5ID0gaXRlbS5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucHJldktleSA9IHJvd1tyb3cubGVuZ3RoIC0gMV0ua2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtLmxldmVsID0gaTtcbiAgICAgICAgICAgICAgICBpdGVtLmNvbEluZGV4ID0gY29sSW5kZXg7XG4gICAgICAgICAgICAgICAgcm93LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgY29sSW5kZXgrKztcbiAgICB9XG4gICAgLy8gQWRkIHBsYWNlaG9sZGVycyBhdCB0aGUgZW5kIG9mIGVhY2ggcm93IHRoYXQgaXMgc2hvcnRlciB0aGFuIHRoZSBtYXhpbXVtXG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHJvdyBvZiBoZWFkZXJSb3dzKXtcbiAgICAgICAgbGV0IHJvd0xlbmd0aCA9IHJvdy5yZWR1Y2UoKHAsIGMpPT5wICsgYy5jb2xzcGFuLCAwKTtcbiAgICAgICAgaWYgKHJvd0xlbmd0aCA8IGNvbHVtbk5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHBsYWNlaG9sZGVyID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgICAgICAgICBrZXk6IFwicGxhY2Vob2xkZXItXCIgKyByb3dbcm93Lmxlbmd0aCAtIDFdLmtleSxcbiAgICAgICAgICAgICAgICBjb2xzcGFuOiBjb2x1bW5Ob2Rlcy5sZW5ndGggLSByb3dMZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHJvd0xlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICByZW5kZXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgICBsZXZlbDogaSxcbiAgICAgICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgICAgICAgICB0ZXh0VmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJldktleTogcm93W3Jvdy5sZW5ndGggLSAxXS5rZXlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByb3cucHVzaChwbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVyUm93cy5tYXAoKGNoaWxkTm9kZXMsIGluZGV4KT0+e1xuICAgICAgICBsZXQgcm93ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJoZWFkZXJyb3dcIixcbiAgICAgICAgICAgIGtleTogXCJoZWFkZXJyb3ctXCIgKyBpbmRleCxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgcmVuZGVyZWQ6IG51bGwsXG4gICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgIGhhc0NoaWxkTm9kZXM6IHRydWUsXG4gICAgICAgICAgICBjaGlsZE5vZGVzOiBjaGlsZE5vZGVzLFxuICAgICAgICAgICAgdGV4dFZhbHVlOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgfSk7XG59XG5jbGFzcyAkNzg4NzgxYmFhMzAxMTdmYSRleHBvcnQkNTk2ZTFiMmUyY2Y5MzY5MCBleHRlbmRzICgwLCAkMUJmalckR3JpZENvbGxlY3Rpb24pIHtcbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmJvZHkuY2hpbGROb2RlcztcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAua2V5cygpO1xuICAgIH1cbiAgICBnZXRLZXlCZWZvcmUoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5wcmV2S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0S2V5QWZ0ZXIoa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiBub2RlID8gbm9kZS5uZXh0S2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Rmlyc3RLZXkoKSB7XG4gICAgICAgIHZhciBfZ2V0Rmlyc3RJdGVtO1xuICAgICAgICByZXR1cm4gKF9nZXRGaXJzdEl0ZW0gPSAoMCwgJDFCZmpXJGdldEZpcnN0SXRlbSkodGhpcy5ib2R5LmNoaWxkTm9kZXMpKSA9PT0gbnVsbCB8fCBfZ2V0Rmlyc3RJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0Rmlyc3RJdGVtLmtleTtcbiAgICB9XG4gICAgZ2V0TGFzdEtleSgpIHtcbiAgICAgICAgdmFyIF9nZXRMYXN0SXRlbTtcbiAgICAgICAgcmV0dXJuIChfZ2V0TGFzdEl0ZW0gPSAoMCwgJDFCZmpXJGdldExhc3RJdGVtKSh0aGlzLmJvZHkuY2hpbGROb2RlcykpID09PSBudWxsIHx8IF9nZXRMYXN0SXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldExhc3RJdGVtLmtleTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgIH1cbiAgICBhdChpZHgpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0S2V5cygpXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZW0oa2V5c1tpZHhdKTtcbiAgICB9XG4gICAgZ2V0VGV4dFZhbHVlKGtleSkge1xuICAgICAgICBsZXQgcm93ID0gdGhpcy5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmICghcm93KSByZXR1cm4gXCJcIjtcbiAgICAgICAgLy8gSWYgdGhlIHJvdyBoYXMgYSB0ZXh0VmFsdWUsIHVzZSB0aGF0LlxuICAgICAgICBpZiAocm93LnRleHRWYWx1ZSkgcmV0dXJuIHJvdy50ZXh0VmFsdWU7XG4gICAgICAgIC8vIE90aGVyd2lzZSBjb21iaW5lIHRoZSB0ZXh0IG9mIGVhY2ggb2YgdGhlIHJvdyBoZWFkZXIgY29sdW1ucy5cbiAgICAgICAgbGV0IHJvd0hlYWRlckNvbHVtbktleXMgPSB0aGlzLnJvd0hlYWRlckNvbHVtbktleXM7XG4gICAgICAgIGlmIChyb3dIZWFkZXJDb2x1bW5LZXlzKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2VsbCBvZiByb3cuY2hpbGROb2Rlcyl7XG4gICAgICAgICAgICAgICAgbGV0IGNvbHVtbiA9IHRoaXMuY29sdW1uc1tjZWxsLmluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAocm93SGVhZGVyQ29sdW1uS2V5cy5oYXMoY29sdW1uLmtleSkgJiYgY2VsbC50ZXh0VmFsdWUpIHRleHQucHVzaChjZWxsLnRleHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSByb3dIZWFkZXJDb2x1bW5LZXlzLnNpemUpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRleHQuam9pbihcIiBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG5vZGVzLCBwcmV2LCBvcHRzKXtcbiAgICAgICAgbGV0IHJvd0hlYWRlckNvbHVtbktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBsZXQgY29sdW1ucyA9IFtdO1xuICAgICAgICAvLyBBZGQgY2VsbCBmb3Igc2VsZWN0aW9uIGNoZWNrYm94ZXMgaWYgbmVlZGVkLlxuICAgICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dTZWxlY3Rpb25DaGVja2JveGVzKSB7XG4gICAgICAgICAgICBsZXQgcm93SGVhZGVyQ29sdW1uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAga2V5OiAkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHRleHRWYWx1ZTogXCJcIixcbiAgICAgICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgICAgICBpbmRleDogKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93RHJhZ0J1dHRvbnMpID8gMSA6IDAsXG4gICAgICAgICAgICAgICAgaGFzQ2hpbGROb2RlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3Rpb25DZWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbHVtbnMudW5zaGlmdChyb3dIZWFkZXJDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBjZWxsIGZvciBkcmFnIGJ1dHRvbnMgaWYgbmVlZGVkLlxuICAgICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dEcmFnQnV0dG9ucykge1xuICAgICAgICAgICAgbGV0IHJvd0hlYWRlckNvbHVtbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgIGtleTogJDc4ODc4MWJhYTMwMTE3ZmEkdmFyJFJPV19IRUFERVJfQ09MVU1OX0tFWV9EUkFHLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHRleHRWYWx1ZTogXCJcIixcbiAgICAgICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgICAgICBoYXNDaGlsZE5vZGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZW5kZXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBpc0RyYWdCdXR0b25DZWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbHVtbnMudW5zaGlmdChyb3dIZWFkZXJDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByb3dzID0gW107XG4gICAgICAgIGxldCBjb2x1bW5LZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCB2aXNpdCA9IChub2RlKT0+e1xuICAgICAgICAgICAgc3dpdGNoKG5vZGUudHlwZSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb2x1bW5cIjpcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uS2V5TWFwLnNldChub2RlLmtleSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5oYXNDaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5wcm9wcy5pc1Jvd0hlYWRlcikgcm93SGVhZGVyQ29sdW1uS2V5cy5hZGQobm9kZS5rZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpdGVtXCI6XG4gICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBkbyBub3QgZ28gaW50byBjaGlsZE5vZGVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpdmlzaXQoY2hpbGQpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKXZpc2l0KG5vZGUpO1xuICAgICAgICBsZXQgaGVhZGVyUm93cyA9ICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ3YzEyN2RiODUwZDRlODFlKGNvbHVtbktleU1hcCwgY29sdW1ucyk7XG4gICAgICAgIGhlYWRlclJvd3MuZm9yRWFjaCgocm93LCBpKT0+cm93cy5zcGxpY2UoaSwgMCwgcm93KSk7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGNvbHVtbkNvdW50OiBjb2x1bW5zLmxlbmd0aCxcbiAgICAgICAgICAgIGl0ZW1zOiByb3dzLFxuICAgICAgICAgICAgdmlzaXROb2RlOiAobm9kZSk9PntcbiAgICAgICAgICAgICAgICBub2RlLmNvbHVtbiA9IGNvbHVtbnNbbm9kZS5pbmRleF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucztcbiAgICAgICAgdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzID0gcm93SGVhZGVyQ29sdW1uS2V5cztcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5oZWFkZXJSb3dzID0gaGVhZGVyUm93cztcbiAgICAgICAgdGhpcy5fc2l6ZSA9IFtcbiAgICAgICAgICAgIC4uLmJvZHkuY2hpbGROb2Rlc1xuICAgICAgICBdLmxlbmd0aDtcbiAgICAgICAgLy8gRGVmYXVsdCByb3cgaGVhZGVyIGNvbHVtbiB0byB0aGUgZmlyc3Qgb25lLlxuICAgICAgICBpZiAodGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dEcmFnQnV0dG9ucykgdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzLmFkZCh0aGlzLmNvbHVtbnNbMl0ua2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMucm93SGVhZGVyQ29sdW1uS2V5cy5hZGQodGhpcy5jb2x1bW5zWzFdLmtleSk7XG4gICAgICAgICAgICB9IGVsc2UgdGhpcy5yb3dIZWFkZXJDb2x1bW5LZXlzLmFkZCh0aGlzLmNvbHVtbnNbMF0ua2V5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbmNvbnN0ICQ0YTBkZDAzNmQ0OTJjZWU0JHZhciRPUFBPU0lURV9TT1JUX0RJUkVDVElPTiA9IHtcbiAgICBhc2NlbmRpbmc6IFwiZGVzY2VuZGluZ1wiLFxuICAgIGRlc2NlbmRpbmc6IFwiYXNjZW5kaW5nXCJcbn07XG5mdW5jdGlvbiAkNGEwZGQwMzZkNDkyY2VlNCRleHBvcnQkOTA3YmNjNmM0ODMyNWZkNihwcm9wcykge1xuICAgIGxldCBbaXNLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZCwgc2V0S2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWRdID0gKDAsICQxQmZqVyR1c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGxldCB7IHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUgPSBcIm5vbmVcIiwgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHNob3dTZWxlY3Rpb25DaGVja2JveGVzLCBzaG93RHJhZ0J1dHRvbnM6IHNob3dEcmFnQnV0dG9ucyB9ID0gcHJvcHM7XG4gICAgbGV0IGNvbnRleHQgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXM6IHNob3dTZWxlY3Rpb25DaGVja2JveGVzICYmIHNlbGVjdGlvbk1vZGUgIT09IFwibm9uZVwiLFxuICAgICAgICAgICAgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMsXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLFxuICAgICAgICAgICAgY29sdW1uczogW11cbiAgICAgICAgfSksIFtcbiAgICAgICAgcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzLFxuICAgICAgICBzZWxlY3Rpb25Nb2RlLFxuICAgICAgICBzaG93RHJhZ0J1dHRvbnNcbiAgICBdKTtcbiAgICBsZXQgY29sbGVjdGlvbiA9ICgwLCAkMUJmalckdXNlQ29sbGVjdGlvbikocHJvcHMsICgwLCAkMUJmalckdXNlQ2FsbGJhY2spKChub2Rlcyk9Pm5ldyAoMCwgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDU5NmUxYjJlMmNmOTM2OTApKG5vZGVzLCBudWxsLCBjb250ZXh0KSwgW1xuICAgICAgICBjb250ZXh0XG4gICAgXSksIGNvbnRleHQpO1xuICAgIGxldCB7IGRpc2FibGVkS2V5czogZGlzYWJsZWRLZXlzLCBzZWxlY3Rpb25NYW5hZ2VyOiBzZWxlY3Rpb25NYW5hZ2VyIH0gPSAoMCwgJDFCZmpXJHVzZUdyaWRTdGF0ZSkoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgZGlzYWJsZWRCZWhhdmlvcjogcHJvcHMuZGlzYWJsZWRCZWhhdmlvciB8fCBcInNlbGVjdGlvblwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgZGlzYWJsZWRLZXlzOiBkaXNhYmxlZEtleXMsXG4gICAgICAgIHNlbGVjdGlvbk1hbmFnZXI6IHNlbGVjdGlvbk1hbmFnZXIsXG4gICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBwcm9wcy5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcyB8fCBmYWxzZSxcbiAgICAgICAgc29ydERlc2NyaXB0b3I6IHByb3BzLnNvcnREZXNjcmlwdG9yLFxuICAgICAgICBpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkOiBjb2xsZWN0aW9uLnNpemUgPT09IDAgfHwgaXNLZXlib2FyZE5hdmlnYXRpb25EaXNhYmxlZCxcbiAgICAgICAgc2V0S2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQ6IHNldEtleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkLFxuICAgICAgICBzb3J0IChjb2x1bW5LZXksIGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdmFyIF9wcm9wc19zb3J0RGVzY3JpcHRvcjtcbiAgICAgICAgICAgIHByb3BzLm9uU29ydENoYW5nZSh7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5LZXksXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24gIT09IG51bGwgJiYgZGlyZWN0aW9uICE9PSB2b2lkIDAgPyBkaXJlY3Rpb24gOiAoKF9wcm9wc19zb3J0RGVzY3JpcHRvciA9IHByb3BzLnNvcnREZXNjcmlwdG9yKSA9PT0gbnVsbCB8fCBfcHJvcHNfc29ydERlc2NyaXB0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcm9wc19zb3J0RGVzY3JpcHRvci5jb2x1bW4pID09PSBjb2x1bW5LZXkgPyAkNGEwZGQwMzZkNDkyY2VlNCR2YXIkT1BQT1NJVEVfU09SVF9ESVJFQ1RJT05bcHJvcHMuc29ydERlc2NyaXB0b3IuZGlyZWN0aW9uXSA6IFwiYXNjZW5kaW5nXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkMzEyYWUzYjU2YTk0YTg2ZSR2YXIkVGFibGVIZWFkZXIocHJvcHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbiQzMTJhZTNiNTZhOTRhODZlJHZhciRUYWJsZUhlYWRlci5nZXRDb2xsZWN0aW9uTm9kZSA9IGZ1bmN0aW9uKiBnZXRDb2xsZWN0aW9uTm9kZShwcm9wcywgY29udGV4dCkge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgY29sdW1uczogY29sdW1ucyB9ID0gcHJvcHM7XG4gICAgLy8gQ2xlYXIgY29sdW1ucyBzbyB0aGV5IGFyZW4ndCBkb3VibGUgYWRkZWQgaW4gc3RyaWN0IG1vZGUuXG4gICAgY29udGV4dC5jb2x1bW5zID0gW107XG4gICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghY29sdW1ucykgdGhyb3cgbmV3IEVycm9yKFwicHJvcHMuY2hpbGRyZW4gd2FzIGEgZnVuY3Rpb24gYnV0IHByb3BzLmNvbHVtbnMgaXMgbWlzc2luZ1wiKTtcbiAgICAgICAgZm9yIChsZXQgY29sdW1uIG9mIGNvbHVtbnMpeWllbGQge1xuICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBjb2x1bW4sXG4gICAgICAgICAgICByZW5kZXJlcjogY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY29sdW1ucyA9IFtdO1xuICAgICAgICAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY29sdW1uKT0+e1xuICAgICAgICAgICAgY29sdW1ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGNvbHVtblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB5aWVsZCogY29sdW1ucztcbiAgICB9XG59O1xuLyoqXG4gKiBBIFRhYmxlSGVhZGVyIGlzIGEgY29udGFpbmVyIGZvciB0aGUgQ29sdW1uIGVsZW1lbnRzIGluIGEgVGFibGUuIENvbHVtbnMgY2FuIGJlIHN0YXRpY2FsbHkgZGVmaW5lZFxuICogYXMgY2hpbGRyZW4sIG9yIGdlbmVyYXRlZCBkeW5hbWljYWxseSB1c2luZyBhIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBkYXRhIHBhc3NlZCB0byB0aGUgYGNvbHVtbnNgIHByb3AuXG4gKi8gLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkMzEyYWUzYjU2YTk0YTg2ZSRleHBvcnQkZjg1MDg5NWIyODdlZjI4ZSA9ICQzMTJhZTNiNTZhOTRhODZlJHZhciRUYWJsZUhlYWRlcjtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNGFlNTMxNGJmNTBkYjFhMyR2YXIkVGFibGVCb2R5KHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kNGFlNTMxNGJmNTBkYjFhMyR2YXIkVGFibGVCb2R5LmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzKSB7XG4gICAgbGV0IHsgY2hpbGRyZW46IGNoaWxkcmVuLCBpdGVtczogaXRlbXMgfSA9IHByb3BzO1xuICAgIHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJib2R5XCIsXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6IHRydWUsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgKmNoaWxkTm9kZXMgKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtcykgdGhyb3cgbmV3IEVycm9yKFwicHJvcHMuY2hpbGRyZW4gd2FzIGEgZnVuY3Rpb24gYnV0IHByb3BzLml0ZW1zIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcyl5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXI6IGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgKDAsICQxQmZqVyRyZWFjdCkuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGl0ZW0pPT57XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBpdGVtXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBpdGVtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBBIFRhYmxlQm9keSBpcyBhIGNvbnRhaW5lciBmb3IgdGhlIFJvdyBlbGVtZW50cyBvZiBhIFRhYmxlLiBSb3dzIGNhbiBiZSBzdGF0aWNhbGx5IGRlZmluZWRcbiAqIGFzIGNoaWxkcmVuLCBvciBnZW5lcmF0ZWQgZHluYW1pY2FsbHkgdXNpbmcgYSBmdW5jdGlvbiBiYXNlZCBvbiB0aGUgZGF0YSBwYXNzZWQgdG8gdGhlIGBpdGVtc2AgcHJvcC5cbiAqLyAvLyBXZSBkb24ndCB3YW50IGdldENvbGxlY3Rpb25Ob2RlIHRvIHNob3cgdXAgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxubGV0ICQ0YWU1MzE0YmY1MGRiMWEzJGV4cG9ydCQ3NmNjZDIxMGI5MDI5OTE3ID0gJDRhZTUzMTRiZjUwZGIxYTMkdmFyJFRhYmxlQm9keTtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkMWNkMjQ0NTU3YzJmOTdkNSR2YXIkQ29sdW1uKHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kMWNkMjQ0NTU3YzJmOTdkNSR2YXIkQ29sdW1uLmdldENvbGxlY3Rpb25Ob2RlID0gZnVuY3Rpb24qIGdldENvbGxlY3Rpb25Ob2RlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgdGl0bGU6IHRpdGxlLCBjaGlsZHJlbjogY2hpbGRyZW4sIGNoaWxkQ29sdW1uczogY2hpbGRDb2x1bW5zIH0gPSBwcm9wcztcbiAgICBsZXQgcmVuZGVyZWQgPSB0aXRsZSB8fCBjaGlsZHJlbjtcbiAgICBsZXQgdGV4dFZhbHVlID0gcHJvcHMudGV4dFZhbHVlIHx8ICh0eXBlb2YgcmVuZGVyZWQgPT09IFwic3RyaW5nXCIgPyByZW5kZXJlZCA6IFwiXCIpIHx8IHByb3BzW1wiYXJpYS1sYWJlbFwiXTtcbiAgICBsZXQgZnVsbE5vZGVzID0geWllbGQge1xuICAgICAgICB0eXBlOiBcImNvbHVtblwiLFxuICAgICAgICBoYXNDaGlsZE5vZGVzOiAhIWNoaWxkQ29sdW1ucyB8fCB0aXRsZSAmJiAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPiAwLFxuICAgICAgICByZW5kZXJlZDogcmVuZGVyZWQsXG4gICAgICAgIHRleHRWYWx1ZTogdGV4dFZhbHVlLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICpjaGlsZE5vZGVzICgpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZENvbHVtbnMpIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkQ29sdW1ucyl5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2hpbGRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbHNlIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZENvbHVtbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAoMCwgJDFCZmpXJHJlYWN0KS5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpPT57XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ29sdW1ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBjaGlsZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB5aWVsZCogY2hpbGRDb2x1bW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaG91bGRJbnZhbGlkYXRlIChuZXdDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjaywgYnV0IGl0IHdvcmtzLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB0aGVuIHRoZXJlJ3MgYSBjYWNoZWQgdmVyc2lvbiBvZiB0aGlzIG5vZGUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgLy8gQnV0LCB3ZSBuZWVkIHRvIGtlZXAgdGhlIGxpc3Qgb2YgY29sdW1ucyBpbiB0aGUgbmV3IGNvbnRleHQgdXAgdG8gZGF0ZS5cbiAgICAgICAgICAgIHVwZGF0ZUNvbnRleHQobmV3Q29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCB1cGRhdGVDb250ZXh0ID0gKGNvbnRleHQpPT57XG4gICAgICAgIC8vIHJlZ2lzdGVyIGxlYWYgY29sdW1ucyBvbiB0aGUgY29udGV4dCBzbyB0aGF0IDxSb3c+IGNhbiBhY2Nlc3MgdGhlbVxuICAgICAgICBmb3IgKGxldCBub2RlIG9mIGZ1bGxOb2RlcylpZiAoIW5vZGUuaGFzQ2hpbGROb2RlcykgY29udGV4dC5jb2x1bW5zLnB1c2gobm9kZSk7XG4gICAgfTtcbiAgICB1cGRhdGVDb250ZXh0KGNvbnRleHQpO1xufTtcbi8qKlxuICogQSBDb2x1bW4gcmVwcmVzZW50cyBhIGZpZWxkIG9mIGVhY2ggaXRlbSB3aXRoaW4gYSBUYWJsZS4gQ29sdW1ucyBtYXkgYWxzbyBjb250YWluIG5lc3RlZFxuICogQ29sdW1uIGVsZW1lbnRzIHRvIHJlcHJlc2VudCBjb2x1bW4gZ3JvdXBzLiBOZXN0ZWQgY29sdW1ucyBjYW4gYmUgc3RhdGljYWxseSBkZWZpbmVkIGFzXG4gKiBjaGlsZHJlbiwgb3IgZHluYW1pY2FsbHkgZ2VuZXJhdGVkIHVzaW5nIGEgZnVuY3Rpb24gYmFzZWQgb24gdGhlIGBjaGlsZENvbHVtbnNgIHByb3AuXG4gKi8gLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkMWNkMjQ0NTU3YzJmOTdkNSRleHBvcnQkODE2YjVkODExMjk1ZTZiYyA9ICQxY2QyNDQ1NTdjMmY5N2Q1JHZhciRDb2x1bW47XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDcwZDcwZWIxNmVhNDg0MjgkdmFyJFJvdyhwcm9wcykge1xuICAgIHJldHVybiBudWxsO1xufVxuJDcwZDcwZWIxNmVhNDg0MjgkdmFyJFJvdy5nZXRDb2xsZWN0aW9uTm9kZSA9IGZ1bmN0aW9uKiBnZXRDb2xsZWN0aW9uTm9kZShwcm9wcywgY29udGV4dCkge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsIFVOU1RBQkxFX2NoaWxkSXRlbXM6IFVOU1RBQkxFX2NoaWxkSXRlbXMgfSA9IHByb3BzO1xuICAgIHlpZWxkIHtcbiAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwcm9wc1tcImFyaWEtbGFiZWxcIl0sXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6IHRydWUsXG4gICAgICAgICpjaGlsZE5vZGVzICgpIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgY2VsbHMgZmlyc3RcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnNob3dEcmFnQnV0dG9ucykgeWllbGQge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICAgICAgICAgIGtleTogXCJoZWFkZXItZHJhZ1wiLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzRHJhZ0J1dHRvbkNlbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgJiYgY29udGV4dC5zZWxlY3Rpb25Nb2RlICE9PSBcIm5vbmVcIikgeWllbGQge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICAgICAgICAgIGtleTogXCJoZWFkZXJcIixcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGlvbkNlbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29sdW1uIG9mIGNvbnRleHQuY29sdW1ucyl5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBjaGlsZHJlbihjb2x1bW4ua2V5KSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBjb2x1bW4ua2V5IC8vIHRoaXMgaXMgY29tYmluZWQgd2l0aCB0aGUgcm93IGtleSBieSBDb2xsZWN0aW9uQnVpbGRlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKFVOU1RBQkxFX2NoaWxkSXRlbXMpIGZvciAobGV0IGNoaWxkIG9mIFVOU1RBQkxFX2NoaWxkSXRlbXMpLy8gTm90ZTogaW4gb3JkZXIgdG8gcmV1c2UgdGhlIHJlbmRlciBmdW5jdGlvbiBvZiBUYWJsZUJvZHkgZm9yIG91ciBjaGlsZCByb3dzLCB3ZSBqdXN0IG5lZWQgdG8geWllbGQgYSB0eXBlIGFuZCBhIHZhbHVlIGhlcmUuIENvbGxlY3Rpb25CdWlsZGVyIHdpbGwgdGhlbiBsb29rIHVwXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhcmVudCByZW5kZXJlciBhbmQgdXNlIHRoYXQgdG8gYnVpbGQgdGhlIGZ1bGwgbm9kZSBvZiB0aGlzIGNoaWxkIHJvdywgdXNpbmcgdGhlIHZhbHVlIHByb3ZpZGVkIGhlcmUgdG8gZ2VuZXJhdGUgdGhlIGNlbGxzXG4gICAgICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIml0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoaWxkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNlbGxzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkUm93cyA9IFtdO1xuICAgICAgICAgICAgICAgICgwLCAkMUJmalckcmVhY3QpLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChub2RlKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAkNzBkNzBlYjE2ZWE0ODQyOCR2YXIkUm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbHMubGVuZ3RoIDwgY29udGV4dC5jb2x1bW5zLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiQWxsIG9mIGEgUm93J3MgY2hpbGQgQ2VsbHMgbXVzdCBiZSBwb3NpdGlvbmVkIGJlZm9yZSBhbnkgY2hpbGQgUm93cy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFJvd3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBjZWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogbm9kZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbHMubGVuZ3RoICE9PSBjb250ZXh0LmNvbHVtbnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoYENlbGwgY291bnQgbXVzdCBtYXRjaCBjb2x1bW4gY291bnQuIEZvdW5kICR7Y2VsbHMubGVuZ3RofSBjZWxscyBhbmQgJHtjb250ZXh0LmNvbHVtbnMubGVuZ3RofSBjb2x1bW5zLmApO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBjZWxscztcbiAgICAgICAgICAgICAgICB5aWVsZCogY2hpbGRSb3dzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaG91bGRJbnZhbGlkYXRlIChuZXdDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIGFsbCByb3dzIGlmIHRoZSBjb2x1bW5zIGNoYW5nZWQuXG4gICAgICAgICAgICByZXR1cm4gbmV3Q29udGV4dC5jb2x1bW5zLmxlbmd0aCAhPT0gY29udGV4dC5jb2x1bW5zLmxlbmd0aCB8fCBuZXdDb250ZXh0LmNvbHVtbnMuc29tZSgoYywgaSk9PmMua2V5ICE9PSBjb250ZXh0LmNvbHVtbnNbaV0ua2V5KSB8fCBuZXdDb250ZXh0LnNob3dTZWxlY3Rpb25DaGVja2JveGVzICE9PSBjb250ZXh0LnNob3dTZWxlY3Rpb25DaGVja2JveGVzIHx8IG5ld0NvbnRleHQuc2hvd0RyYWdCdXR0b25zICE9PSBjb250ZXh0LnNob3dEcmFnQnV0dG9ucyB8fCBuZXdDb250ZXh0LnNlbGVjdGlvbk1vZGUgIT09IGNvbnRleHQuc2VsZWN0aW9uTW9kZTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBBIFJvdyByZXByZXNlbnRzIGEgc2luZ2xlIGl0ZW0gaW4gYSBUYWJsZSBhbmQgY29udGFpbnMgQ2VsbCBlbGVtZW50cyBmb3IgZWFjaCBjb2x1bW4uXG4gKiBDZWxscyBjYW4gYmUgc3RhdGljYWxseSBkZWZpbmVkIGFzIGNoaWxkcmVuLCBvciBnZW5lcmF0ZWQgZHluYW1pY2FsbHkgdXNpbmcgYSBmdW5jdGlvblxuICogYmFzZWQgb24gdGhlIGNvbHVtbnMgZGVmaW5lZCBpbiB0aGUgVGFibGVIZWFkZXIuXG4gKi8gLy8gV2UgZG9uJ3Qgd2FudCBnZXRDb2xsZWN0aW9uTm9kZSB0byBzaG93IHVwIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbmxldCAkNzBkNzBlYjE2ZWE0ODQyOCRleHBvcnQkYjU5YmRiZWY5Y2U3MGRlMiA9ICQ3MGQ3MGViMTZlYTQ4NDI4JHZhciRSb3c7XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ5NDFkMWQ5YTZhMjg5ODJhJHZhciRDZWxsKHByb3BzKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4kOTQxZDFkOWE2YTI4OTgyYSR2YXIkQ2VsbC5nZXRDb2xsZWN0aW9uTm9kZSA9IGZ1bmN0aW9uKiBnZXRDb2xsZWN0aW9uTm9kZShwcm9wcykge1xuICAgIGxldCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gICAgbGV0IHRleHRWYWx1ZSA9IHByb3BzLnRleHRWYWx1ZSB8fCAodHlwZW9mIGNoaWxkcmVuID09PSBcInN0cmluZ1wiID8gY2hpbGRyZW4gOiBcIlwiKSB8fCBwcm9wc1tcImFyaWEtbGFiZWxcIl0gfHwgXCJcIjtcbiAgICB5aWVsZCB7XG4gICAgICAgIHR5cGU6IFwiY2VsbFwiLFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlbixcbiAgICAgICAgdGV4dFZhbHVlOiB0ZXh0VmFsdWUsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwcm9wc1tcImFyaWEtbGFiZWxcIl0sXG4gICAgICAgIGhhc0NoaWxkTm9kZXM6IGZhbHNlXG4gICAgfTtcbn07XG4vKipcbiAqIEEgQ2VsbCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZiBhIHNpbmdsZSBDb2x1bW4gd2l0aGluIGEgVGFibGUgUm93LlxuICovIC8vIFdlIGRvbid0IHdhbnQgZ2V0Q29sbGVjdGlvbk5vZGUgdG8gc2hvdyB1cCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG5sZXQgJDk0MWQxZDlhNmEyODk4MmEkZXhwb3J0JGY2ZjBjM2ZlNGVjMzA2ZWEgPSAkOTQxZDFkOWE2YTI4OTgyYSR2YXIkQ2VsbDtcblxuXG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjMgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cblxuXG5cblxuZnVuY3Rpb24gJGVlNjVhMDA1N2ZkOTk1MzEkZXhwb3J0JDM0ZGZhOGExNjIyMTg1YTQocHJvcHMpIHtcbiAgICBsZXQgeyBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlID0gXCJub25lXCIsIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcywgc2hvd0RyYWdCdXR0b25zOiBzaG93RHJhZ0J1dHRvbnMsIFVOU1RBQkxFX2V4cGFuZGVkS2V5czogcHJvcEV4cGFuZGVkS2V5cywgVU5TVEFCTEVfZGVmYXVsdEV4cGFuZGVkS2V5czogcHJvcERlZmF1bHRFeHBhbmRlZEtleXMsIFVOU1RBQkxFX29uRXhwYW5kZWRDaGFuZ2U6IFVOU1RBQkxFX29uRXhwYW5kZWRDaGFuZ2UsIGNoaWxkcmVuOiBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gICAgaWYgKCEoMCwgJDFCZmpXJHRhYmxlTmVzdGVkUm93cykoKSkgdGhyb3cgbmV3IEVycm9yKFwiRmVhdHVyZSBmbGFnIGZvciB0YWJsZSBuZXN0ZWQgcm93cyBtdXN0IGJlIGVuYWJsZWQgdG8gdXNlIHVzZVRyZWVHcmlkU3RhdGUuXCIpO1xuICAgIGxldCBbZXhwYW5kZWRLZXlzLCBzZXRFeHBhbmRlZEtleXNdID0gKDAsICQxQmZqVyR1c2VDb250cm9sbGVkU3RhdGUpKHByb3BFeHBhbmRlZEtleXMgPyAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkY29udmVydEV4cGFuZGVkKHByb3BFeHBhbmRlZEtleXMpIDogdW5kZWZpbmVkLCBwcm9wRGVmYXVsdEV4cGFuZGVkS2V5cyA/ICRlZTY1YTAwNTdmZDk5NTMxJHZhciRjb252ZXJ0RXhwYW5kZWQocHJvcERlZmF1bHRFeHBhbmRlZEtleXMpIDogbmV3IFNldCgpLCBVTlNUQUJMRV9vbkV4cGFuZGVkQ2hhbmdlKTtcbiAgICBsZXQgY29udGV4dCA9ICgwLCAkMUJmalckdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICBzaG93U2VsZWN0aW9uQ2hlY2tib3hlczogc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMgJiYgc2VsZWN0aW9uTW9kZSAhPT0gXCJub25lXCIsXG4gICAgICAgICAgICBzaG93RHJhZ0J1dHRvbnM6IHNob3dEcmFnQnV0dG9ucyxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsXG4gICAgICAgICAgICBjb2x1bW5zOiBbXVxuICAgICAgICB9KSwgW1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsXG4gICAgICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgICAgIHNob3dEcmFnQnV0dG9uc1xuICAgIF0pO1xuICAgIGxldCBidWlsZGVyID0gKDAsICQxQmZqVyR1c2VNZW1vKSgoKT0+bmV3ICgwLCAkMUJmalckQ29sbGVjdGlvbkJ1aWxkZXIpKCksIFtdKTtcbiAgICBsZXQgbm9kZXMgPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT5idWlsZGVyLmJ1aWxkKHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9LCBjb250ZXh0KSwgW1xuICAgICAgICBidWlsZGVyLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgY29udGV4dFxuICAgIF0pO1xuICAgIGxldCB0cmVlR3JpZENvbGxlY3Rpb24gPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT57XG4gICAgICAgIHJldHVybiAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkZ2VuZXJhdGVUcmVlR3JpZENvbGxlY3Rpb24obm9kZXMsIHtcbiAgICAgICAgICAgIHNob3dTZWxlY3Rpb25DaGVja2JveGVzOiBzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyxcbiAgICAgICAgICAgIHNob3dEcmFnQnV0dG9uczogc2hvd0RyYWdCdXR0b25zLFxuICAgICAgICAgICAgZXhwYW5kZWRLZXlzOiBleHBhbmRlZEtleXNcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBub2RlcyxcbiAgICAgICAgc2hvd1NlbGVjdGlvbkNoZWNrYm94ZXMsXG4gICAgICAgIHNob3dEcmFnQnV0dG9ucyxcbiAgICAgICAgZXhwYW5kZWRLZXlzXG4gICAgXSk7XG4gICAgbGV0IG9uVG9nZ2xlID0gKGtleSk9PntcbiAgICAgICAgc2V0RXhwYW5kZWRLZXlzKCRlZTY1YTAwNTdmZDk5NTMxJHZhciR0b2dnbGVLZXkoZXhwYW5kZWRLZXlzLCBrZXksIHRyZWVHcmlkQ29sbGVjdGlvbikpO1xuICAgIH07XG4gICAgbGV0IGNvbGxlY3Rpb24gPSAoMCwgJDFCZmpXJHVzZU1lbW8pKCgpPT57XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ1OTZlMWIyZTJjZjkzNjkwKSh0cmVlR3JpZENvbGxlY3Rpb24udGFibGVOb2RlcywgbnVsbCwgY29udGV4dCk7XG4gICAgfSwgW1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICB0cmVlR3JpZENvbGxlY3Rpb24udGFibGVOb2Rlc1xuICAgIF0pO1xuICAgIGxldCB0YWJsZVN0YXRlID0gKDAsICQ0YTBkZDAzNmQ0OTJjZWU0JGV4cG9ydCQ5MDdiY2M2YzQ4MzI1ZmQ2KSh7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGFibGVTdGF0ZSxcbiAgICAgICAga2V5TWFwOiB0cmVlR3JpZENvbGxlY3Rpb24ua2V5TWFwLFxuICAgICAgICB1c2VyQ29sdW1uQ291bnQ6IHRyZWVHcmlkQ29sbGVjdGlvbi51c2VyQ29sdW1uQ291bnQsXG4gICAgICAgIGV4cGFuZGVkS2V5czogZXhwYW5kZWRLZXlzLFxuICAgICAgICB0b2dnbGVLZXk6IG9uVG9nZ2xlXG4gICAgfTtcbn1cbmZ1bmN0aW9uICRlZTY1YTAwNTdmZDk5NTMxJHZhciR0b2dnbGVLZXkoY3VycmVudEV4cGFuZGVkS2V5cywga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgbGV0IHVwZGF0ZWRFeHBhbmRlZEtleXM7XG4gICAgaWYgKGN1cnJlbnRFeHBhbmRlZEtleXMgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgdXBkYXRlZEV4cGFuZGVkS2V5cyA9IG5ldyBTZXQoY29sbGVjdGlvbi5mbGF0dGVuZWRSb3dzLmZpbHRlcigocm93KT0+cm93LnByb3BzLlVOU1RBQkxFX2NoaWxkSXRlbXMgfHwgcm93LnByb3BzLmNoaWxkcmVuLmxlbmd0aCA+IGNvbGxlY3Rpb24udXNlckNvbHVtbkNvdW50KS5tYXAoKHJvdyk9PnJvdy5rZXkpKTtcbiAgICAgICAgdXBkYXRlZEV4cGFuZGVkS2V5cy5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVkRXhwYW5kZWRLZXlzID0gbmV3IFNldChjdXJyZW50RXhwYW5kZWRLZXlzKTtcbiAgICAgICAgaWYgKHVwZGF0ZWRFeHBhbmRlZEtleXMuaGFzKGtleSkpIHVwZGF0ZWRFeHBhbmRlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGVsc2UgdXBkYXRlZEV4cGFuZGVkS2V5cy5hZGQoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZWRFeHBhbmRlZEtleXM7XG59XG5mdW5jdGlvbiAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkY29udmVydEV4cGFuZGVkKGV4cGFuZGVkKSB7XG4gICAgaWYgKCFleHBhbmRlZCkgcmV0dXJuIG5ldyBTZXQoKTtcbiAgICByZXR1cm4gZXhwYW5kZWQgPT09IFwiYWxsXCIgPyBcImFsbFwiIDogbmV3IFNldChleHBhbmRlZCk7XG59XG5mdW5jdGlvbiAkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkZ2VuZXJhdGVUcmVlR3JpZENvbGxlY3Rpb24obm9kZXMsIG9wdHMpIHtcbiAgICBsZXQgeyBleHBhbmRlZEtleXM6IGV4cGFuZGVkS2V5cyA9IG5ldyBTZXQoKSB9ID0gb3B0cztcbiAgICBsZXQgYm9keTtcbiAgICBsZXQgZmxhdHRlbmVkUm93cyA9IFtdO1xuICAgIGxldCBjb2x1bW5Db3VudCA9IDA7XG4gICAgbGV0IHVzZXJDb2x1bW5Db3VudCA9IDA7XG4gICAgbGV0IG9yaWdpbmFsQ29sdW1ucyA9IFtdO1xuICAgIGxldCBrZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zaG93U2VsZWN0aW9uQ2hlY2tib3hlcykgY29sdW1uQ291bnQrKztcbiAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNob3dEcmFnQnV0dG9ucykgY29sdW1uQ291bnQrKztcbiAgICBsZXQgdG9wTGV2ZWxSb3dzID0gW107XG4gICAgbGV0IHZpc2l0ID0gKG5vZGUpPT57XG4gICAgICAgIHN3aXRjaChub2RlLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICBib2R5ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBrZXlNYXAuc2V0KGJvZHkua2V5LCBib2R5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjb2x1bW5cIjpcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaGFzQ2hpbGROb2RlcykgdXNlckNvbHVtbkNvdW50Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaXRlbVwiOlxuICAgICAgICAgICAgICAgIHRvcExldmVsUm93cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpdmlzaXQoY2hpbGQpO1xuICAgIH07XG4gICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcyl7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiY29sdW1uXCIpIG9yaWdpbmFsQ29sdW1ucy5wdXNoKG5vZGUpO1xuICAgICAgICB2aXNpdChub2RlKTtcbiAgICB9XG4gICAgY29sdW1uQ291bnQgKz0gdXNlckNvbHVtbkNvdW50O1xuICAgIC8vIFVwZGF0ZSBlYWNoIGdyaWQgbm9kZSBpbiB0aGUgdHJlZWdyaWQgdGFibGUgd2l0aCB2YWx1ZXMgc3BlY2lmaWMgdG8gYSB0cmVlZ3JpZCBzdHJ1Y3R1cmUuIEFsc28gc3RvcmUgYSBzZXQgb2YgZmxhdHRlbmVkIHJvdyBub2RlcyBmb3IgVGFibGVDb2xsZWN0aW9uIHRvIGNvbnN1bWVcbiAgICBsZXQgZ2xvYmFsUm93Q291bnQgPSAwO1xuICAgIGxldCB2aXNpdE5vZGUgPSAobm9kZSwgaSk9PntcbiAgICAgICAgLy8gQ2xvbmUgcm93IG5vZGUgYW5kIGl0cyBjaGlsZHJlbiBzbyBtb2RpZmljYXRpb25zIHRvIHRoZSBub2RlIGZvciB0cmVlZ3JpZCBzcGVjaWZpYyB2YWx1ZXMgYXJlbid0IGFwcGxpZWQgb24gdGhlIG5vZGVzIHByb3ZpZGVkXG4gICAgICAgIC8vIHRvIFRhYmxlQ29sbGVjdGlvbi4gSW5kZXgsIGxldmVsLCBhbmQgcGFyZW50IGtleXMgYXJlIGFsbCBjaGFuZ2VkIHRvIHJlZmxlY3QgYSBmbGF0dGVuZWQgcm93IHN0cnVjdHVyZSByYXRoZXIgdGhhbiB0aGUgdHJlZWdyaWQgc3RydWN0dXJlXG4gICAgICAgIC8vIHZhbHVlcyBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgdmlhIENvbGxlY3Rpb25CdWlsZGVyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiaXRlbVwiKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKWlmIChjaGlsZC50eXBlID09PSBcImNlbGxcIikge1xuICAgICAgICAgICAgICAgIGxldCBjZWxsQ2xvbmUgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbENsb25lLmluZGV4ICsgMSA9PT0gY29sdW1uQ291bnQpIGNlbGxDbG9uZS5uZXh0S2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAuLi5jZWxsQ2xvbmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjbG9uZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZXMsXG4gICAgICAgICAgICAgICAgcGFyZW50S2V5OiBib2R5LmtleSxcbiAgICAgICAgICAgICAgICBsZXZlbDogMSxcbiAgICAgICAgICAgICAgICBpbmRleDogZ2xvYmFsUm93Q291bnQrK1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZsYXR0ZW5lZFJvd3MucHVzaChjbG9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1Byb3BzID0ge307XG4gICAgICAgIC8vIEFzc2lnbiBpbmRleE9mVHlwZSB0byBjZWxscyBhbmQgcm93cyBmb3IgYXJpYS1wb3NpbnNldFxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSBcInBsYWNlaG9sZGVyXCIgJiYgbm9kZS50eXBlICE9PSBcImNvbHVtblwiKSBuZXdQcm9wc1tcImluZGV4T2ZUeXBlXCJdID0gaTtcbiAgICAgICAgLy8gVXNlIE9iamVjdC5hc3NpZ24gaW5zdGVhZCBvZiBzcHJlYWQgdG8gcHJlc2VydmUgb2JqZWN0IHJlZmVyZW5jZSBmb3Iga2V5TWFwLiBBbHNvIGVuc3VyZXMgcmV0cmlldmluZyBub2Rlc1xuICAgICAgICAvLyB2aWEgLmNoaWxkTm9kZXMgcmV0dXJucyB0aGUgc2FtZSBvYmplY3QgYXMgdGhlIG9uZSBmb3VuZCB2aWEga2V5TWFwIGxvb2sgdXBcbiAgICAgICAgT2JqZWN0LmFzc2lnbihub2RlLCBuZXdQcm9wcyk7XG4gICAgICAgIGtleU1hcC5zZXQobm9kZS5rZXksIG5vZGUpO1xuICAgICAgICBsZXQgbGFzdE5vZGU7XG4gICAgICAgIGxldCByb3dJbmRleCA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2RlcylpZiAoIShjaGlsZC50eXBlID09PSBcIml0ZW1cIiAmJiBleHBhbmRlZEtleXMgIT09IFwiYWxsXCIgJiYgIWV4cGFuZGVkS2V5cy5oYXMobm9kZS5rZXkpKSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudEtleSA9PSBudWxsKSAvLyBpZiBjaGlsZCBpcyBhIGNlbGwvZXhwYW5kZWQgcm93L2NvbHVtbiBhbmQgdGhlIHBhcmVudCBrZXkgaXNuJ3QgYWxyZWFkeSBlc3RhYmxpc2hlZCBieSB0aGUgY29sbGVjdGlvbiwgbWF0Y2ggY2hpbGQgbm9kZSB0byBwYXJlbnQgcm93XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnRLZXkgPSBub2RlLmtleTtcbiAgICAgICAgICAgIGlmIChsYXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGxhc3ROb2RlLm5leHRLZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJldktleSA9IGxhc3ROb2RlLmtleTtcbiAgICAgICAgICAgIH0gZWxzZSBjaGlsZC5wcmV2S2V5ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcIml0ZW1cIikgdmlzaXROb2RlKGNoaWxkLCByb3dJbmRleCsrKTtcbiAgICAgICAgICAgIGVsc2UgLy8gV2UgZW5mb3JjZSB0aGF0IHRoZSBjZWxscyBjb21lIGJlZm9yZSByb3dzIHNvIGNhbiBqdXN0IHJldXNlIGNlbGwgaW5kZXhcbiAgICAgICAgICAgIHZpc2l0Tm9kZShjaGlsZCwgY2hpbGQuaW5kZXgpO1xuICAgICAgICAgICAgbGFzdE5vZGUgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdE5vZGUpIGxhc3ROb2RlLm5leHRLZXkgPSBudWxsO1xuICAgIH07XG4gICAgbGV0IGxhc3Q7XG4gICAgdG9wTGV2ZWxSb3dzLmZvckVhY2goKG5vZGUsIGkpPT57XG4gICAgICAgIHZpc2l0Tm9kZShub2RlLCBpKTtcbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QubmV4dEtleSA9IG5vZGUua2V5O1xuICAgICAgICAgICAgbm9kZS5wcmV2S2V5ID0gbGFzdC5rZXk7XG4gICAgICAgIH0gZWxzZSBub2RlLnByZXZLZXkgPSBudWxsO1xuICAgICAgICBsYXN0ID0gbm9kZTtcbiAgICB9KTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0S2V5ID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXlNYXA6IGtleU1hcCxcbiAgICAgICAgdXNlckNvbHVtbkNvdW50OiB1c2VyQ29sdW1uQ291bnQsXG4gICAgICAgIGZsYXR0ZW5lZFJvd3M6IGZsYXR0ZW5lZFJvd3MsXG4gICAgICAgIHRhYmxlTm9kZXM6IFtcbiAgICAgICAgICAgIC4uLm9yaWdpbmFsQ29sdW1ucyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi5ib2R5LFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IGZsYXR0ZW5lZFJvd3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH07XG59XG5cblxuXG5cbmV4cG9ydCB7JDI5MmJjNGUwOWNkMGViNjIkZXhwb3J0JGNiODk1ZGNmODVkYjEzMTkgYXMgdXNlVGFibGVDb2x1bW5SZXNpemVTdGF0ZSwgJDRhMGRkMDM2ZDQ5MmNlZTQkZXhwb3J0JDkwN2JjYzZjNDgzMjVmZDYgYXMgdXNlVGFibGVTdGF0ZSwgJDMxMmFlM2I1NmE5NGE4NmUkZXhwb3J0JGY4NTA4OTViMjg3ZWYyOGUgYXMgVGFibGVIZWFkZXIsICQ0YWU1MzE0YmY1MGRiMWEzJGV4cG9ydCQ3NmNjZDIxMGI5MDI5OTE3IGFzIFRhYmxlQm9keSwgJDFjZDI0NDU1N2MyZjk3ZDUkZXhwb3J0JDgxNmI1ZDgxMTI5NWU2YmMgYXMgQ29sdW1uLCAkNzBkNzBlYjE2ZWE0ODQyOCRleHBvcnQkYjU5YmRiZWY5Y2U3MGRlMiBhcyBSb3csICQ5NDFkMWQ5YTZhMjg5ODJhJGV4cG9ydCRmNmYwYzNmZTRlYzMwNmVhIGFzIENlbGwsICQ2NTU1MTA0ZmYwODViZWY0JHJlX2V4cG9ydCRTZWN0aW9uIGFzIFNlY3Rpb24sICQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ1OTZlMWIyZTJjZjkzNjkwIGFzIFRhYmxlQ29sbGVjdGlvbiwgJDc4ODc4MWJhYTMwMTE3ZmEkZXhwb3J0JDdjMTI3ZGI4NTBkNGU4MWUgYXMgYnVpbGRIZWFkZXJSb3dzLCAkYTllN2FlNTQ0YTRlNDFkZCRleHBvcnQkN2ZmNzdhMTYyOTcwYjMwZSBhcyBUYWJsZUNvbHVtbkxheW91dCwgJGVlNjVhMDA1N2ZkOTk1MzEkZXhwb3J0JDM0ZGZhOGExNjIyMTg1YTQgYXMgVU5TVEFCTEVfdXNlVHJlZUdyaWRTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiU2VjdGlvbiIsIiQ2NTU1MTA0ZmYwODViZWY0JHJlX2V4cG9ydCRTZWN0aW9uIiwidXNlQ29sbGVjdGlvbiIsIiQxQmZqVyR1c2VDb2xsZWN0aW9uIiwiZ2V0Rmlyc3RJdGVtIiwiJDFCZmpXJGdldEZpcnN0SXRlbSIsImdldExhc3RJdGVtIiwiJDFCZmpXJGdldExhc3RJdGVtIiwiQ29sbGVjdGlvbkJ1aWxkZXIiLCIkMUJmalckQ29sbGVjdGlvbkJ1aWxkZXIiLCIkMUJmalckcmVhY3QiLCJ1c2VTdGF0ZSIsIiQxQmZqVyR1c2VTdGF0ZSIsInVzZU1lbW8iLCIkMUJmalckdXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiJDFCZmpXJHVzZUNhbGxiYWNrIiwidXNlR3JpZFN0YXRlIiwiJDFCZmpXJHVzZUdyaWRTdGF0ZSIsIkdyaWRDb2xsZWN0aW9uIiwiJDFCZmpXJEdyaWRDb2xsZWN0aW9uIiwidGFibGVOZXN0ZWRSb3dzIiwiJDFCZmpXJHRhYmxlTmVzdGVkUm93cyIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsIiQxQmZqVyR1c2VDb250cm9sbGVkU3RhdGUiLCIkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkMTk5NGEwNzdiOThlZTBkNSIsIndpZHRoIiwiaXNOYU4iLCJTdHJpbmciLCJtYXRjaCIsIiQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCQ5MDc4YmFkNGMzOTM0NjA0IiwiY29uc29sZSIsIndhcm4iLCJwYXJzZUZsb2F0IiwiJDY4MThiMWM0ZmM2NzAyOGQkZXhwb3J0JDdiYmFkMjc4OTZmN2FlOWYiLCJ0YWJsZVdpZHRoIiwiRXJyb3IiLCIkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTkxODVjNjJhNzU0NGFhMCIsIm1heFdpZHRoIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIiQ2ODE4YjFjNGZjNjcwMjhkJGV4cG9ydCRmNTU2MDU0Y2U0MzU4NzAxIiwibWluV2lkdGgiLCIkNjgxOGIxYzRmYzY3MDI4ZCRleHBvcnQkNTVkNTBkYzY4NzM4NTQ5MSIsImF2YWlsYWJsZVdpZHRoIiwiY29sdW1ucyIsImNoYW5nZWRDb2x1bW5zIiwiZ2V0RGVmYXVsdFdpZHRoIiwiZ2V0RGVmYXVsdE1pbldpZHRoIiwiaGFzTm9uRnJvemVuSXRlbXMiLCJmbGV4SXRlbXMiLCJtYXAiLCJjb2x1bW4iLCJpbmRleCIsIl9jb2x1bW5fd2lkdGgiLCJfcmVmIiwiX3JlZjEiLCJnZXQiLCJrZXkiLCJkZWZhdWx0V2lkdGgiLCJmcm96ZW4iLCJiYXNlU2l6ZSIsImZsZXgiLCJ0YXJnZXRNYWluU2l6ZSIsIl9jb2x1bW5fbWluV2lkdGgiLCJfcmVmMiIsIm1pbiIsIm1heCIsImh5cG90aGV0aWNhbE1haW5TaXplIiwiTWF0aCIsInZpb2xhdGlvbiIsInVzZWRXaWR0aCIsImZsZXhGYWN0b3JzIiwiZm9yRWFjaCIsIml0ZW0iLCJyZW1haW5pbmdGcmVlU3BhY2UiLCJyYXRpbyIsInRvdGFsVmlvbGF0aW9uIiwic2lnbiIsIiQ2ODE4YjFjNGZjNjcwMjhkJHZhciRjYXNjYWRlUm91bmRpbmciLCJmcFRvdGFsIiwiaW50VG90YWwiLCJyb3VuZGVkQXJyYXkiLCJmbG9hdCIsImludGVnZXIiLCJyb3VuZCIsInB1c2giLCIkYTllN2FlNTQ0YTRlNDFkZCRleHBvcnQkN2ZmNzdhMTYyOTcwYjMwZSIsInNwbGl0Q29sdW1uc0ludG9Db250cm9sbGVkQW5kVW5jb250cm9sbGVkIiwicmVkdWNlIiwiYWNjIiwiY29sIiwicHJvcHMiLCJzZXQiLCJNYXAiLCJyZWNvbWJpbmVDb2x1bW5zIiwidW5jb250cm9sbGVkV2lkdGhzIiwidW5jb250cm9sbGVkQ29sdW1ucyIsImNvbnRyb2xsZWRDb2x1bW5zIiwiaGFzIiwiZ2V0SW5pdGlhbFVuY29udHJvbGxlZFdpZHRocyIsIkFycmF5IiwiZnJvbSIsIl90aGlzX2dldERlZmF1bHRXaWR0aCIsIl90aGlzIiwiX2NvbF9wcm9wc19kZWZhdWx0V2lkdGgiLCJjYWxsIiwiZ2V0Q29sdW1uV2lkdGgiLCJfdGhpc19jb2x1bW5XaWR0aHNfZ2V0IiwiY29sdW1uV2lkdGhzIiwiZ2V0Q29sdW1uTWluV2lkdGgiLCJjb2x1bW5NaW5XaWR0aHMiLCJnZXRDb2x1bW5NYXhXaWR0aCIsImNvbHVtbk1heFdpZHRocyIsInJlc2l6ZUNvbHVtbldpZHRoIiwiY29sbGVjdGlvbiIsImNvbnRyb2xsZWRXaWR0aHMiLCJwcmV2Q29sdW1uV2lkdGhzIiwicmVzaXplSW5kZXgiLCJJbmZpbml0eSIsInJlc2l6aW5nQ2hhbmdlZCIsInBlcmNlbnRLZXlzIiwiZnJLZXlzVG9UaGVSaWdodCIsIm1pbldpZHRocyIsImkiLCJfY29sdW1uX3Byb3BzX3dpZHRoX2VuZHNXaXRoIiwiX2NvbHVtbl9wcm9wc193aWR0aCIsImZyS2V5IiwiZnJWYWx1ZSIsImVuZHNXaXRoIiwiZmxvb3IiLCJuZXdXaWR0aHMiLCJidWlsZENvbHVtbldpZHRocyIsIndpZHRocyIsIl9jb2x1bW5fcHJvcHNfbWluV2lkdGgiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJfb3B0aW9uc19nZXREZWZhdWx0V2lkdGgiLCJfb3B0aW9uc19nZXREZWZhdWx0TWluV2lkdGgiLCIkMjkyYmM0ZTA5Y2QwZWI2MiRleHBvcnQkY2I4OTVkY2Y4NWRiMTMxOSIsInN0YXRlIiwicmVzaXppbmdDb2x1bW4iLCJzZXRSZXNpemluZ0NvbHVtbiIsImNvbHVtbkxheW91dCIsInNldFVuY29udHJvbGxlZFdpZHRocyIsImxhc3RDb2x1bW5zIiwic2V0TGFzdENvbHVtbnMiLCJsZW5ndGgiLCJzb21lIiwiYyIsIm5ld1VuY29udHJvbGxlZFdpZHRocyIsImNvbFdpZHRocyIsInN0YXJ0UmVzaXplIiwidXBkYXRlUmVzaXplZENvbHVtbnMiLCJuZXdDb250cm9sbGVkIiwiZW50cnkiLCJuZXdTaXplcyIsImVuZFJlc2l6ZSIsInRhYmxlU3RhdGUiLCIkNzg4NzgxYmFhMzAxMTdmYSR2YXIkUk9XX0hFQURFUl9DT0xVTU5fS0VZIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsIiQ3ODg3ODFiYWEzMDExN2ZhJHZhciRST1dfSEVBREVSX0NPTFVNTl9LRVlfRFJBRyIsIiQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ3YzEyN2RiODUwZDRlODFlIiwia2V5TWFwIiwiY29sdW1uTm9kZXMiLCJzZWVuIiwicGFyZW50S2V5IiwicGFyZW50IiwiY29sc3BhbiIsInNwbGljZSIsIm1heExlbmd0aCIsImhlYWRlclJvd3MiLCJmaWxsIiwiY29sSW5kZXgiLCJyb3ciLCJyb3dMZW5ndGgiLCJwIiwicGxhY2Vob2xkZXIiLCJ0eXBlIiwidmFsdWUiLCJyZW5kZXJlZCIsImxldmVsIiwiaGFzQ2hpbGROb2RlcyIsImNoaWxkTm9kZXMiLCJ0ZXh0VmFsdWUiLCJuZXh0S2V5IiwicHJldktleSIsIiQ3ODg3ODFiYWEzMDExN2ZhJGV4cG9ydCQ1OTZlMWIyZTJjZjkzNjkwIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJib2R5Iiwic2l6ZSIsIl9zaXplIiwiZ2V0S2V5cyIsImtleXMiLCJnZXRLZXlCZWZvcmUiLCJub2RlIiwiZ2V0S2V5QWZ0ZXIiLCJnZXRGaXJzdEtleSIsIl9nZXRGaXJzdEl0ZW0iLCJnZXRMYXN0S2V5IiwiX2dldExhc3RJdGVtIiwiZ2V0SXRlbSIsImF0IiwiaWR4IiwiZ2V0VGV4dFZhbHVlIiwicm93SGVhZGVyQ29sdW1uS2V5cyIsInRleHQiLCJjZWxsIiwiam9pbiIsIm5vZGVzIiwicHJldiIsIm9wdHMiLCJTZXQiLCJzaG93U2VsZWN0aW9uQ2hlY2tib3hlcyIsInJvd0hlYWRlckNvbHVtbiIsInNob3dEcmFnQnV0dG9ucyIsImlzU2VsZWN0aW9uQ2VsbCIsInVuc2hpZnQiLCJpc0RyYWdCdXR0b25DZWxsIiwicm93cyIsImNvbHVtbktleU1hcCIsInZpc2l0IiwiaXNSb3dIZWFkZXIiLCJhZGQiLCJjaGlsZCIsImNvbHVtbkNvdW50IiwiaXRlbXMiLCJ2aXNpdE5vZGUiLCIkNGEwZGQwMzZkNDkyY2VlNCR2YXIkT1BQT1NJVEVfU09SVF9ESVJFQ1RJT04iLCJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwiJDRhMGRkMDM2ZDQ5MmNlZTQkZXhwb3J0JDkwN2JjYzZjNDgzMjVmZDYiLCJpc0tleWJvYXJkTmF2aWdhdGlvbkRpc2FibGVkIiwic2V0S2V5Ym9hcmROYXZpZ2F0aW9uRGlzYWJsZWQiLCJzZWxlY3Rpb25Nb2RlIiwiY29udGV4dCIsImNoaWxkcmVuIiwiZGlzYWJsZWRLZXlzIiwic2VsZWN0aW9uTWFuYWdlciIsImRpc2FibGVkQmVoYXZpb3IiLCJzb3J0RGVzY3JpcHRvciIsInNvcnQiLCJjb2x1bW5LZXkiLCJkaXJlY3Rpb24iLCJfcHJvcHNfc29ydERlc2NyaXB0b3IiLCJvblNvcnRDaGFuZ2UiLCIkMzEyYWUzYjU2YTk0YTg2ZSR2YXIkVGFibGVIZWFkZXIiLCJnZXRDb2xsZWN0aW9uTm9kZSIsInJlbmRlcmVyIiwiQ2hpbGRyZW4iLCJlbGVtZW50IiwiJDMxMmFlM2I1NmE5NGE4NmUkZXhwb3J0JGY4NTA4OTViMjg3ZWYyOGUiLCIkNGFlNTMxNGJmNTBkYjFhMyR2YXIkVGFibGVCb2R5IiwiJDRhZTUzMTRiZjUwZGIxYTMkZXhwb3J0JDc2Y2NkMjEwYjkwMjk5MTciLCIkMWNkMjQ0NTU3YzJmOTdkNSR2YXIkQ29sdW1uIiwidGl0bGUiLCJjaGlsZENvbHVtbnMiLCJmdWxsTm9kZXMiLCJjb3VudCIsInNob3VsZEludmFsaWRhdGUiLCJuZXdDb250ZXh0IiwidXBkYXRlQ29udGV4dCIsIiQxY2QyNDQ1NTdjMmY5N2Q1JGV4cG9ydCQ4MTZiNWQ4MTEyOTVlNmJjIiwiJDcwZDcwZWIxNmVhNDg0MjgkdmFyJFJvdyIsIlVOU1RBQkxFX2NoaWxkSXRlbXMiLCJjZWxscyIsImNoaWxkUm93cyIsIiQ3MGQ3MGViMTZlYTQ4NDI4JGV4cG9ydCRiNTliZGJlZjljZTcwZGUyIiwiJDk0MWQxZDlhNmEyODk4MmEkdmFyJENlbGwiLCIkOTQxZDFkOWE2YTI4OTgyYSRleHBvcnQkZjZmMGMzZmU0ZWMzMDZlYSIsIiRlZTY1YTAwNTdmZDk5NTMxJGV4cG9ydCQzNGRmYThhMTYyMjE4NWE0IiwiVU5TVEFCTEVfZXhwYW5kZWRLZXlzIiwicHJvcEV4cGFuZGVkS2V5cyIsIlVOU1RBQkxFX2RlZmF1bHRFeHBhbmRlZEtleXMiLCJwcm9wRGVmYXVsdEV4cGFuZGVkS2V5cyIsIlVOU1RBQkxFX29uRXhwYW5kZWRDaGFuZ2UiLCJleHBhbmRlZEtleXMiLCJzZXRFeHBhbmRlZEtleXMiLCIkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkY29udmVydEV4cGFuZGVkIiwidW5kZWZpbmVkIiwiYnVpbGRlciIsImJ1aWxkIiwidHJlZUdyaWRDb2xsZWN0aW9uIiwiJGVlNjVhMDA1N2ZkOTk1MzEkdmFyJGdlbmVyYXRlVHJlZUdyaWRDb2xsZWN0aW9uIiwib25Ub2dnbGUiLCIkZWU2NWEwMDU3ZmQ5OTUzMSR2YXIkdG9nZ2xlS2V5IiwidGFibGVOb2RlcyIsInVzZXJDb2x1bW5Db3VudCIsInRvZ2dsZUtleSIsImN1cnJlbnRFeHBhbmRlZEtleXMiLCJ1cGRhdGVkRXhwYW5kZWRLZXlzIiwiZmxhdHRlbmVkUm93cyIsImZpbHRlciIsImRlbGV0ZSIsImV4cGFuZGVkIiwib3JpZ2luYWxDb2x1bW5zIiwidG9wTGV2ZWxSb3dzIiwiZ2xvYmFsUm93Q291bnQiLCJjZWxsQ2xvbmUiLCJjbG9uZSIsIm5ld1Byb3BzIiwiT2JqZWN0IiwiYXNzaWduIiwibGFzdE5vZGUiLCJyb3dJbmRleCIsImxhc3QiLCJ1c2VUYWJsZUNvbHVtblJlc2l6ZVN0YXRlIiwidXNlVGFibGVTdGF0ZSIsIlRhYmxlSGVhZGVyIiwiVGFibGVCb2R5IiwiQ29sdW1uIiwiUm93IiwiQ2VsbCIsIlRhYmxlQ29sbGVjdGlvbiIsImJ1aWxkSGVhZGVyUm93cyIsIlRhYmxlQ29sdW1uTGF5b3V0IiwiVU5TVEFCTEVfdXNlVHJlZUdyaWRTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/table/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/toggle/dist/import.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@react-stately/toggle/dist/import.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useToggleState: () => (/* binding */ $3017fa7ffdddec74$export$8042c6c013fd5226)\n/* harmony export */ });\n/* harmony import */ var _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/utils */ \"(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $3017fa7ffdddec74$export$8042c6c013fd5226(props = {}) {\n    let { isReadOnly: isReadOnly } = props;\n    // have to provide an empty function so useControlledState doesn't throw a fit\n    // can't use useControlledState's prop calling because we need the event object from the change\n    let [isSelected, setSelected] = (0, _react_stately_utils__WEBPACK_IMPORTED_MODULE_0__.useControlledState)(props.isSelected, props.defaultSelected || false, props.onChange);\n    function updateSelected(value) {\n        if (!isReadOnly) setSelected(value);\n    }\n    function toggleState() {\n        if (!isReadOnly) setSelected(!isSelected);\n    }\n    return {\n        isSelected: isSelected,\n        setSelected: updateSelected,\n        toggle: toggleState\n    };\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdG9nZ2xlL2Rpc3QvaW1wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxRjtBQUVyRjs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUNELFNBQVNFLDBDQUEwQ0MsUUFBUSxDQUFDLENBQUM7SUFDekQsSUFBSSxFQUFFQyxZQUFZQSxVQUFVLEVBQUUsR0FBR0Q7SUFDakMsOEVBQThFO0lBQzlFLCtGQUErRjtJQUMvRixJQUFJLENBQUNFLFlBQVlDLFlBQVksR0FBRyxDQUFDLEdBQUdMLG9FQUF3QixFQUFHRSxNQUFNRSxVQUFVLEVBQUVGLE1BQU1JLGVBQWUsSUFBSSxPQUFPSixNQUFNSyxRQUFRO0lBQy9ILFNBQVNDLGVBQWVDLEtBQUs7UUFDekIsSUFBSSxDQUFDTixZQUFZRSxZQUFZSTtJQUNqQztJQUNBLFNBQVNDO1FBQ0wsSUFBSSxDQUFDUCxZQUFZRSxZQUFZLENBQUNEO0lBQ2xDO0lBQ0EsT0FBTztRQUNIQSxZQUFZQTtRQUNaQyxhQUFhRztRQUNiRyxRQUFRRDtJQUNaO0FBQ0o7QUFLcUUsQ0FDckUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemV1cy1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS90b2dnbGUvZGlzdC9pbXBvcnQubWpzP2Y4NTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VDb250cm9sbGVkU3RhdGUgYXMgJGJPa2FlJHVzZUNvbnRyb2xsZWRTdGF0ZX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkMzAxN2ZhN2ZmZGRkZWM3NCRleHBvcnQkODA0MmM2YzAxM2ZkNTIyNihwcm9wcyA9IHt9KSB7XG4gICAgbGV0IHsgaXNSZWFkT25seTogaXNSZWFkT25seSB9ID0gcHJvcHM7XG4gICAgLy8gaGF2ZSB0byBwcm92aWRlIGFuIGVtcHR5IGZ1bmN0aW9uIHNvIHVzZUNvbnRyb2xsZWRTdGF0ZSBkb2Vzbid0IHRocm93IGEgZml0XG4gICAgLy8gY2FuJ3QgdXNlIHVzZUNvbnRyb2xsZWRTdGF0ZSdzIHByb3AgY2FsbGluZyBiZWNhdXNlIHdlIG5lZWQgdGhlIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBjaGFuZ2VcbiAgICBsZXQgW2lzU2VsZWN0ZWQsIHNldFNlbGVjdGVkXSA9ICgwLCAkYk9rYWUkdXNlQ29udHJvbGxlZFN0YXRlKShwcm9wcy5pc1NlbGVjdGVkLCBwcm9wcy5kZWZhdWx0U2VsZWN0ZWQgfHwgZmFsc2UsIHByb3BzLm9uQ2hhbmdlKTtcbiAgICBmdW5jdGlvbiB1cGRhdGVTZWxlY3RlZCh2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzUmVhZE9ubHkpIHNldFNlbGVjdGVkKHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9nZ2xlU3RhdGUoKSB7XG4gICAgICAgIGlmICghaXNSZWFkT25seSkgc2V0U2VsZWN0ZWQoIWlzU2VsZWN0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpc1NlbGVjdGVkOiBpc1NlbGVjdGVkLFxuICAgICAgICBzZXRTZWxlY3RlZDogdXBkYXRlU2VsZWN0ZWQsXG4gICAgICAgIHRvZ2dsZTogdG9nZ2xlU3RhdGVcbiAgICB9O1xufVxuXG5cblxuXG5leHBvcnQgeyQzMDE3ZmE3ZmZkZGRlYzc0JGV4cG9ydCQ4MDQyYzZjMDEzZmQ1MjI2IGFzIHVzZVRvZ2dsZVN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VDb250cm9sbGVkU3RhdGUiLCIkYk9rYWUkdXNlQ29udHJvbGxlZFN0YXRlIiwiJDMwMTdmYTdmZmRkZGVjNzQkZXhwb3J0JDgwNDJjNmMwMTNmZDUyMjYiLCJwcm9wcyIsImlzUmVhZE9ubHkiLCJpc1NlbGVjdGVkIiwic2V0U2VsZWN0ZWQiLCJkZWZhdWx0U2VsZWN0ZWQiLCJvbkNoYW5nZSIsInVwZGF0ZVNlbGVjdGVkIiwidmFsdWUiLCJ0b2dnbGVTdGF0ZSIsInRvZ2dsZSIsInVzZVRvZ2dsZVN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/toggle/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/utils/dist/import.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@react-stately/utils/dist/import.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ $9446cca9a3875146$export$7d15b64cf5a3a4c4),\n/* harmony export */   snapValueToStep: () => (/* binding */ $9446cca9a3875146$export$cb6e0bb50bc19463),\n/* harmony export */   toFixedNumber: () => (/* binding */ $9446cca9a3875146$export$b6268554fba451f),\n/* harmony export */   useControlledState: () => (/* binding */ $458b0a5536c1a7cf$export$40bfa8c7b0832715)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $458b0a5536c1a7cf$export$40bfa8c7b0832715(value, defaultValue, onChange) {\n    let [stateValue, setStateValue] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(value || defaultValue);\n    let isControlledRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value !== undefined);\n    let isControlled = value !== undefined;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let wasControlled = isControlledRef.current;\n        if (wasControlled !== isControlled) console.warn(`WARN: A component changed from ${wasControlled ? \"controlled\" : \"uncontrolled\"} to ${isControlled ? \"controlled\" : \"uncontrolled\"}.`);\n        isControlledRef.current = isControlled;\n    }, [\n        isControlled\n    ]);\n    let currentValue = isControlled ? value : stateValue;\n    let setValue = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value, ...args)=>{\n        let onChangeCaller = (value, ...onChangeArgs)=>{\n            if (onChange) {\n                if (!Object.is(currentValue, value)) onChange(value, ...onChangeArgs);\n            }\n            if (!isControlled) // calling setState multiple times with the same value only emits onChange once.\n            // We do not use a ref for this because we specifically _do_ want the value to\n            // reset every render, and assigning to a ref in render breaks aborted suspended renders.\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            currentValue = value;\n        };\n        if (typeof value === \"function\") {\n            console.warn(\"We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320\");\n            // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n            // when someone using useControlledState calls setControlledState(myFunc)\n            // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n            // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n            // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n            let updateFunction = (oldValue, ...functionArgs)=>{\n                let interceptedValue = value(isControlled ? currentValue : oldValue, ...functionArgs);\n                onChangeCaller(interceptedValue, ...args);\n                if (!isControlled) return interceptedValue;\n                return oldValue;\n            };\n            setStateValue(updateFunction);\n        } else {\n            if (!isControlled) setStateValue(value);\n            onChangeCaller(value, ...args);\n        }\n    }, [\n        isControlled,\n        currentValue,\n        onChange\n    ]);\n    return [\n        currentValue,\n        setValue\n    ];\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */ function $9446cca9a3875146$export$7d15b64cf5a3a4c4(value, min = -Infinity, max = Infinity) {\n    let newValue = Math.min(Math.max(value, min), max);\n    return newValue;\n}\nfunction $9446cca9a3875146$export$cb6e0bb50bc19463(value, min, max, step) {\n    min = Number(min);\n    max = Number(max);\n    let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n    let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;\n    if (!isNaN(min)) {\n        if (snappedValue < min) snappedValue = min;\n        else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor((max - min) / step) * step;\n    } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor(max / step) * step;\n    // correct floating point behavior by rounding to step precision\n    let string = step.toString();\n    let index = string.indexOf(\".\");\n    let precision = index >= 0 ? string.length - index : 0;\n    if (precision > 0) {\n        let pow = Math.pow(10, precision);\n        snappedValue = Math.round(snappedValue * pow) / pow;\n    }\n    return snappedValue;\n}\nfunction $9446cca9a3875146$export$b6268554fba451f(value, digits, base = 10) {\n    const pow = Math.pow(base, digits);\n    return Math.round(value * pow) / pow;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdXRpbHMvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZJO0FBRTdJOzs7Ozs7Ozs7O0NBVUMsR0FBRzs7Ozs7Ozs7OztDQVVILEdBQ0QsU0FBU1EsMENBQTBDQyxLQUFLLEVBQUVDLFlBQVksRUFBRUMsUUFBUTtJQUM1RSxJQUFJLENBQUNDLFlBQVlDLGNBQWMsR0FBRyxDQUFDLEdBQUdaLDJDQUFjLEVBQUdRLFNBQVNDO0lBQ2hFLElBQUlJLGtCQUFrQixDQUFDLEdBQUdYLHlDQUFZLEVBQUdNLFVBQVVNO0lBQ25ELElBQUlDLGVBQWVQLFVBQVVNO0lBQzVCLElBQUdWLDRDQUFlLEVBQUc7UUFDbEIsSUFBSVksZ0JBQWdCSCxnQkFBZ0JJLE9BQU87UUFDM0MsSUFBSUQsa0JBQWtCRCxjQUFjRyxRQUFRQyxJQUFJLENBQUMsQ0FBQywrQkFBK0IsRUFBRUgsZ0JBQWdCLGVBQWUsZUFBZSxJQUFJLEVBQUVELGVBQWUsZUFBZSxlQUFlLENBQUMsQ0FBQztRQUN0TEYsZ0JBQWdCSSxPQUFPLEdBQUdGO0lBQzlCLEdBQUc7UUFDQ0E7S0FDSDtJQUNELElBQUlLLGVBQWVMLGVBQWVQLFFBQVFHO0lBQzFDLElBQUlVLFdBQVcsQ0FBQyxHQUFHZiw4Q0FBaUIsRUFBRyxDQUFDRSxPQUFPLEdBQUdjO1FBQzlDLElBQUlDLGlCQUFpQixDQUFDZixPQUFPLEdBQUdnQjtZQUM1QixJQUFJZCxVQUFVO2dCQUNWLElBQUksQ0FBQ2UsT0FBT0MsRUFBRSxDQUFDTixjQUFjWixRQUFRRSxTQUFTRixVQUFVZ0I7WUFDNUQ7WUFDQSxJQUFJLENBQUNULGNBQ0wsZ0ZBQWdGO1lBQ2hGLDhFQUE4RTtZQUM5RSx5RkFBeUY7WUFDekYsdURBQXVEO1lBQ3ZESyxlQUFlWjtRQUNuQjtRQUNBLElBQUksT0FBT0EsVUFBVSxZQUFZO1lBQzdCVSxRQUFRQyxJQUFJLENBQUM7WUFDYixvR0FBb0c7WUFDcEcseUVBQXlFO1lBQ3pFLGtJQUFrSTtZQUNsSSxpS0FBaUs7WUFDaksseUlBQXlJO1lBQ3pJLElBQUlRLGlCQUFpQixDQUFDQyxVQUFVLEdBQUdDO2dCQUMvQixJQUFJQyxtQkFBbUJ0QixNQUFNTyxlQUFlSyxlQUFlUSxhQUFhQztnQkFDeEVOLGVBQWVPLHFCQUFxQlI7Z0JBQ3BDLElBQUksQ0FBQ1AsY0FBYyxPQUFPZTtnQkFDMUIsT0FBT0Y7WUFDWDtZQUNBaEIsY0FBY2U7UUFDbEIsT0FBTztZQUNILElBQUksQ0FBQ1osY0FBY0gsY0FBY0o7WUFDakNlLGVBQWVmLFVBQVVjO1FBQzdCO0lBQ0osR0FBRztRQUNDUDtRQUNBSztRQUNBVjtLQUNIO0lBQ0QsT0FBTztRQUNIVTtRQUNBQztLQUNIO0FBQ0w7QUFHQTs7Ozs7Ozs7OztDQVVDLEdBQUc7O0NBRUgsR0FBRyxTQUFTVSwwQ0FBMEN2QixLQUFLLEVBQUV3QixNQUFNLENBQUNDLFFBQVEsRUFBRUMsTUFBTUQsUUFBUTtJQUN6RixJQUFJRSxXQUFXQyxLQUFLSixHQUFHLENBQUNJLEtBQUtGLEdBQUcsQ0FBQzFCLE9BQU93QixNQUFNRTtJQUM5QyxPQUFPQztBQUNYO0FBQ0EsU0FBU0UsMENBQTBDN0IsS0FBSyxFQUFFd0IsR0FBRyxFQUFFRSxHQUFHLEVBQUVJLElBQUk7SUFDcEVOLE1BQU1PLE9BQU9QO0lBQ2JFLE1BQU1LLE9BQU9MO0lBQ2IsSUFBSU0sWUFBWSxDQUFDaEMsUUFBU2lDLENBQUFBLE1BQU1ULE9BQU8sSUFBSUEsR0FBRSxDQUFDLElBQUtNO0lBQ25ELElBQUlJLGVBQWVOLEtBQUtPLEdBQUcsQ0FBQ0gsYUFBYSxLQUFLRixPQUFPOUIsUUFBUTRCLEtBQUtRLElBQUksQ0FBQ0osYUFBY0YsQ0FBQUEsT0FBT0YsS0FBS08sR0FBRyxDQUFDSCxVQUFTLElBQUtoQyxRQUFRZ0M7SUFDM0gsSUFBSSxDQUFDQyxNQUFNVCxNQUFNO1FBQ2IsSUFBSVUsZUFBZVYsS0FBS1UsZUFBZVY7YUFDbEMsSUFBSSxDQUFDUyxNQUFNUCxRQUFRUSxlQUFlUixLQUFLUSxlQUFlVixNQUFNSSxLQUFLUyxLQUFLLENBQUMsQ0FBQ1gsTUFBTUYsR0FBRSxJQUFLTSxRQUFRQTtJQUN0RyxPQUFPLElBQUksQ0FBQ0csTUFBTVAsUUFBUVEsZUFBZVIsS0FBS1EsZUFBZU4sS0FBS1MsS0FBSyxDQUFDWCxNQUFNSSxRQUFRQTtJQUN0RixnRUFBZ0U7SUFDaEUsSUFBSVEsU0FBU1IsS0FBS1MsUUFBUTtJQUMxQixJQUFJQyxRQUFRRixPQUFPRyxPQUFPLENBQUM7SUFDM0IsSUFBSUMsWUFBWUYsU0FBUyxJQUFJRixPQUFPSyxNQUFNLEdBQUdILFFBQVE7SUFDckQsSUFBSUUsWUFBWSxHQUFHO1FBQ2YsSUFBSUUsTUFBTWhCLEtBQUtnQixHQUFHLENBQUMsSUFBSUY7UUFDdkJSLGVBQWVOLEtBQUtpQixLQUFLLENBQUNYLGVBQWVVLE9BQU9BO0lBQ3BEO0lBQ0EsT0FBT1Y7QUFDWDtBQUNBLFNBQVNZLHlDQUF5QzlDLEtBQUssRUFBRStDLE1BQU0sRUFBRUMsT0FBTyxFQUFFO0lBQ3RFLE1BQU1KLE1BQU1oQixLQUFLZ0IsR0FBRyxDQUFDSSxNQUFNRDtJQUMzQixPQUFPbkIsS0FBS2lCLEtBQUssQ0FBQzdDLFFBQVE0QyxPQUFPQTtBQUNyQztBQUtzUCxDQUN0UCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZXVzLW5leHQtYXBwLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zdGF0ZWx5L3V0aWxzL2Rpc3QvaW1wb3J0Lm1qcz9lM2Y1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlU3RhdGUgYXMgJDZpbXVoJHVzZVN0YXRlLCB1c2VSZWYgYXMgJDZpbXVoJHVzZVJlZiwgdXNlRWZmZWN0IGFzICQ2aW11aCR1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIGFzICQ2aW11aCR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5mdW5jdGlvbiAkNDU4YjBhNTUzNmMxYTdjZiRleHBvcnQkNDBiZmE4YzdiMDgzMjcxNSh2YWx1ZSwgZGVmYXVsdFZhbHVlLCBvbkNoYW5nZSkge1xuICAgIGxldCBbc3RhdGVWYWx1ZSwgc2V0U3RhdGVWYWx1ZV0gPSAoMCwgJDZpbXVoJHVzZVN0YXRlKSh2YWx1ZSB8fCBkZWZhdWx0VmFsdWUpO1xuICAgIGxldCBpc0NvbnRyb2xsZWRSZWYgPSAoMCwgJDZpbXVoJHVzZVJlZikodmFsdWUgIT09IHVuZGVmaW5lZCk7XG4gICAgbGV0IGlzQ29udHJvbGxlZCA9IHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgKDAsICQ2aW11aCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCB3YXNDb250cm9sbGVkID0gaXNDb250cm9sbGVkUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICh3YXNDb250cm9sbGVkICE9PSBpc0NvbnRyb2xsZWQpIGNvbnNvbGUud2FybihgV0FSTjogQSBjb21wb25lbnQgY2hhbmdlZCBmcm9tICR7d2FzQ29udHJvbGxlZCA/IFwiY29udHJvbGxlZFwiIDogXCJ1bmNvbnRyb2xsZWRcIn0gdG8gJHtpc0NvbnRyb2xsZWQgPyBcImNvbnRyb2xsZWRcIiA6IFwidW5jb250cm9sbGVkXCJ9LmApO1xuICAgICAgICBpc0NvbnRyb2xsZWRSZWYuY3VycmVudCA9IGlzQ29udHJvbGxlZDtcbiAgICB9LCBbXG4gICAgICAgIGlzQ29udHJvbGxlZFxuICAgIF0pO1xuICAgIGxldCBjdXJyZW50VmFsdWUgPSBpc0NvbnRyb2xsZWQgPyB2YWx1ZSA6IHN0YXRlVmFsdWU7XG4gICAgbGV0IHNldFZhbHVlID0gKDAsICQ2aW11aCR1c2VDYWxsYmFjaykoKHZhbHVlLCAuLi5hcmdzKT0+e1xuICAgICAgICBsZXQgb25DaGFuZ2VDYWxsZXIgPSAodmFsdWUsIC4uLm9uQ2hhbmdlQXJncyk9PntcbiAgICAgICAgICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmlzKGN1cnJlbnRWYWx1ZSwgdmFsdWUpKSBvbkNoYW5nZSh2YWx1ZSwgLi4ub25DaGFuZ2VBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNDb250cm9sbGVkKSAvLyBJZiB1bmNvbnRyb2xsZWQsIG11dGF0ZSB0aGUgY3VycmVudFZhbHVlIGxvY2FsIHZhcmlhYmxlIHNvIHRoYXRcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgc2V0U3RhdGUgbXVsdGlwbGUgdGltZXMgd2l0aCB0aGUgc2FtZSB2YWx1ZSBvbmx5IGVtaXRzIG9uQ2hhbmdlIG9uY2UuXG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgdXNlIGEgcmVmIGZvciB0aGlzIGJlY2F1c2Ugd2Ugc3BlY2lmaWNhbGx5IF9kb18gd2FudCB0aGUgdmFsdWUgdG9cbiAgICAgICAgICAgIC8vIHJlc2V0IGV2ZXJ5IHJlbmRlciwgYW5kIGFzc2lnbmluZyB0byBhIHJlZiBpbiByZW5kZXIgYnJlYWtzIGFib3J0ZWQgc3VzcGVuZGVkIHJlbmRlcnMuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXZSBjYW4gbm90IHN1cHBvcnQgYSBmdW5jdGlvbiBjYWxsYmFjay4gU2VlIEdpdGh1YiBJc3N1ZXMgZm9yIGRldGFpbHMgaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlL3JlYWN0LXNwZWN0cnVtL2lzc3Vlcy8yMzIwXCIpO1xuICAgICAgICAgICAgLy8gdGhpcyBzdXBwb3J0cyBmdW5jdGlvbmFsIHVwZGF0ZXMgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2hvb2tzLXJlZmVyZW5jZS5odG1sI2Z1bmN0aW9uYWwtdXBkYXRlc1xuICAgICAgICAgICAgLy8gd2hlbiBzb21lb25lIHVzaW5nIHVzZUNvbnRyb2xsZWRTdGF0ZSBjYWxscyBzZXRDb250cm9sbGVkU3RhdGUobXlGdW5jKVxuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGNhbGwgb3VyIHVzZVN0YXRlIHNldFN0YXRlIHdpdGggYSBmdW5jdGlvbiBhcyB3ZWxsIHdoaWNoIGludm9rZXMgbXlGdW5jIGFuZCBjYWxscyBvbkNoYW5nZSB3aXRoIHRoZSB2YWx1ZSBmcm9tIG15RnVuY1xuICAgICAgICAgICAgLy8gaWYgd2UncmUgaW4gYW4gdW5jb250cm9sbGVkIHN0YXRlLCB0aGVuIHdlIGFsc28gcmV0dXJuIHRoZSB2YWx1ZSBvZiBteUZ1bmMgd2hpY2ggdG8gc2V0U3RhdGUgbG9va3MgYXMgdGhvdWdoIGl0IHdhcyBqdXN0IGNhbGxlZCB3aXRoIG15RnVuYyBmcm9tIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBqdXN0IHJldHVybiB0aGUgY29udHJvbGxlZCB2YWx1ZSwgd2hpY2ggd29uJ3QgY2F1c2UgYSByZXJlbmRlciBiZWNhdXNlIFJlYWN0IGtub3dzIHRvIGJhaWwgb3V0IHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICAgICAgICBsZXQgdXBkYXRlRnVuY3Rpb24gPSAob2xkVmFsdWUsIC4uLmZ1bmN0aW9uQXJncyk9PntcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJjZXB0ZWRWYWx1ZSA9IHZhbHVlKGlzQ29udHJvbGxlZCA/IGN1cnJlbnRWYWx1ZSA6IG9sZFZhbHVlLCAuLi5mdW5jdGlvbkFyZ3MpO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlQ2FsbGVyKGludGVyY2VwdGVkVmFsdWUsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICghaXNDb250cm9sbGVkKSByZXR1cm4gaW50ZXJjZXB0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2V0U3RhdGVWYWx1ZSh1cGRhdGVGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzQ29udHJvbGxlZCkgc2V0U3RhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICBvbkNoYW5nZUNhbGxlcih2YWx1ZSwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGlzQ29udHJvbGxlZCxcbiAgICAgICAgY3VycmVudFZhbHVlLFxuICAgICAgICBvbkNoYW5nZVxuICAgIF0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgc2V0VmFsdWVcbiAgICBdO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyAvKipcbiAqIFRha2VzIGEgdmFsdWUgYW5kIGZvcmNlcyBpdCB0byB0aGUgY2xvc2VzdCBtaW4vbWF4IGlmIGl0J3Mgb3V0c2lkZS4gQWxzbyBmb3JjZXMgaXQgdG8gdGhlIGNsb3Nlc3QgdmFsaWQgc3RlcC5cbiAqLyBmdW5jdGlvbiAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkN2QxNWI2NGNmNWEzYTRjNCh2YWx1ZSwgbWluID0gLUluZmluaXR5LCBtYXggPSBJbmZpbml0eSkge1xuICAgIGxldCBuZXdWYWx1ZSA9IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xuICAgIHJldHVybiBuZXdWYWx1ZTtcbn1cbmZ1bmN0aW9uICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRjYjZlMGJiNTBiYzE5NDYzKHZhbHVlLCBtaW4sIG1heCwgc3RlcCkge1xuICAgIG1pbiA9IE51bWJlcihtaW4pO1xuICAgIG1heCA9IE51bWJlcihtYXgpO1xuICAgIGxldCByZW1haW5kZXIgPSAodmFsdWUgLSAoaXNOYU4obWluKSA/IDAgOiBtaW4pKSAlIHN0ZXA7XG4gICAgbGV0IHNuYXBwZWRWYWx1ZSA9IE1hdGguYWJzKHJlbWFpbmRlcikgKiAyID49IHN0ZXAgPyB2YWx1ZSArIE1hdGguc2lnbihyZW1haW5kZXIpICogKHN0ZXAgLSBNYXRoLmFicyhyZW1haW5kZXIpKSA6IHZhbHVlIC0gcmVtYWluZGVyO1xuICAgIGlmICghaXNOYU4obWluKSkge1xuICAgICAgICBpZiAoc25hcHBlZFZhbHVlIDwgbWluKSBzbmFwcGVkVmFsdWUgPSBtaW47XG4gICAgICAgIGVsc2UgaWYgKCFpc05hTihtYXgpICYmIHNuYXBwZWRWYWx1ZSA+IG1heCkgc25hcHBlZFZhbHVlID0gbWluICsgTWF0aC5mbG9vcigobWF4IC0gbWluKSAvIHN0ZXApICogc3RlcDtcbiAgICB9IGVsc2UgaWYgKCFpc05hTihtYXgpICYmIHNuYXBwZWRWYWx1ZSA+IG1heCkgc25hcHBlZFZhbHVlID0gTWF0aC5mbG9vcihtYXggLyBzdGVwKSAqIHN0ZXA7XG4gICAgLy8gY29ycmVjdCBmbG9hdGluZyBwb2ludCBiZWhhdmlvciBieSByb3VuZGluZyB0byBzdGVwIHByZWNpc2lvblxuICAgIGxldCBzdHJpbmcgPSBzdGVwLnRvU3RyaW5nKCk7XG4gICAgbGV0IGluZGV4ID0gc3RyaW5nLmluZGV4T2YoXCIuXCIpO1xuICAgIGxldCBwcmVjaXNpb24gPSBpbmRleCA+PSAwID8gc3RyaW5nLmxlbmd0aCAtIGluZGV4IDogMDtcbiAgICBpZiAocHJlY2lzaW9uID4gMCkge1xuICAgICAgICBsZXQgcG93ID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgICAgIHNuYXBwZWRWYWx1ZSA9IE1hdGgucm91bmQoc25hcHBlZFZhbHVlICogcG93KSAvIHBvdztcbiAgICB9XG4gICAgcmV0dXJuIHNuYXBwZWRWYWx1ZTtcbn1cbmZ1bmN0aW9uICQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCRiNjI2ODU1NGZiYTQ1MWYodmFsdWUsIGRpZ2l0cywgYmFzZSA9IDEwKSB7XG4gICAgY29uc3QgcG93ID0gTWF0aC5wb3coYmFzZSwgZGlnaXRzKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIHBvdykgLyBwb3c7XG59XG5cblxuXG5cbmV4cG9ydCB7JDQ1OGIwYTU1MzZjMWE3Y2YkZXhwb3J0JDQwYmZhOGM3YjA4MzI3MTUgYXMgdXNlQ29udHJvbGxlZFN0YXRlLCAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkN2QxNWI2NGNmNWEzYTRjNCBhcyBjbGFtcCwgJDk0NDZjY2E5YTM4NzUxNDYkZXhwb3J0JGNiNmUwYmI1MGJjMTk0NjMgYXMgc25hcFZhbHVlVG9TdGVwLCAkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkYjYyNjg1NTRmYmE0NTFmIGFzIHRvRml4ZWROdW1iZXJ9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwiJDZpbXVoJHVzZVN0YXRlIiwidXNlUmVmIiwiJDZpbXVoJHVzZVJlZiIsInVzZUVmZmVjdCIsIiQ2aW11aCR1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIiQ2aW11aCR1c2VDYWxsYmFjayIsIiQ0NThiMGE1NTM2YzFhN2NmJGV4cG9ydCQ0MGJmYThjN2IwODMyNzE1IiwidmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJvbkNoYW5nZSIsInN0YXRlVmFsdWUiLCJzZXRTdGF0ZVZhbHVlIiwiaXNDb250cm9sbGVkUmVmIiwidW5kZWZpbmVkIiwiaXNDb250cm9sbGVkIiwid2FzQ29udHJvbGxlZCIsImN1cnJlbnQiLCJjb25zb2xlIiwid2FybiIsImN1cnJlbnRWYWx1ZSIsInNldFZhbHVlIiwiYXJncyIsIm9uQ2hhbmdlQ2FsbGVyIiwib25DaGFuZ2VBcmdzIiwiT2JqZWN0IiwiaXMiLCJ1cGRhdGVGdW5jdGlvbiIsIm9sZFZhbHVlIiwiZnVuY3Rpb25BcmdzIiwiaW50ZXJjZXB0ZWRWYWx1ZSIsIiQ5NDQ2Y2NhOWEzODc1MTQ2JGV4cG9ydCQ3ZDE1YjY0Y2Y1YTNhNGM0IiwibWluIiwiSW5maW5pdHkiLCJtYXgiLCJuZXdWYWx1ZSIsIk1hdGgiLCIkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkY2I2ZTBiYjUwYmMxOTQ2MyIsInN0ZXAiLCJOdW1iZXIiLCJyZW1haW5kZXIiLCJpc05hTiIsInNuYXBwZWRWYWx1ZSIsImFicyIsInNpZ24iLCJmbG9vciIsInN0cmluZyIsInRvU3RyaW5nIiwiaW5kZXgiLCJpbmRleE9mIiwicHJlY2lzaW9uIiwibGVuZ3RoIiwicG93Iiwicm91bmQiLCIkOTQ0NmNjYTlhMzg3NTE0NiRleHBvcnQkYjYyNjg1NTRmYmE0NTFmIiwiZGlnaXRzIiwiYmFzZSIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsImNsYW1wIiwic25hcFZhbHVlVG9TdGVwIiwidG9GaXhlZE51bWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/utils/dist/import.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-stately/virtualizer/dist/import.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@react-stately/virtualizer/dist/import.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Layout: () => (/* binding */ $c74cda7d31af1253$export$c84671f46d6a1ca),\n/* harmony export */   LayoutInfo: () => (/* binding */ $d7fd61009c21d0bb$export$7e0eeb9da702a085),\n/* harmony export */   Point: () => (/* binding */ $3041db3296945e6e$export$baf26146a414f24a),\n/* harmony export */   Rect: () => (/* binding */ $60423f92c7f9ad87$export$c79fc6492f3af13d),\n/* harmony export */   ReusableView: () => (/* binding */ $ad1d98aa8f0c31b4$export$1a5223887c560441),\n/* harmony export */   Size: () => (/* binding */ $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec),\n/* harmony export */   useVirtualizerState: () => (/* binding */ $fc0b13b484ac1194$export$1505db82fe357e65)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(ssr)/./node_modules/@react-aria/utils/dist/import.mjs\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $c74cda7d31af1253$export$c84671f46d6a1ca {\n    /**\n   * Returns whether the layout should invalidate in response to\n   * visible rectangle changes. By default, it only invalidates\n   * when the collection view's size changes. Return true always\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\n   */ shouldInvalidate(newRect, oldRect) {\n        // By default, invalidate when the size changes\n        return newRect.width !== oldRect.width || newRect.height !== oldRect.height;\n    }\n    /**\n   * This method allows the layout to perform any pre-computation\n   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n   * Called by the collection view before {@link getVisibleLayoutInfos}\n   * or {@link getLayoutInfo} are called.\n   */ validate(invalidationContext) {}\n    /**\n   * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n   * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n   * @param point The point at which the drag occurred.\n   */ // getDragTarget(point: Point): DragTarget | null {\n    //   let target = this.virtualizer.keyAtPoint(point);\n    //   if (!target) {\n    //     return null;\n    //   }\n    //   return {\n    //     type: 'item',\n    //     key: target\n    //   };\n    // }\n    /**\n   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n   * to reject the drop. The dropped items will be inserted before the resulting target.\n   * @param point The point at which the drop occurred.\n   */ // getDropTarget(point: Point): DropTarget | null {\n    //   return null;\n    // }\n    /**\n   * Returns the starting attributes for an animated insertion.\n   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n   * The default implementation just returns its input.\n   *\n   * @param layoutInfo The proposed LayoutInfo for this view.\n   */ getInitialLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n    /**\n   * Returns the ending attributes for an animated removal.\n   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n   * to the one returned by this method. The default implementation returns its input.\n   *\n   * @param layoutInfo The original LayoutInfo for this view.\n   */ getFinalLayoutInfo(layoutInfo) {\n        return layoutInfo;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $d7fd61009c21d0bb$export$7e0eeb9da702a085 {\n    /**\n   * Returns a copy of the LayoutInfo.\n   */ copy() {\n        let res = new $d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());\n        res.estimatedSize = this.estimatedSize;\n        res.opacity = this.opacity;\n        res.transform = this.transform;\n        res.parentKey = this.parentKey;\n        res.isSticky = this.isSticky;\n        res.zIndex = this.zIndex;\n        res.allowOverflow = this.allowOverflow;\n        return res;\n    }\n    /**\n   * @param type A string representing the view type. Should be `'item'` for item views.\n                            Other types are used by supplementary views.\n   * @param key The unique key for this view.\n   * @param rect The rectangle describing the size and position of this view.\n   */ constructor(type, key, rect){\n        this.type = type;\n        this.key = key;\n        this.parentKey = null;\n        this.rect = rect;\n        this.estimatedSize = false;\n        this.isSticky = false;\n        this.opacity = 1;\n        this.transform = null;\n        this.zIndex = 0;\n        this.allowOverflow = false;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $3041db3296945e6e$export$baf26146a414f24a {\n    /**\n   * Returns a copy of this point.\n   */ copy() {\n        return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n   * Checks if two points are equal.\n   */ equals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    /**\n   * Returns true if this point is the origin.\n   */ isOrigin() {\n        return this.x === 0 && this.y === 0;\n    }\n    constructor(x = 0, y = 0){\n        this.x = x;\n        this.y = y;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $60423f92c7f9ad87$export$c79fc6492f3af13d {\n    /**\n   * The maximum x-coordinate in the rectangle.\n   */ get maxX() {\n        return this.x + this.width;\n    }\n    /**\n   * The maximum y-coordinate in the rectangle.\n   */ get maxY() {\n        return this.y + this.height;\n    }\n    /**\n   * The area of the rectangle.\n   */ get area() {\n        return this.width * this.height;\n    }\n    /**\n   * The top left corner of the rectangle.\n   */ get topLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.y);\n    }\n    /**\n   * The top right corner of the rectangle.\n   */ get topRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.y);\n    }\n    /**\n   * The bottom left corner of the rectangle.\n   */ get bottomLeft() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.maxY);\n    }\n    /**\n   * The bottom right corner of the rectangle.\n   */ get bottomRight() {\n        return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.maxY);\n    }\n    /**\n   * Returns whether this rectangle intersects another rectangle.\n   * @param rect - The rectangle to check.\n   */ intersects(rect) {\n        return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;\n    }\n    /**\n   * Returns whether this rectangle fully contains another rectangle.\n   * @param rect - The rectangle to check.\n   */ containsRect(rect) {\n        return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;\n    }\n    /**\n   * Returns whether the rectangle contains the given point.\n   * @param point - The point to check.\n   */ containsPoint(point) {\n        return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;\n    }\n    /**\n   * Returns the first corner of this rectangle (from top to bottom, left to right)\n   * that is contained in the given rectangle, or null of the rectangles do not intersect.\n   * @param rect - The rectangle to check.\n   */ getCornerInRect(rect) {\n        for (let key of [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomLeft\",\n            \"bottomRight\"\n        ]){\n            if (rect.containsPoint(this[key])) return key;\n        }\n        return null;\n    }\n    equals(rect) {\n        return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n    }\n    pointEquals(point) {\n        return this.x === point.x && this.y === point.y;\n    }\n    sizeEquals(size) {\n        return this.width === size.width && this.height === size.height;\n    }\n    /**\n   * Returns the union of this Rect and another.\n   */ union(other) {\n        let x = Math.min(this.x, other.x);\n        let y = Math.min(this.y, other.y);\n        let width = Math.max(this.maxX, other.maxX) - x;\n        let height = Math.max(this.maxY, other.maxY) - y;\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, width, height);\n    }\n    /**\n   * Returns the intersection of this Rect with another.\n   * If the rectangles do not intersect, an all zero Rect is returned.\n   */ intersection(other) {\n        if (!this.intersects(other)) return new $60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, 0, 0);\n        let x = Math.max(this.x, other.x);\n        let y = Math.max(this.y, other.y);\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, Math.min(this.maxX, other.maxX) - x, Math.min(this.maxY, other.maxY) - y);\n    }\n    /**\n   * Returns a copy of this rectangle.\n   */ copy() {\n        return new $60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);\n    }\n    constructor(x = 0, y = 0, width = 0, height = 0){\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec {\n    /**\n   * Returns a copy of this size.\n   */ copy() {\n        return new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);\n    }\n    /**\n   * Returns whether this size is equal to another one.\n   */ equals(other) {\n        return this.width === other.width && this.height === other.height;\n    }\n    /**\n   * The total area of the Size.\n   */ get area() {\n        return this.width * this.height;\n    }\n    constructor(width = 0, height = 0){\n        this.width = width;\n        this.height = height;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $ad1d98aa8f0c31b4$var$KEY = 0;\nclass $ad1d98aa8f0c31b4$export$1a5223887c560441 {\n    /**\n   * Prepares the view for reuse. Called just before the view is removed from the DOM.\n   */ prepareForReuse() {\n        this.content = null;\n        this.rendered = null;\n        this.layoutInfo = null;\n    }\n    constructor(virtualizer){\n        this.virtualizer = virtualizer;\n        this.key = ++$ad1d98aa8f0c31b4$var$KEY;\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // use high res timer if available\nlet $3eb131dcf37ad5f8$var$perf =  false ? 0 : null;\n// @ts-ignore\nlet $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);\nlet $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function() {\n    return Date.now ? Date.now() : new Date().getTime();\n};\nlet $3eb131dcf37ad5f8$var$fixTs;\nfunction $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn) {\n    let canceled = false;\n    let raf_id;\n    let promise = new Promise((resolve)=>{\n        let start = $3eb131dcf37ad5f8$var$getTime();\n        let diffX = end.x - begin.x;\n        let diffY = end.y - begin.y;\n        raf_id = requestAnimationFrame(function run(t) {\n            // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n            // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n            if ($3eb131dcf37ad5f8$var$fixTs == null) $3eb131dcf37ad5f8$var$fixTs = t > 1e12 !== $3eb131dcf37ad5f8$var$getTime() > 1e12;\n            if ($3eb131dcf37ad5f8$var$fixTs) t = $3eb131dcf37ad5f8$var$getTime();\n            // check if we're done\n            let delta = t - start;\n            if (delta > duration) {\n                fn(end);\n                resolve();\n            } else {\n                // call frame callback after computing eased time and get the next frame\n                let proceed = fn(new (0, $3041db3296945e6e$export$baf26146a414f24a)(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));\n                if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run);\n            }\n        });\n    });\n    promise.cancel = function() {\n        canceled = true;\n        cancelAnimationFrame(raf_id);\n    };\n    return promise;\n}\nfunction $3eb131dcf37ad5f8$export$77860c106b4a6a2e(t) {\n    return t;\n}\nfunction $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t) {\n    return Math.sin(t * Math.PI / 2);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b) {\n    let res = new Set();\n    for (let key of a.keys())if (!b.has(key)) res.add(key);\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$acaf96a27438246b(a, b) {\n    let toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b);\n    let toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b, a);\n    let toUpdate = new Set;\n    for (let key of a.keys())if (b.has(key)) toUpdate.add(key);\n    return {\n        toRemove: toRemove,\n        toAdd: toAdd,\n        toUpdate: toUpdate\n    };\n}\nfunction* $fc36f9a046a9ce79$export$cfc14088dfefce5f(...iterators) {\n    for (let iterator of iterators)yield* iterator;\n}\nfunction $fc36f9a046a9ce79$export$6897c284b6f9f4dc(object) {\n    let res = {};\n    for(let key in object)res[object[key]] = key;\n    return res;\n}\nfunction $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a, b) {\n    if (a === b) return true;\n    if (a.size !== b.size) return false;\n    for (let key of a){\n        if (!b.has(key)) return false;\n    }\n    return true;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $364191b3decf3697$var$RollingAverage {\n    addSample(sample) {\n        this.count++;\n        this.value += (sample - this.value) / this.count;\n    }\n    constructor(){\n        this.count = 0;\n        this.value = 0;\n    }\n}\nclass $364191b3decf3697$export$4455ee6afb38dcbb {\n    setVisibleRect(rect) {\n        let time = performance.now() - this.startTime;\n        if (time < 500) {\n            this.averageTime.addSample(time);\n            if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;\n            if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;\n        }\n        this.startTime = performance.now();\n        this.visibleRect = rect;\n    }\n    collectMetrics() {\n        let time = performance.now() - this.startTime;\n        if (time < 500) this.averagePerf.addSample(time);\n        if (this.visibleRect.height > 0) {\n            let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));\n            this.overscanY.addSample(o);\n        }\n        if (this.visibleRect.width > 0) {\n            let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));\n            this.overscanX.addSample(o);\n        }\n    }\n    getOverscannedRect() {\n        let overscanned = this.visibleRect.copy();\n        let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n        if (this.velocity.y > 0) {\n            overscanned.y -= overscanY * 0.2;\n            overscanned.height += overscanY + overscanY * 0.2;\n        } else {\n            overscanned.y -= overscanY;\n            overscanned.height += overscanY + overscanY * 0.2;\n        }\n        let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n        if (this.velocity.x > 0) {\n            overscanned.x -= overscanX * 0.2;\n            overscanned.width += overscanX + overscanX * 0.2;\n        } else {\n            overscanned.x -= overscanX;\n            overscanned.width += overscanX + overscanX * 0.2;\n        }\n        return overscanned;\n    }\n    constructor(){\n        this.startTime = 0;\n        this.averagePerf = new $364191b3decf3697$var$RollingAverage();\n        this.averageTime = new $364191b3decf3697$var$RollingAverage();\n        this.velocity = new (0, $3041db3296945e6e$export$baf26146a414f24a)(5, 5);\n        this.overscanX = new $364191b3decf3697$var$RollingAverage();\n        this.overscanY = new $364191b3decf3697$var$RollingAverage();\n        this.visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();\n    }\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $8e135e531d8dcb66$export$febc5573c75cefb0 {\n    constructor(){\n        this.level = 0;\n        this.actions = [];\n        this.animated = true;\n        this.initialMap = new Map();\n        this.finalMap = new Map();\n        this.initialLayoutInfo = new Map();\n        this.finalLayoutInfo = new Map();\n        this.removed = new Map();\n        this.toRemove = new Map();\n    }\n}\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n    _setContentSize(size) {\n        this._contentSize = size;\n        this.delegate.setContentSize(size);\n    }\n    _setContentOffset(offset) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n        this.delegate.setVisibleRect(rect);\n    }\n    /**\n   * Get the size of the scrollable content.\n   */ get contentSize() {\n        return this._contentSize;\n    }\n    /**\n   * Get the collection view's currently visible rectangle.\n   */ get visibleRect() {\n        return this._visibleRect;\n    }\n    /**\n   * Set the collection view's currently visible rectangle.\n   */ set visibleRect(rect) {\n        this._setVisibleRect(rect);\n    }\n    _setVisibleRect(rect, forceUpdate = false) {\n        let current = this._visibleRect;\n        // Ignore if the rects are equal\n        if (rect.equals(current)) return;\n        if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n        let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n        this._resetAnimatedContentOffset();\n        this._visibleRect = rect;\n        if (shouldInvalidate) this.relayoutNow({\n            offsetChanged: !rect.pointEquals(current),\n            sizeChanged: !rect.sizeEquals(current)\n        });\n        else this.updateSubviews(forceUpdate);\n    }\n    get collection() {\n        return this._collection;\n    }\n    set collection(data) {\n        this._setData(data);\n    }\n    _setData(data) {\n        if (data === this._collection) return;\n        if (this._collection) this._runTransaction(()=>{\n            this._collection = data;\n        }, this.transitionDuration > 0);\n        else {\n            this._collection = data;\n            this.reloadData();\n        }\n    }\n    /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */ reloadData() {\n        this.relayout({\n            contentChanged: true\n        });\n    }\n    /**\n   * Returns the item with the given key.\n   */ getItem(key) {\n        return this._collection ? this._collection.getItem(key) : null;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ get persistedKeys() {\n        return this._persistedKeys;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ set persistedKeys(persistedKeys) {\n        if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {\n            this._persistedKeys = persistedKeys;\n            this.updateSubviews();\n        }\n    }\n    /** Returns whether the given key, or an ancestor, is persisted. */ isPersistedKey(key) {\n        // Quick check if the key is directly in the set of persisted keys.\n        if (this._persistedKeys.has(key)) return true;\n        // If not, check if the key is an ancestor of any of the persisted keys.\n        for (let k of this._persistedKeys)while(k != null){\n            let layoutInfo = this.layout.getLayoutInfo(k);\n            if (!layoutInfo) break;\n            k = layoutInfo.parentKey;\n            if (k === key) return true;\n        }\n        return false;\n    }\n    /**\n   * Get the collection view's layout.\n   */ get layout() {\n        return this._layout;\n    }\n    /**\n   * Set the collection view's layout.\n   */ set layout(layout) {\n        this.setLayout(layout);\n    }\n    /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */ setLayout(layout, animated = false) {\n        if (layout === this._layout) return;\n        let applyLayout = ()=>{\n            if (this._layout) this._layout.virtualizer = null;\n            layout.virtualizer = this;\n            this._layout = layout;\n        };\n        if (animated) // We just set the layout inside a transaction action, which runs after the initial\n        // layout infos for the animation are retrieved from the previous layout. Then, the\n        // final layout infos are retrieved from the new layout, and animations occur.\n        this._runTransaction(applyLayout);\n        else {\n            applyLayout();\n            this.relayout();\n        }\n    }\n    _getReuseType(layoutInfo, content) {\n        if (layoutInfo.type === \"item\" && content) {\n            let type = this.delegate.getType ? this.delegate.getType(content) : \"item\";\n            let reuseType = type === \"item\" ? \"item\" : layoutInfo.type + \"_\" + type;\n            return {\n                type: type,\n                reuseType: reuseType\n            };\n        }\n        return {\n            type: layoutInfo.type,\n            reuseType: layoutInfo.type\n        };\n    }\n    getReusableView(layoutInfo) {\n        let content = this.getItem(layoutInfo.key);\n        let { reuseType: reuseType } = this._getReuseType(layoutInfo, content);\n        if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n        let reusable = this._reusableViews[reuseType];\n        let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);\n        view.viewType = reuseType;\n        if (!this._animatedContentOffset.isOrigin()) {\n            layoutInfo = layoutInfo.copy();\n            layoutInfo.rect.x += this._animatedContentOffset.x;\n            layoutInfo.rect.y += this._animatedContentOffset.y;\n        }\n        view.layoutInfo = layoutInfo;\n        this._renderView(view);\n        return view;\n    }\n    _renderView(reusableView) {\n        let { type: type, key: key } = reusableView.layoutInfo;\n        reusableView.content = this.getItem(key);\n        reusableView.rendered = this._renderContent(type, reusableView.content);\n    }\n    _renderContent(type, content) {\n        let cached = this._renderedContent.get(content);\n        if (cached != null) return cached;\n        let rendered = this.delegate.renderView(type, content);\n        if (content) this._renderedContent.set(content, rendered);\n        return rendered;\n    }\n    /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */ get visibleViews() {\n        return Array.from(this._visibleViews.values());\n    }\n    /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */ getView(key) {\n        return this._visibleViews.get(key) || null;\n    }\n    /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */ getViewsOfType(type) {\n        return this.visibleViews.filter((v)=>v.layoutInfo && v.layoutInfo.type === type);\n    }\n    /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */ keyForView(view) {\n        if (view && view.layoutInfo) return view.layoutInfo.key;\n        return null;\n    }\n    /**\n   * Returns the key for the item view currently at the given point.\n   */ keyAtPoint(point) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        // Layout may return multiple layout infos in the case of\n        // persisted keys, so find the first one that actually intersects.\n        for (let layoutInfo of layoutInfos){\n            if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n        }\n        return null;\n    }\n    /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */ willUnmount() {\n        cancelAnimationFrame(this._relayoutRaf);\n    }\n    /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */ relayout(context = {}) {\n        // Ignore relayouts while animating the scroll position\n        if (this._scrollAnimation || typeof requestAnimationFrame === \"undefined\") return;\n        // If we already scheduled a relayout, extend the invalidation\n        // context so we coalesce multiple relayouts in the same frame.\n        if (this._invalidationContext) {\n            Object.assign(this._invalidationContext, context);\n            return;\n        }\n        this._invalidationContext = context;\n    }\n    /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */ relayoutNow(context = this._invalidationContext || {}) {\n        // Cancel the scheduled relayout, since we're doing it now.\n        if (this._relayoutRaf) {\n            cancelAnimationFrame(this._relayoutRaf);\n            this._relayoutRaf = null;\n            // Update the provided context with the current invalidationContext since we are cancelling\n            // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n            context = {\n                ...this._invalidationContext,\n                ...context\n            };\n        }\n        // Reset the invalidation context\n        this._invalidationContext = null;\n        // Do nothing if we don't have a layout or content, or we are\n        // in the middle of an animated scroll transition.\n        if (!this.layout || !this._collection || this._scrollAnimation) return;\n        let scrollAnchor = this._getScrollAnchor();\n        // Trigger the beforeLayout hook, if provided\n        if (typeof context.beforeLayout === \"function\") context.beforeLayout();\n        // Validate the layout\n        this.layout.validate(context);\n        this._setContentSize(this.layout.getContentSize());\n        // Trigger the afterLayout hook, if provided\n        if (typeof context.afterLayout === \"function\") context.afterLayout();\n        // Adjust scroll position based on scroll anchor, and constrain.\n        // If the content changed, scroll to the top.\n        let visibleRect = this.getVisibleRect();\n        let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n        let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n        let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n        contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n        contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n        let hasLayoutUpdates = false;\n        if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n            // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n            // Save the difference between the current and new content offsets, and apply it to the\n            // individual content items instead. At the end of the animation, we'll reset and set the\n            // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n            // the scroll animation and the content animation.\n            if (context.animated || !this._animatedContentOffset.isOrigin()) {\n                this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n                this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n                hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n            } else this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));\n        } else hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n        // Apply layout infos, unless this is coming from an animated transaction\n        if (!(context.transaction && context.animated)) this._applyLayoutInfos();\n        // Wait for animations, and apply the afterAnimation hook, if provided\n        if (context.animated && hasLayoutUpdates) {\n            this._enableTransitions();\n            let done = ()=>{\n                this._disableTransitions();\n                // Reset scroll position after animations (see above comment).\n                if (!this._animatedContentOffset.isOrigin()) {\n                    // Get the content offset to scroll to, taking _animatedContentOffset into account.\n                    let { x: x, y: y } = this.getVisibleRect();\n                    this._resetAnimatedContentOffset();\n                    this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));\n                }\n                if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n            };\n            // Sometimes the animation takes slightly longer than expected.\n            setTimeout(done, this.transitionDuration + 100);\n            return;\n        } else if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n    }\n    /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */ _correctItemOrder() {\n        // Defer until after scrolling and animated transactions are complete\n        if (this._isScrolling || this._transaction) return;\n        for (let key of this._visibleLayoutInfos.keys()){\n            let view = this._visibleViews.get(key);\n            this._children.delete(view);\n            this._children.add(view);\n        }\n    }\n    _enableTransitions() {\n        this.delegate.beginAnimations();\n    }\n    _disableTransitions() {\n        this.delegate.endAnimations();\n    }\n    _getScrollAnchor() {\n        if (!this.anchorScrollPosition) return null;\n        let visibleRect = this.getVisibleRect();\n        // Ask the delegate to provide a scroll anchor, if possible\n        if (this.delegate.getScrollAnchor) {\n            let key = this.delegate.getScrollAnchor(visibleRect);\n            if (key != null) {\n                let layoutInfo = this.layout.getLayoutInfo(key);\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let key = layoutInfo.key;\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    return {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        // No need to anchor the scroll position if it is at the top\n        if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null;\n        // Find a view with a visible corner that has the smallest distance to the top of the collection view\n        let cornerAnchor = null;\n        for (let [key, view] of this._visibleViews){\n            let layoutInfo = view.layoutInfo;\n            if (layoutInfo && layoutInfo.rect.area > 0) {\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    if (!cornerAnchor || offset < cornerAnchor.offset) cornerAnchor = {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        return cornerAnchor;\n    }\n    _restoreScrollAnchor(scrollAnchor, context) {\n        let contentOffset = this.getVisibleRect();\n        if (scrollAnchor) {\n            var _context_transaction;\n            let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n            if (finalAnchor) {\n                let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n                contentOffset.y += adjustment;\n            }\n        }\n        return contentOffset;\n    }\n    getVisibleRect() {\n        let v = this.visibleRect;\n        let x = v.x - this._animatedContentOffset.x;\n        let y = v.y - this._animatedContentOffset.y;\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, v.width, v.height);\n    }\n    getVisibleLayoutInfos() {\n        let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n        this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n        return this._visibleLayoutInfos;\n    }\n    _getLayoutInfoMap(rect, copy = false) {\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        let map = new Map;\n        for (let layoutInfo of layoutInfos){\n            if (copy) layoutInfo = layoutInfo.copy();\n            map.set(layoutInfo.key, layoutInfo);\n        }\n        return map;\n    }\n    updateSubviews(forceUpdate = false) {\n        if (!this._collection) return;\n        let visibleLayoutInfos = this.getVisibleLayoutInfos();\n        let currentlyVisible = this._visibleViews;\n        let toAdd, toRemove, toUpdate;\n        // If this is a force update, remove and re-add all views.\n        // Otherwise, find and update the diff.\n        if (forceUpdate) {\n            toAdd = visibleLayoutInfos;\n            toRemove = currentlyVisible;\n            toUpdate = new Set();\n        } else {\n            ({ toAdd: toAdd, toRemove: toRemove, toUpdate: toUpdate } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));\n            for (let key of toUpdate){\n                let view = currentlyVisible.get(key);\n                if (!view || !view.layoutInfo) continue;\n                let item = this.getItem(visibleLayoutInfos.get(key).key);\n                if (view.content === item) toUpdate.delete(key);\n                else {\n                    // If the view type changes, delete and recreate the view instead of updating\n                    let { reuseType: reuseType } = this._getReuseType(view.layoutInfo, item);\n                    if (view.viewType !== reuseType) {\n                        toUpdate.delete(key);\n                        toAdd.add(key);\n                        toRemove.add(key);\n                    }\n                }\n            }\n            // We are done if the sets are equal\n            if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n                if (this._transaction) this._applyLayoutInfos();\n                return;\n            }\n        }\n        // Track views that should be removed. They are not removed from\n        // the DOM immediately, since we may reuse and need to re-insert\n        // them back into the DOM anyway.\n        let removed = new Set();\n        for (let key of toRemove.keys()){\n            let view = this._visibleViews.get(key);\n            if (view) {\n                removed.add(view);\n                this._visibleViews.delete(key);\n                // If we are in the middle of a transaction, wait until the end\n                // of the animations to remove the views from the DOM. Also means\n                // we can't reuse those views immediately.\n                if (this._transaction) this._transaction.toRemove.set(key, view);\n                else this.reuseView(view);\n            }\n        }\n        for (let key of toAdd.keys()){\n            let layoutInfo = visibleLayoutInfos.get(key);\n            let view;\n            // If we're in a transaction, and a layout change happens\n            // during the animations such that a view that was going\n            // to be removed is now not, we don't create a new view\n            // since the old one is still in the DOM, marked as toRemove.\n            if (this._transaction) {\n                // if transaction, get initial layout attributes for the animation\n                if (this._transaction.initialLayoutInfo.has(key)) layoutInfo = this._transaction.initialLayoutInfo.get(key);\n                view = this._transaction.toRemove.get(key);\n                if (view) {\n                    this._transaction.toRemove.delete(key);\n                    this._applyLayoutInfo(view, layoutInfo);\n                }\n            }\n            if (!view) {\n                // Create or reuse a view for this row\n                view = this.getReusableView(layoutInfo);\n                // Add the view to the DOM if needed\n                if (!removed.has(view)) this._children.add(view);\n            }\n            this._visibleViews.set(key, view);\n            removed.delete(view);\n        }\n        for (let key of toUpdate){\n            let view = currentlyVisible.get(key);\n            this._renderedContent.delete(key);\n            this._renderView(view);\n        }\n        // Remove the remaining rows to delete from the DOM\n        if (!this._transaction) this.removeViews(removed);\n        this._correctItemOrder();\n        this._flushVisibleViews();\n        let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n        if (hasLayoutUpdates) requestAnimationFrame(()=>{\n            // If we're in a transaction, apply animations to visible views\n            // and \"to be removed\" views, which animate off screen.\n            if (this._transaction) requestAnimationFrame(()=>this._applyLayoutInfos());\n        });\n        return hasLayoutUpdates;\n    }\n    afterRender() {\n        if (this._transactionQueue.length > 0) this._processTransactionQueue();\n        else if (this._invalidationContext) this.relayoutNow();\n        if (this.shouldOverscan) this._overscanManager.collectMetrics();\n    }\n    _flushVisibleViews() {\n        // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n        // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n        // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n        // method to build the final tree.\n        let viewsByParentKey = new Map([\n            [\n                null,\n                []\n            ]\n        ]);\n        for (let view of this._children){\n            var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;\n            if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);\n            (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);\n            if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);\n        }\n        let buildTree = (parent, views)=>views.map((view)=>{\n                let children = viewsByParentKey.get(view.layoutInfo.key);\n                return this.delegate.renderWrapper(parent, view, children, (childViews)=>buildTree(view, childViews));\n            });\n        let children = buildTree(null, viewsByParentKey.get(null));\n        this.delegate.setVisibleViews(children);\n    }\n    _applyLayoutInfo(view, layoutInfo) {\n        if (view.layoutInfo === layoutInfo) return false;\n        view.layoutInfo = layoutInfo;\n        return true;\n    }\n    _applyLayoutInfos() {\n        let updated = false;\n        // Apply layout infos to visible views\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        // Apply final layout infos for views that will be removed\n        if (this._transaction) {\n            for (let view of this._transaction.toRemove.values()){\n                let cur = view.layoutInfo;\n                if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                    let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                    if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n                }\n            }\n            for (let view of this._transaction.removed.values()){\n                let cur = view.layoutInfo;\n                let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n                layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        if (updated) this._flushVisibleViews();\n    }\n    _hasLayoutUpdates() {\n        if (!this._transaction) return false;\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if (!cur) return true;\n            let layoutInfo = this.layout.getLayoutInfo(cur.key);\n            if (!cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n        }\n        return false;\n    }\n    reuseView(view) {\n        view.prepareForReuse();\n        this._reusableViews[view.viewType].push(view);\n    }\n    removeViews(toRemove) {\n        for (let view of toRemove)this._children.delete(view);\n    }\n    updateItemSize(key, size) {\n        // TODO: we should be able to invalidate a single index path\n        // @ts-ignore\n        if (!this.layout.updateItemSize) return;\n        // If the scroll position is currently animating, add the update\n        // to a queue to be processed after the animation is complete.\n        if (this._scrollAnimation) {\n            this._sizeUpdateQueue.set(key, size);\n            return;\n        }\n        // @ts-ignore\n        let changed = this.layout.updateItemSize(key, size);\n        if (changed) this.relayout();\n    }\n    startScrolling() {\n        this._isScrolling = true;\n    }\n    endScrolling() {\n        this._isScrolling = false;\n        this._correctItemOrder();\n        this._flushVisibleViews();\n    }\n    _resetAnimatedContentOffset() {\n        // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n        if (!this._animatedContentOffset.isOrigin()) {\n            this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n            this._applyLayoutInfos();\n        }\n    }\n    /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */ scrollToItem(key, options) {\n        // key can be 0, so check if null or undefined\n        if (key == null) return;\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        if (!layoutInfo) return;\n        let { duration: duration = 300, shouldScrollX: shouldScrollX = true, shouldScrollY: shouldScrollY = true, offsetX: offsetX = 0, offsetY: offsetY = 0 } = options;\n        let x = this.visibleRect.x;\n        let y = this.visibleRect.y;\n        let minX = layoutInfo.rect.x - offsetX;\n        let minY = layoutInfo.rect.y - offsetY;\n        let maxX = x + this.visibleRect.width;\n        let maxY = y + this.visibleRect.height;\n        if (shouldScrollX) {\n            if (minX <= x || maxX === 0) x = minX;\n            else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n        }\n        if (shouldScrollY) {\n            if (minY <= y || maxY === 0) y = minY;\n            else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n        }\n        return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y), duration);\n    }\n    /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */ scrollTo(offset, duration = 300) {\n        // Cancel the current scroll animation\n        if (this._scrollAnimation) {\n            this._scrollAnimation.cancel();\n            this._scrollAnimation = null;\n        }\n        // Set the content offset synchronously if the duration is zero\n        if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n            this._setContentOffset(offset);\n            return Promise.resolve();\n        }\n        this.startScrolling();\n        this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), (offset)=>{\n            this._setContentOffset(offset);\n        });\n        this._scrollAnimation.then(()=>{\n            this._scrollAnimation = null;\n            // Process view size updates that occurred during the animation.\n            // Only views that are still visible will be actually updated.\n            for (let [key, size] of this._sizeUpdateQueue)this.updateItemSize(key, size);\n            this._sizeUpdateQueue.clear();\n            this.relayout();\n            this._processTransactionQueue();\n            this.endScrolling();\n        });\n        return this._scrollAnimation;\n    }\n    _runTransaction(action, animated) {\n        this._startTransaction();\n        if (this._nextTransaction) this._nextTransaction.actions.push(action);\n        this._endTransaction(animated);\n    }\n    _startTransaction() {\n        if (!this._nextTransaction) this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0);\n        this._nextTransaction.level++;\n    }\n    _endTransaction(animated) {\n        if (!this._nextTransaction) return false;\n        // Save whether the transaction should be animated.\n        if (animated != null) this._nextTransaction.animated = animated;\n        // If we haven't reached level 0, we are still in a\n        // nested transaction. Wait for the parent to end.\n        if (--this._nextTransaction.level > 0) return false;\n        // Do nothing for empty transactions\n        if (this._nextTransaction.actions.length === 0) {\n            this._nextTransaction = null;\n            return false;\n        }\n        // Default animations to true\n        if (this._nextTransaction.animated == null) this._nextTransaction.animated = true;\n        // Enqueue the transaction\n        this._transactionQueue.push(this._nextTransaction);\n        this._nextTransaction = null;\n        return true;\n    }\n    _processTransactionQueue() {\n        // If the current transaction is animating, wait until the end\n        // to process the next transaction.\n        if (this._transaction || this._scrollAnimation) return;\n        let next = this._transactionQueue.shift();\n        if (next) this._performTransaction(next);\n    }\n    _getContentRect() {\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);\n    }\n    _performTransaction(transaction) {\n        this._transaction = transaction;\n        this.relayoutNow({\n            transaction: transaction,\n            animated: transaction.animated,\n            beforeLayout: ()=>{\n                // Get the initial layout infos for all views before the updates\n                // so we can figure out which views to add and remove.\n                if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n                // Apply the actions that occurred during this transaction\n                for (let action of transaction.actions)action();\n            },\n            afterLayout: ()=>{\n                // Get the final layout infos after the updates\n                if (transaction.animated) {\n                    transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n                    this._setupTransactionAnimations(transaction);\n                } else this._transaction = null;\n            },\n            afterAnimation: ()=>{\n                // Remove and reuse views when animations are done\n                if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())){\n                    this._children.delete(view);\n                    this.reuseView(view);\n                }\n                this._transaction = null;\n                // Ensure DOM order is correct for accessibility after animations are complete\n                this._correctItemOrder();\n                this._flushVisibleViews();\n                this._processTransactionQueue();\n            }\n        });\n    }\n    _setupTransactionAnimations(transaction) {\n        let { initialMap: initialMap, finalMap: finalMap } = transaction;\n        // Store initial and final layout infos for animations\n        for (let [key, layoutInfo] of initialMap)if (finalMap.has(key)) transaction.initialLayoutInfo.set(key, layoutInfo);\n        else // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n        // Get initial layout infos for views that were added\n        for (let [key, layoutInfo] of finalMap)if (!initialMap.has(key)) {\n            let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n            transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n        }\n        // Figure out which views were removed.\n        for (let [key, view] of this._visibleViews)// Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n        // added, removed... etc in a loop.\n        if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n            transaction.removed.set(key, view);\n            this._visibleViews.delete(key);\n            // In case something weird happened, where we have a view but no\n            // initial layout info, use the one attached to the view.\n            if (view.layoutInfo) {\n                if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n            }\n        }\n    }\n    constructor(options = {}){\n        this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec);\n        this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d);\n        this._reusableViews = {};\n        this._visibleLayoutInfos = new Map();\n        this._visibleViews = new Map();\n        this._renderedContent = new WeakMap();\n        this._children = new Set();\n        this._invalidationContext = null;\n        this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();\n        this._persistedKeys = new Set();\n        this._scrollAnimation = null;\n        this._isScrolling = false;\n        this._sizeUpdateQueue = new Map();\n        this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n        this._transaction = null;\n        this._nextTransaction = null;\n        this._transactionQueue = [];\n        var _options_transitionDuration;\n        // Set options from passed object if given\n        this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;\n        this.anchorScrollPosition = options.anchorScrollPosition || false;\n        this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n        this.shouldOverscan = options.shouldOverscan !== false;\n        for (let key of [\n            \"delegate\",\n            \"size\",\n            \"layout\",\n            \"collection\"\n        ])if (options[key]) this[key] = options[key];\n    }\n}\nfunction $fc0b13b484ac1194$export$1505db82fe357e65(opts) {\n    let [visibleViews, setVisibleViews] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    let [contentSize, setContentSize] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)());\n    let [isAnimating, setAnimating] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isScrolling, setScrolling] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let virtualizer = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new (0, $38b9490c1cca8fc4$export$89be5a243e59c4b2)(), []);\n    virtualizer.delegate = {\n        setVisibleViews: setVisibleViews,\n        setVisibleRect (rect) {\n            virtualizer.visibleRect = rect;\n            opts.onVisibleRectChange(rect);\n        },\n        setContentSize: setContentSize,\n        renderView: opts.renderView,\n        renderWrapper: opts.renderWrapper,\n        beginAnimations: ()=>setAnimating(true),\n        endAnimations: ()=>setAnimating(false),\n        getScrollAnchor: opts.getScrollAnchor\n    };\n    virtualizer.layout = opts.layout;\n    virtualizer.collection = opts.collection;\n    virtualizer.transitionDuration = opts.transitionDuration;\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        virtualizer.afterRender();\n    });\n    // eslint-disable-next-line arrow-body-style\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>virtualizer.willUnmount();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let setVisibleRect = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((rect)=>{\n        virtualizer.visibleRect = rect;\n    }, [\n        virtualizer\n    ]);\n    let startScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.startScrolling();\n        setScrolling(true);\n    }, [\n        virtualizer\n    ]);\n    let endScrolling = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        virtualizer.endScrolling();\n        setScrolling(false);\n    }, [\n        virtualizer\n    ]);\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            virtualizer: virtualizer,\n            visibleViews: visibleViews,\n            setVisibleRect: setVisibleRect,\n            contentSize: contentSize,\n            isAnimating: isAnimating,\n            isScrolling: isScrolling,\n            startScrolling: startScrolling,\n            endScrolling: endScrolling\n        }), [\n        virtualizer,\n        visibleViews,\n        setVisibleRect,\n        contentSize,\n        isAnimating,\n        isScrolling,\n        startScrolling,\n        endScrolling\n    ]);\n    return state;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvdmlydHVhbGl6ZXIvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErSTtBQUNuRTtBQUU1RTs7Ozs7Ozs7OztDQVVDLEdBQUc7Ozs7Ozs7Ozs7Q0FVSCxHQUFHLE1BQU1VO0lBQ047Ozs7O0dBS0QsR0FBR0MsaUJBQWlCQyxPQUFPLEVBQUVDLE9BQU8sRUFBRTtRQUNqQywrQ0FBK0M7UUFDL0MsT0FBT0QsUUFBUUUsS0FBSyxLQUFLRCxRQUFRQyxLQUFLLElBQUlGLFFBQVFHLE1BQU0sS0FBS0YsUUFBUUUsTUFBTTtJQUMvRTtJQUNBOzs7OztHQUtELEdBQUdDLFNBQVNDLG1CQUFtQixFQUFFLENBQUM7SUFDakM7Ozs7R0FJRCxHQUFHLG1EQUFtRDtJQUNyRCxxREFBcUQ7SUFDckQsbUJBQW1CO0lBQ25CLG1CQUFtQjtJQUNuQixNQUFNO0lBQ04sYUFBYTtJQUNiLG9CQUFvQjtJQUNwQixrQkFBa0I7SUFDbEIsT0FBTztJQUNQLElBQUk7SUFDSjs7OztHQUlELEdBQUcsbURBQW1EO0lBQ3JELGlCQUFpQjtJQUNqQixJQUFJO0lBQ0o7Ozs7OztHQU1ELEdBQUdDLHFCQUFxQkMsVUFBVSxFQUFFO1FBQy9CLE9BQU9BO0lBQ1g7SUFDQTs7Ozs7O0dBTUQsR0FBR0MsbUJBQW1CRCxVQUFVLEVBQUU7UUFDN0IsT0FBT0E7SUFDWDtBQUNKO0FBR0E7Ozs7Ozs7Ozs7Q0FVQyxHQUFHLE1BQU1FO0lBQ047O0dBRUQsR0FBR0MsT0FBTztRQUNMLElBQUlDLE1BQU0sSUFBSUYsMENBQTBDLElBQUksQ0FBQ0csSUFBSSxFQUFFLElBQUksQ0FBQ0MsR0FBRyxFQUFFLElBQUksQ0FBQ0MsSUFBSSxDQUFDSixJQUFJO1FBQzNGQyxJQUFJSSxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhO1FBQ3RDSixJQUFJSyxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPO1FBQzFCTCxJQUFJTSxTQUFT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LDhDQUFpQixFQUFHLENBQUNtQjtRQUMxQzBDLFlBQVlrRSxXQUFXLEdBQUc1RztJQUM5QixHQUFHO1FBQ0MwQztLQUNIO0lBQ0QsSUFBSXVPLGlCQUFpQixDQUFDLEdBQUdwUyw4Q0FBaUIsRUFBRztRQUN6QzZELFlBQVl1TyxjQUFjO1FBQzFCNkIsYUFBYTtJQUNqQixHQUFHO1FBQ0NwUTtLQUNIO0lBQ0QsSUFBSXdPLGVBQWUsQ0FBQyxHQUFHclMsOENBQWlCLEVBQUc7UUFDdkM2RCxZQUFZd08sWUFBWTtRQUN4QjRCLGFBQWE7SUFDakIsR0FBRztRQUNDcFE7S0FDSDtJQUNELElBQUlzUSxRQUFRLENBQUMsR0FBR3ZVLDBDQUFhLEVBQUcsSUFBSztZQUM3QmlFLGFBQWFBO1lBQ2JnSixjQUFjQTtZQUNkbEYsZ0JBQWdCQTtZQUNoQmlDLGFBQWFBO1lBQ2JrSyxhQUFhQTtZQUNiRSxhQUFhQTtZQUNiNUIsZ0JBQWdCQTtZQUNoQkMsY0FBY0E7UUFDbEIsSUFBSTtRQUNKeE87UUFDQWdKO1FBQ0FsRjtRQUNBaUM7UUFDQWtLO1FBQ0FFO1FBQ0E1QjtRQUNBQztLQUNIO0lBQ0QsT0FBTzhCO0FBQ1g7QUFLNFksQ0FDNVksa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemV1cy1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3RhdGVseS92aXJ0dWFsaXplci9kaXN0L2ltcG9ydC5tanM/ZTlhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZVN0YXRlIGFzICQ4RDNuciR1c2VTdGF0ZSwgdXNlTWVtbyBhcyAkOEQzbnIkdXNlTWVtbywgdXNlRWZmZWN0IGFzICQ4RDNuciR1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIGFzICQ4RDNuciR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUxheW91dEVmZmVjdCBhcyAkOEQzbnIkdXNlTGF5b3V0RWZmZWN0fSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkYzc0Y2RhN2QzMWFmMTI1MyRleHBvcnQkYzg0NjcxZjQ2ZDZhMWNhIHtcbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGludmFsaWRhdGUgaW4gcmVzcG9uc2UgdG9cbiAgICogdmlzaWJsZSByZWN0YW5nbGUgY2hhbmdlcy4gQnkgZGVmYXVsdCwgaXQgb25seSBpbnZhbGlkYXRlc1xuICAgKiB3aGVuIHRoZSBjb2xsZWN0aW9uIHZpZXcncyBzaXplIGNoYW5nZXMuIFJldHVybiB0cnVlIGFsd2F5c1xuICAgKiB0byBtYWtlIHRoZSBsYXlvdXQgaW52YWxpZGF0ZSB3aGlsZSBzY3JvbGxpbmcgKGUuZy4gc3RpY2t5IGhlYWRlcnMpLlxuICAgKi8gc2hvdWxkSW52YWxpZGF0ZShuZXdSZWN0LCBvbGRSZWN0KSB7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIGludmFsaWRhdGUgd2hlbiB0aGUgc2l6ZSBjaGFuZ2VzXG4gICAgICAgIHJldHVybiBuZXdSZWN0LndpZHRoICE9PSBvbGRSZWN0LndpZHRoIHx8IG5ld1JlY3QuaGVpZ2h0ICE9PSBvbGRSZWN0LmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGFsbG93cyB0aGUgbGF5b3V0IHRvIHBlcmZvcm0gYW55IHByZS1jb21wdXRhdGlvblxuICAgKiBpdCBuZWVkcyB0byBpbiBvcmRlciB0byBwcmVwYXJlIHtAbGluayBMYXlvdXRJbmZvfXMgZm9yIHJldHJpZXZhbC5cbiAgICogQ2FsbGVkIGJ5IHRoZSBjb2xsZWN0aW9uIHZpZXcgYmVmb3JlIHtAbGluayBnZXRWaXNpYmxlTGF5b3V0SW5mb3N9XG4gICAqIG9yIHtAbGluayBnZXRMYXlvdXRJbmZvfSBhcmUgY2FsbGVkLlxuICAgKi8gdmFsaWRhdGUoaW52YWxpZGF0aW9uQ29udGV4dCkge31cbiAgICAvKipcbiAgICogUmV0dXJucyBhIHtAbGluayBEcmFnVGFyZ2V0fSBkZXNjcmliaW5nIGEgdmlldyBhdCB0aGUgZ2l2ZW4gcG9pbnQgdG8gYmUgZHJhZ2dlZC5cbiAgICogUmV0dXJuIGBudWxsYCB0byBjYW5jZWwgdGhlIGRyYWcuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdGhlIHZpZXcgYXQgdGhlIGdpdmVuIHBvaW50LlxuICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IGF0IHdoaWNoIHRoZSBkcmFnIG9jY3VycmVkLlxuICAgKi8gLy8gZ2V0RHJhZ1RhcmdldChwb2ludDogUG9pbnQpOiBEcmFnVGFyZ2V0IHwgbnVsbCB7XG4gICAgLy8gICBsZXQgdGFyZ2V0ID0gdGhpcy52aXJ0dWFsaXplci5rZXlBdFBvaW50KHBvaW50KTtcbiAgICAvLyAgIGlmICghdGFyZ2V0KSB7XG4gICAgLy8gICAgIHJldHVybiBudWxsO1xuICAgIC8vICAgfVxuICAgIC8vICAgcmV0dXJuIHtcbiAgICAvLyAgICAgdHlwZTogJ2l0ZW0nLFxuICAgIC8vICAgICBrZXk6IHRhcmdldFxuICAgIC8vICAgfTtcbiAgICAvLyB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSB7QGxpbmsgRHJhZ1RhcmdldH0gb2JqZWN0IGRlc2NyaWJpbmcgd2hlcmUgYSBkcm9wIHNob3VsZCBvY2N1ci4gUmV0dXJuIGBudWxsYFxuICAgKiB0byByZWplY3QgdGhlIGRyb3AuIFRoZSBkcm9wcGVkIGl0ZW1zIHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSByZXN1bHRpbmcgdGFyZ2V0LlxuICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IGF0IHdoaWNoIHRoZSBkcm9wIG9jY3VycmVkLlxuICAgKi8gLy8gZ2V0RHJvcFRhcmdldChwb2ludDogUG9pbnQpOiBEcm9wVGFyZ2V0IHwgbnVsbCB7XG4gICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAvLyB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXJ0aW5nIGF0dHJpYnV0ZXMgZm9yIGFuIGFuaW1hdGVkIGluc2VydGlvbi5cbiAgICogVGhlIHZpZXcgaXMgYW5pbWF0ZWQgZnJvbSB0aGlzIHtAbGluayBMYXlvdXRJbmZvfSB0byB0aGUgb25lIHJldHVybmVkIGJ5IHtAbGluayBnZXRMYXlvdXRJbmZvfS5cbiAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm5zIGl0cyBpbnB1dC5cbiAgICpcbiAgICogQHBhcmFtIGxheW91dEluZm8gVGhlIHByb3Bvc2VkIExheW91dEluZm8gZm9yIHRoaXMgdmlldy5cbiAgICovIGdldEluaXRpYWxMYXlvdXRJbmZvKGxheW91dEluZm8pIHtcbiAgICAgICAgcmV0dXJuIGxheW91dEluZm87XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbmRpbmcgYXR0cmlidXRlcyBmb3IgYW4gYW5pbWF0ZWQgcmVtb3ZhbC5cbiAgICogVGhlIHZpZXcgaXMgYW5pbWF0ZWQgZnJvbSB0aGUge0BsaW5rIExheW91dEluZm99IHJldHVybmVkIGJ5IHtAbGluayBnZXRMYXlvdXRJbmZvfVxuICAgKiB0byB0aGUgb25lIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGl0cyBpbnB1dC5cbiAgICpcbiAgICogQHBhcmFtIGxheW91dEluZm8gVGhlIG9yaWdpbmFsIExheW91dEluZm8gZm9yIHRoaXMgdmlldy5cbiAgICovIGdldEZpbmFsTGF5b3V0SW5mbyhsYXlvdXRJbmZvKSB7XG4gICAgICAgIHJldHVybiBsYXlvdXRJbmZvO1xuICAgIH1cbn1cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJGQ3ZmQ2MTAwOWMyMWQwYmIkZXhwb3J0JDdlMGVlYjlkYTcwMmEwODUge1xuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgTGF5b3V0SW5mby5cbiAgICovIGNvcHkoKSB7XG4gICAgICAgIGxldCByZXMgPSBuZXcgJGQ3ZmQ2MTAwOWMyMWQwYmIkZXhwb3J0JDdlMGVlYjlkYTcwMmEwODUodGhpcy50eXBlLCB0aGlzLmtleSwgdGhpcy5yZWN0LmNvcHkoKSk7XG4gICAgICAgIHJlcy5lc3RpbWF0ZWRTaXplID0gdGhpcy5lc3RpbWF0ZWRTaXplO1xuICAgICAgICByZXMub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICAgICAgcmVzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICByZXMucGFyZW50S2V5ID0gdGhpcy5wYXJlbnRLZXk7XG4gICAgICAgIHJlcy5pc1N0aWNreSA9IHRoaXMuaXNTdGlja3k7XG4gICAgICAgIHJlcy56SW5kZXggPSB0aGlzLnpJbmRleDtcbiAgICAgICAgcmVzLmFsbG93T3ZlcmZsb3cgPSB0aGlzLmFsbG93T3ZlcmZsb3c7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgKiBAcGFyYW0gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZpZXcgdHlwZS4gU2hvdWxkIGJlIGAnaXRlbSdgIGZvciBpdGVtIHZpZXdzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE90aGVyIHR5cGVzIGFyZSB1c2VkIGJ5IHN1cHBsZW1lbnRhcnkgdmlld3MuXG4gICAqIEBwYXJhbSBrZXkgVGhlIHVuaXF1ZSBrZXkgZm9yIHRoaXMgdmlldy5cbiAgICogQHBhcmFtIHJlY3QgVGhlIHJlY3RhbmdsZSBkZXNjcmliaW5nIHRoZSBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGlzIHZpZXcuXG4gICAqLyBjb25zdHJ1Y3Rvcih0eXBlLCBrZXksIHJlY3Qpe1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wYXJlbnRLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY3QgPSByZWN0O1xuICAgICAgICB0aGlzLmVzdGltYXRlZFNpemUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0aWNreSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG4gICAgICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5hbGxvd092ZXJmbG93ID0gZmFsc2U7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBjbGFzcyAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSB7XG4gICAgLyoqXG4gICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcG9pbnQuXG4gICAqLyBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3ICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbC5cbiAgICovIGVxdWFscyhwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBwb2ludC54ICYmIHRoaXMueSA9PT0gcG9pbnQueTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIHRoZSBvcmlnaW4uXG4gICAqLyBpc09yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gMCAmJiB0aGlzLnkgPT09IDA7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCl7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmNsYXNzICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkIHtcbiAgICAvKipcbiAgICogVGhlIG1heGltdW0geC1jb29yZGluYXRlIGluIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgbWF4WCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgbWF4aW11bSB5LWNvb3JkaW5hdGUgaW4gdGhlIHJlY3RhbmdsZS5cbiAgICovIGdldCBtYXhZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgYXJlYSBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKi8gZ2V0IGFyZWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgdG9wTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgdG9wUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh0aGlzLm1heFgsIHRoaXMueSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgYm90dG9tTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHRoaXMueCwgdGhpcy5tYXhZKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqLyBnZXQgYm90dG9tUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh0aGlzLm1heFgsIHRoaXMubWF4WSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyByZWN0YW5nbGUgaW50ZXJzZWN0cyBhbm90aGVyIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGNoZWNrLlxuICAgKi8gaW50ZXJzZWN0cyhyZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPD0gcmVjdC54ICsgcmVjdC53aWR0aCAmJiByZWN0LnggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAmJiB0aGlzLnkgPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQgJiYgcmVjdC55IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgcmVjdGFuZ2xlIGZ1bGx5IGNvbnRhaW5zIGFub3RoZXIgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gY2hlY2suXG4gICAqLyBjb250YWluc1JlY3QocmVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy54IDw9IHJlY3QueCAmJiB0aGlzLnkgPD0gcmVjdC55ICYmIHRoaXMubWF4WCA+PSByZWN0Lm1heFggJiYgdGhpcy5tYXhZID49IHJlY3QubWF4WTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cbiAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIGNoZWNrLlxuICAgKi8gY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy54IDw9IHBvaW50LnggJiYgdGhpcy55IDw9IHBvaW50LnkgJiYgdGhpcy5tYXhYID49IHBvaW50LnggJiYgdGhpcy5tYXhZID49IHBvaW50Lnk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjb3JuZXIgb2YgdGhpcyByZWN0YW5nbGUgKGZyb20gdG9wIHRvIGJvdHRvbSwgbGVmdCB0byByaWdodClcbiAgICogdGhhdCBpcyBjb250YWluZWQgaW4gdGhlIGdpdmVuIHJlY3RhbmdsZSwgb3IgbnVsbCBvZiB0aGUgcmVjdGFuZ2xlcyBkbyBub3QgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gY2hlY2suXG4gICAqLyBnZXRDb3JuZXJJblJlY3QocmVjdCkge1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgW1xuICAgICAgICAgICAgXCJ0b3BMZWZ0XCIsXG4gICAgICAgICAgICBcInRvcFJpZ2h0XCIsXG4gICAgICAgICAgICBcImJvdHRvbUxlZnRcIixcbiAgICAgICAgICAgIFwiYm90dG9tUmlnaHRcIlxuICAgICAgICBdKXtcbiAgICAgICAgICAgIGlmIChyZWN0LmNvbnRhaW5zUG9pbnQodGhpc1trZXldKSkgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZXF1YWxzKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHJlY3QueCA9PT0gdGhpcy54ICYmIHJlY3QueSA9PT0gdGhpcy55ICYmIHJlY3Qud2lkdGggPT09IHRoaXMud2lkdGggJiYgcmVjdC5oZWlnaHQgPT09IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICBwb2ludEVxdWFscyhwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBwb2ludC54ICYmIHRoaXMueSA9PT0gcG9pbnQueTtcbiAgICB9XG4gICAgc2l6ZUVxdWFscyhzaXplKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSBzaXplLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBzaXplLmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuaW9uIG9mIHRoaXMgUmVjdCBhbmQgYW5vdGhlci5cbiAgICovIHVuaW9uKG90aGVyKSB7XG4gICAgICAgIGxldCB4ID0gTWF0aC5taW4odGhpcy54LCBvdGhlci54KTtcbiAgICAgICAgbGV0IHkgPSBNYXRoLm1pbih0aGlzLnksIG90aGVyLnkpO1xuICAgICAgICBsZXQgd2lkdGggPSBNYXRoLm1heCh0aGlzLm1heFgsIG90aGVyLm1heFgpIC0geDtcbiAgICAgICAgbGV0IGhlaWdodCA9IE1hdGgubWF4KHRoaXMubWF4WSwgb3RoZXIubWF4WSkgLSB5O1xuICAgICAgICByZXR1cm4gbmV3ICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgUmVjdCB3aXRoIGFub3RoZXIuXG4gICAqIElmIHRoZSByZWN0YW5nbGVzIGRvIG5vdCBpbnRlcnNlY3QsIGFuIGFsbCB6ZXJvIFJlY3QgaXMgcmV0dXJuZWQuXG4gICAqLyBpbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmludGVyc2VjdHMob3RoZXIpKSByZXR1cm4gbmV3ICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKDAsIDAsIDAsIDApO1xuICAgICAgICBsZXQgeCA9IE1hdGgubWF4KHRoaXMueCwgb3RoZXIueCk7XG4gICAgICAgIGxldCB5ID0gTWF0aC5tYXgodGhpcy55LCBvdGhlci55KTtcbiAgICAgICAgcmV0dXJuIG5ldyAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCh4LCB5LCBNYXRoLm1pbih0aGlzLm1heFgsIG90aGVyLm1heFgpIC0geCwgTWF0aC5taW4odGhpcy5tYXhZLCBvdGhlci5tYXhZKSAtIHkpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyByZWN0YW5nbGUuXG4gICAqLyBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3ICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgd2lkdGggPSAwLCBoZWlnaHQgPSAwKXtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGNsYXNzICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjIHtcbiAgICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBzaXplLlxuICAgKi8gY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAkZWUxYmZhOTBhOTU3ZmI4YSRleHBvcnQkY2I2ZGE4OWM2YWYxYThlYyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBzaXplIGlzIGVxdWFsIHRvIGFub3RoZXIgb25lLlxuICAgKi8gZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSBvdGhlci53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gb3RoZXIuaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICogVGhlIHRvdGFsIGFyZWEgb2YgdGhlIFNpemUuXG4gICAqLyBnZXQgYXJlYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iod2lkdGggPSAwLCBoZWlnaHQgPSAwKXtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGxldCAkYWQxZDk4YWE4ZjBjMzFiNCR2YXIkS0VZID0gMDtcbmNsYXNzICRhZDFkOThhYThmMGMzMWI0JGV4cG9ydCQxYTUyMjM4ODdjNTYwNDQxIHtcbiAgICAvKipcbiAgICogUHJlcGFyZXMgdGhlIHZpZXcgZm9yIHJldXNlLiBDYWxsZWQganVzdCBiZWZvcmUgdGhlIHZpZXcgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uXG4gICAqLyBwcmVwYXJlRm9yUmV1c2UoKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgPSBudWxsO1xuICAgICAgICB0aGlzLmxheW91dEluZm8gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aXJ0dWFsaXplcil7XG4gICAgICAgIHRoaXMudmlydHVhbGl6ZXIgPSB2aXJ0dWFsaXplcjtcbiAgICAgICAgdGhpcy5rZXkgPSArKyRhZDFkOThhYThmMGMzMWI0JHZhciRLRVk7XG4gICAgfVxufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuLy8gdXNlIGhpZ2ggcmVzIHRpbWVyIGlmIGF2YWlsYWJsZVxubGV0ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5wZXJmb3JtYW5jZSA6IG51bGw7XG4vLyBAdHMtaWdub3JlXG5sZXQgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmZOb3cgPSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZiAmJiAoJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmYubm93IHx8ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmLndlYmtpdE5vdyB8fCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZi5tc05vdyB8fCAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZi5tb3pOb3cpO1xubGV0ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lID0gJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJHBlcmZOb3cgPyAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZk5vdy5iaW5kKCQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmKSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbn07XG5sZXQgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGZpeFRzO1xuZnVuY3Rpb24gJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JGRjMGI2MzcyMDc4ODA5MGMoYmVnaW4sIGVuZCwgZHVyYXRpb24sIGVhc2UsIGZuKSB7XG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgbGV0IHJhZl9pZDtcbiAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICBsZXQgc3RhcnQgPSAkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZ2V0VGltZSgpO1xuICAgICAgICBsZXQgZGlmZlggPSBlbmQueCAtIGJlZ2luLng7XG4gICAgICAgIGxldCBkaWZmWSA9IGVuZC55IC0gYmVnaW4ueTtcbiAgICAgICAgcmFmX2lkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIHJ1bih0KSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSB1c2luZyBhIGhpZ2ggcmVzIHRpbWVyLCBtYWtlIHN1cmUgdGltZXN0YW1wIGlzIG5vdCB0aGUgb2xkIGVwb2NoLWJhc2VkIHZhbHVlLlxuICAgICAgICAgICAgLy8gaHR0cDovL3VwZGF0ZXMuaHRtbDVyb2Nrcy5jb20vMjAxMi8wNS9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUtQVBJLW5vdy13aXRoLXN1Yi1taWxsaXNlY29uZC1wcmVjaXNpb25cbiAgICAgICAgICAgIGlmICgkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZml4VHMgPT0gbnVsbCkgJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGZpeFRzID0gdCA+IDFlMTIgIT09ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lKCkgPiAxZTEyO1xuICAgICAgICAgICAgaWYgKCQzZWIxMzFkY2YzN2FkNWY4JHZhciRmaXhUcykgdCA9ICQzZWIxMzFkY2YzN2FkNWY4JHZhciRnZXRUaW1lKCk7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSdyZSBkb25lXG4gICAgICAgICAgICBsZXQgZGVsdGEgPSB0IC0gc3RhcnQ7XG4gICAgICAgICAgICBpZiAoZGVsdGEgPiBkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGZuKGVuZCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGZyYW1lIGNhbGxiYWNrIGFmdGVyIGNvbXB1dGluZyBlYXNlZCB0aW1lIGFuZCBnZXQgdGhlIG5leHQgZnJhbWVcbiAgICAgICAgICAgICAgICBsZXQgcHJvY2VlZCA9IGZuKG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKGJlZ2luLnggKyBkaWZmWCAqIGVhc2UoZGVsdGEgLyBkdXJhdGlvbiksIGJlZ2luLnkgKyBkaWZmWSAqIGVhc2UoZGVsdGEgLyBkdXJhdGlvbikpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2VlZCAhPT0gZmFsc2UgJiYgIWNhbmNlbGVkKSByYWZfaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZfaWQpO1xuICAgIH07XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiAkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkNzc4NjBjMTA2YjRhNmEyZSh0KSB7XG4gICAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiAkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkNTc2MzZiYjQzYjFjY2JiMCh0KSB7XG4gICAgcmV0dXJuIE1hdGguc2luKHQgKiBNYXRoLlBJIC8gMik7XG59XG5cblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQzN2EyNmIyODNmZDc3NDBlKGEsIGIpIHtcbiAgICBsZXQgcmVzID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGtleSBvZiBhLmtleXMoKSlpZiAoIWIuaGFzKGtleSkpIHJlcy5hZGQoa2V5KTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGFjYWY5NmEyNzQzODI0NmIoYSwgYikge1xuICAgIGxldCB0b1JlbW92ZSA9ICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQzN2EyNmIyODNmZDc3NDBlKGEsIGIpO1xuICAgIGxldCB0b0FkZCA9ICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQzN2EyNmIyODNmZDc3NDBlKGIsIGEpO1xuICAgIGxldCB0b1VwZGF0ZSA9IG5ldyBTZXQ7XG4gICAgZm9yIChsZXQga2V5IG9mIGEua2V5cygpKWlmIChiLmhhcyhrZXkpKSB0b1VwZGF0ZS5hZGQoa2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b1JlbW92ZTogdG9SZW1vdmUsXG4gICAgICAgIHRvQWRkOiB0b0FkZCxcbiAgICAgICAgdG9VcGRhdGU6IHRvVXBkYXRlXG4gICAgfTtcbn1cbmZ1bmN0aW9uKiAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkY2ZjMTQwODhkZmVmY2U1ZiguLi5pdGVyYXRvcnMpIHtcbiAgICBmb3IgKGxldCBpdGVyYXRvciBvZiBpdGVyYXRvcnMpeWllbGQqIGl0ZXJhdG9yO1xufVxuZnVuY3Rpb24gJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDY4OTdjMjg0YjZmOWY0ZGMob2JqZWN0KSB7XG4gICAgbGV0IHJlcyA9IHt9O1xuICAgIGZvcihsZXQga2V5IGluIG9iamVjdClyZXNbb2JqZWN0W2tleV1dID0ga2V5O1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkYThkMGQwYzhkMWM1ZGY2NChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGtleSBvZiBhKXtcbiAgICAgICAgaWYgKCFiLmhhcyhrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuY2xhc3MgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlIHtcbiAgICBhZGRTYW1wbGUoc2FtcGxlKSB7XG4gICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgdGhpcy52YWx1ZSArPSAoc2FtcGxlIC0gdGhpcy52YWx1ZSkgLyB0aGlzLmNvdW50O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IDA7XG4gICAgfVxufVxuY2xhc3MgJDM2NDE5MWIzZGVjZjM2OTckZXhwb3J0JDQ0NTVlZTZhZmIzOGRjYmIge1xuICAgIHNldFZpc2libGVSZWN0KHJlY3QpIHtcbiAgICAgICAgbGV0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICBpZiAodGltZSA8IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5hdmVyYWdlVGltZS5hZGRTYW1wbGUodGltZSk7XG4gICAgICAgICAgICBpZiAocmVjdC54ICE9PSB0aGlzLnZpc2libGVSZWN0LnggJiYgdGltZSA+IDApIHRoaXMudmVsb2NpdHkueCA9IChyZWN0LnggLSB0aGlzLnZpc2libGVSZWN0LngpIC8gdGltZTtcbiAgICAgICAgICAgIGlmIChyZWN0LnkgIT09IHRoaXMudmlzaWJsZVJlY3QueSAmJiB0aW1lID4gMCkgdGhpcy52ZWxvY2l0eS55ID0gKHJlY3QueSAtIHRoaXMudmlzaWJsZVJlY3QueSkgLyB0aW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMudmlzaWJsZVJlY3QgPSByZWN0O1xuICAgIH1cbiAgICBjb2xsZWN0TWV0cmljcygpIHtcbiAgICAgICAgbGV0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICBpZiAodGltZSA8IDUwMCkgdGhpcy5hdmVyYWdlUGVyZi5hZGRTYW1wbGUodGltZSk7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGVSZWN0LmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIGxldCBvID0gTWF0aC5hYnModGhpcy52ZWxvY2l0eS55ICogKHRoaXMuYXZlcmFnZVRpbWUudmFsdWUgKyB0aGlzLmF2ZXJhZ2VQZXJmLnZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLm92ZXJzY2FuWS5hZGRTYW1wbGUobyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZVJlY3Qud2lkdGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgbyA9IE1hdGguYWJzKHRoaXMudmVsb2NpdHkueCAqICh0aGlzLmF2ZXJhZ2VUaW1lLnZhbHVlICsgdGhpcy5hdmVyYWdlUGVyZi52YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy5vdmVyc2NhblguYWRkU2FtcGxlKG8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE92ZXJzY2FubmVkUmVjdCgpIHtcbiAgICAgICAgbGV0IG92ZXJzY2FubmVkID0gdGhpcy52aXNpYmxlUmVjdC5jb3B5KCk7XG4gICAgICAgIGxldCBvdmVyc2NhblkgPSBNYXRoLnJvdW5kKE1hdGgubWluKHRoaXMudmlzaWJsZVJlY3QuaGVpZ2h0ICogMiwgdGhpcy5vdmVyc2NhblkudmFsdWUpIC8gMTAwKSAqIDEwMDtcbiAgICAgICAgaWYgKHRoaXMudmVsb2NpdHkueSA+IDApIHtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLnkgLT0gb3ZlcnNjYW5ZICogMC4yO1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQuaGVpZ2h0ICs9IG92ZXJzY2FuWSArIG92ZXJzY2FuWSAqIDAuMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLnkgLT0gb3ZlcnNjYW5ZO1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQuaGVpZ2h0ICs9IG92ZXJzY2FuWSArIG92ZXJzY2FuWSAqIDAuMjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3ZlcnNjYW5YID0gTWF0aC5yb3VuZChNYXRoLm1pbih0aGlzLnZpc2libGVSZWN0LndpZHRoICogMiwgdGhpcy5vdmVyc2NhblgudmFsdWUpIC8gMTAwKSAqIDEwMDtcbiAgICAgICAgaWYgKHRoaXMudmVsb2NpdHkueCA+IDApIHtcbiAgICAgICAgICAgIG92ZXJzY2FubmVkLnggLT0gb3ZlcnNjYW5YICogMC4yO1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQud2lkdGggKz0gb3ZlcnNjYW5YICsgb3ZlcnNjYW5YICogMC4yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3ZlcnNjYW5uZWQueCAtPSBvdmVyc2Nhblg7XG4gICAgICAgICAgICBvdmVyc2Nhbm5lZC53aWR0aCArPSBvdmVyc2NhblggKyBvdmVyc2NhblggKiAwLjI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG92ZXJzY2FubmVkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMuYXZlcmFnZVBlcmYgPSBuZXcgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlKCk7XG4gICAgICAgIHRoaXMuYXZlcmFnZVRpbWUgPSBuZXcgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlKCk7XG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSg1LCA1KTtcbiAgICAgICAgdGhpcy5vdmVyc2NhblggPSBuZXcgJDM2NDE5MWIzZGVjZjM2OTckdmFyJFJvbGxpbmdBdmVyYWdlKCk7XG4gICAgICAgIHRoaXMub3ZlcnNjYW5ZID0gbmV3ICQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSgpO1xuICAgICAgICB0aGlzLnZpc2libGVSZWN0ID0gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCkoKTtcbiAgICB9XG59XG5cblxuXG5cblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gY2xhc3MgJDhlMTM1ZTUzMWQ4ZGNiNjYkZXhwb3J0JGZlYmM1NTczYzc1Y2VmYjAge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5hbmltYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5pdGlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5maW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsTGF5b3V0SW5mbyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5maW5hbExheW91dEluZm8gPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50b1JlbW92ZSA9IG5ldyBNYXAoKTtcbiAgICB9XG59XG5cblxuY2xhc3MgJDM4Yjk0OTBjMWNjYThmYzQkZXhwb3J0JDg5YmU1YTI0M2U1OWM0YjIge1xuICAgIF9zZXRDb250ZW50U2l6ZShzaXplKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRTaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRDb250ZW50U2l6ZShzaXplKTtcbiAgICB9XG4gICAgX3NldENvbnRlbnRPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIGxldCByZWN0ID0gbmV3ICgwLCAkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCkob2Zmc2V0LngsIG9mZnNldC55LCB0aGlzLl92aXNpYmxlUmVjdC53aWR0aCwgdGhpcy5fdmlzaWJsZVJlY3QuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRWaXNpYmxlUmVjdChyZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBjb250ZW50LlxuICAgKi8gZ2V0IGNvbnRlbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXQgdGhlIGNvbGxlY3Rpb24gdmlldydzIGN1cnJlbnRseSB2aXNpYmxlIHJlY3RhbmdsZS5cbiAgICovIGdldCB2aXNpYmxlUmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVSZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICogU2V0IHRoZSBjb2xsZWN0aW9uIHZpZXcncyBjdXJyZW50bHkgdmlzaWJsZSByZWN0YW5nbGUuXG4gICAqLyBzZXQgdmlzaWJsZVJlY3QocmVjdCkge1xuICAgICAgICB0aGlzLl9zZXRWaXNpYmxlUmVjdChyZWN0KTtcbiAgICB9XG4gICAgX3NldFZpc2libGVSZWN0KHJlY3QsIGZvcmNlVXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl92aXNpYmxlUmVjdDtcbiAgICAgICAgLy8gSWdub3JlIGlmIHRoZSByZWN0cyBhcmUgZXF1YWxcbiAgICAgICAgaWYgKHJlY3QuZXF1YWxzKGN1cnJlbnQpKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnNob3VsZE92ZXJzY2FuKSB0aGlzLl9vdmVyc2Nhbk1hbmFnZXIuc2V0VmlzaWJsZVJlY3QocmVjdCk7XG4gICAgICAgIGxldCBzaG91bGRJbnZhbGlkYXRlID0gdGhpcy5sYXlvdXQgJiYgdGhpcy5sYXlvdXQuc2hvdWxkSW52YWxpZGF0ZShyZWN0LCB0aGlzLl92aXNpYmxlUmVjdCk7XG4gICAgICAgIHRoaXMuX3Jlc2V0QW5pbWF0ZWRDb250ZW50T2Zmc2V0KCk7XG4gICAgICAgIHRoaXMuX3Zpc2libGVSZWN0ID0gcmVjdDtcbiAgICAgICAgaWYgKHNob3VsZEludmFsaWRhdGUpIC8vIFdlIGFyZSBhbHJlYWR5IGluIGEgbGF5b3V0IGVmZmVjdCB3aGVuIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgc28gcmVsYXlvdXROb3cgaXMgYXBwcm9wcmlhdGUuXG4gICAgICAgIHRoaXMucmVsYXlvdXROb3coe1xuICAgICAgICAgICAgb2Zmc2V0Q2hhbmdlZDogIXJlY3QucG9pbnRFcXVhbHMoY3VycmVudCksXG4gICAgICAgICAgICBzaXplQ2hhbmdlZDogIXJlY3Quc2l6ZUVxdWFscyhjdXJyZW50KVxuICAgICAgICB9KTtcbiAgICAgICAgZWxzZSB0aGlzLnVwZGF0ZVN1YnZpZXdzKGZvcmNlVXBkYXRlKTtcbiAgICB9XG4gICAgZ2V0IGNvbGxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uO1xuICAgIH1cbiAgICBzZXQgY29sbGVjdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMuX3NldERhdGEoZGF0YSk7XG4gICAgfVxuICAgIF9zZXREYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRoaXMuX2NvbGxlY3Rpb24pIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2NvbGxlY3Rpb24pIHRoaXMuX3J1blRyYW5zYWN0aW9uKCgpPT57XG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gZGF0YTtcbiAgICAgICAgfSwgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24gPiAwKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMucmVsb2FkRGF0YSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZWxvYWRzIHRoZSBkYXRhIGZyb20gdGhlIGRhdGEgc291cmNlIGFuZCByZWxheW91dHMgdGhlIGNvbGxlY3Rpb24gdmlldy5cbiAgICogRG9lcyBub3QgYW5pbWF0ZSBhbnkgY2hhbmdlcy4gRXF1aXZhbGVudCB0byByZS1hc3NpZ25pbmcgdGhlIHNhbWUgZGF0YSBzb3VyY2VcbiAgICogdG8gdGhlIGNvbGxlY3Rpb24gdmlldy5cbiAgICovIHJlbG9hZERhdGEoKSB7XG4gICAgICAgIHRoaXMucmVsYXlvdXQoe1xuICAgICAgICAgICAgY29udGVudENoYW5nZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVtIHdpdGggdGhlIGdpdmVuIGtleS5cbiAgICovIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uID8gdGhpcy5fY29sbGVjdGlvbi5nZXRJdGVtKGtleSkgOiBudWxsO1xuICAgIH1cbiAgICAvKiogVGhlIHNldCBvZiBwZXJzaXN0ZWQga2V5cyBhcmUgYWx3YXlzIHByZXNlbnQgaW4gdGhlIERPTSwgZXZlbiBpZiBub3QgY3VycmVudGx5IGluIHZpZXcuICovIGdldCBwZXJzaXN0ZWRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVyc2lzdGVkS2V5cztcbiAgICB9XG4gICAgLyoqIFRoZSBzZXQgb2YgcGVyc2lzdGVkIGtleXMgYXJlIGFsd2F5cyBwcmVzZW50IGluIHRoZSBET00sIGV2ZW4gaWYgbm90IGN1cnJlbnRseSBpbiB2aWV3LiAqLyBzZXQgcGVyc2lzdGVkS2V5cyhwZXJzaXN0ZWRLZXlzKSB7XG4gICAgICAgIGlmICghKDAsICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRhOGQwZDBjOGQxYzVkZjY0KShwZXJzaXN0ZWRLZXlzLCB0aGlzLl9wZXJzaXN0ZWRLZXlzKSkge1xuICAgICAgICAgICAgdGhpcy5fcGVyc2lzdGVkS2V5cyA9IHBlcnNpc3RlZEtleXM7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN1YnZpZXdzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4ga2V5LCBvciBhbiBhbmNlc3RvciwgaXMgcGVyc2lzdGVkLiAqLyBpc1BlcnNpc3RlZEtleShrZXkpIHtcbiAgICAgICAgLy8gUXVpY2sgY2hlY2sgaWYgdGhlIGtleSBpcyBkaXJlY3RseSBpbiB0aGUgc2V0IG9mIHBlcnNpc3RlZCBrZXlzLlxuICAgICAgICBpZiAodGhpcy5fcGVyc2lzdGVkS2V5cy5oYXMoa2V5KSkgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIElmIG5vdCwgY2hlY2sgaWYgdGhlIGtleSBpcyBhbiBhbmNlc3RvciBvZiBhbnkgb2YgdGhlIHBlcnNpc3RlZCBrZXlzLlxuICAgICAgICBmb3IgKGxldCBrIG9mIHRoaXMuX3BlcnNpc3RlZEtleXMpd2hpbGUoayAhPSBudWxsKXtcbiAgICAgICAgICAgIGxldCBsYXlvdXRJbmZvID0gdGhpcy5sYXlvdXQuZ2V0TGF5b3V0SW5mbyhrKTtcbiAgICAgICAgICAgIGlmICghbGF5b3V0SW5mbykgYnJlYWs7XG4gICAgICAgICAgICBrID0gbGF5b3V0SW5mby5wYXJlbnRLZXk7XG4gICAgICAgICAgICBpZiAoayA9PT0ga2V5KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZXQgdGhlIGNvbGxlY3Rpb24gdmlldydzIGxheW91dC5cbiAgICovIGdldCBsYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXQgdGhlIGNvbGxlY3Rpb24gdmlldydzIGxheW91dC5cbiAgICovIHNldCBsYXlvdXQobGF5b3V0KSB7XG4gICAgICAgIHRoaXMuc2V0TGF5b3V0KGxheW91dCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBTZXRzIHRoZSBjb2xsZWN0aW9uIHZpZXcncyBsYXlvdXQsIG9wdGlvbmFsbHkgd2l0aCBhbiBhbmltYXRlZCB0cmFuc2l0aW9uXG4gICAqIGZyb20gdGhlIGN1cnJlbnQgbGF5b3V0IHRvIHRoZSBuZXcgbGF5b3V0LlxuICAgKiBAcGFyYW0gbGF5b3V0IFRoZSBsYXlvdXQgdG8gc3dpdGNoIHRvLlxuICAgKiBAcGFyYW0gYW5pbWF0ZWQgV2hldGhlciB0byBhbmltYXRlIHRoZSBsYXlvdXQgY2hhbmdlLlxuICAgKi8gc2V0TGF5b3V0KGxheW91dCwgYW5pbWF0ZWQgPSBmYWxzZSkge1xuICAgICAgICBpZiAobGF5b3V0ID09PSB0aGlzLl9sYXlvdXQpIHJldHVybjtcbiAgICAgICAgbGV0IGFwcGx5TGF5b3V0ID0gKCk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXlvdXQpIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuX2xheW91dC52aXJ0dWFsaXplciA9IG51bGw7XG4gICAgICAgICAgICBsYXlvdXQudmlydHVhbGl6ZXIgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYW5pbWF0ZWQpIC8vIEFuaW1hdGVkIGxheW91dCB0cmFuc2l0aW9ucyBhcmUgcmVhbGx5IHNpbXBsZSwgdGhhbmtzIHRvIG91ciB0cmFuc2FjdGlvbiBzdXBwb3J0LlxuICAgICAgICAvLyBXZSBqdXN0IHNldCB0aGUgbGF5b3V0IGluc2lkZSBhIHRyYW5zYWN0aW9uIGFjdGlvbiwgd2hpY2ggcnVucyBhZnRlciB0aGUgaW5pdGlhbFxuICAgICAgICAvLyBsYXlvdXQgaW5mb3MgZm9yIHRoZSBhbmltYXRpb24gYXJlIHJldHJpZXZlZCBmcm9tIHRoZSBwcmV2aW91cyBsYXlvdXQuIFRoZW4sIHRoZVxuICAgICAgICAvLyBmaW5hbCBsYXlvdXQgaW5mb3MgYXJlIHJldHJpZXZlZCBmcm9tIHRoZSBuZXcgbGF5b3V0LCBhbmQgYW5pbWF0aW9ucyBvY2N1ci5cbiAgICAgICAgdGhpcy5fcnVuVHJhbnNhY3Rpb24oYXBwbHlMYXlvdXQpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFwcGx5TGF5b3V0KCk7XG4gICAgICAgICAgICB0aGlzLnJlbGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldFJldXNlVHlwZShsYXlvdXRJbmZvLCBjb250ZW50KSB7XG4gICAgICAgIGlmIChsYXlvdXRJbmZvLnR5cGUgPT09IFwiaXRlbVwiICYmIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5kZWxlZ2F0ZS5nZXRUeXBlID8gdGhpcy5kZWxlZ2F0ZS5nZXRUeXBlKGNvbnRlbnQpIDogXCJpdGVtXCI7XG4gICAgICAgICAgICBsZXQgcmV1c2VUeXBlID0gdHlwZSA9PT0gXCJpdGVtXCIgPyBcIml0ZW1cIiA6IGxheW91dEluZm8udHlwZSArIFwiX1wiICsgdHlwZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICByZXVzZVR5cGU6IHJldXNlVHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogbGF5b3V0SW5mby50eXBlLFxuICAgICAgICAgICAgcmV1c2VUeXBlOiBsYXlvdXRJbmZvLnR5cGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0UmV1c2FibGVWaWV3KGxheW91dEluZm8pIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLmdldEl0ZW0obGF5b3V0SW5mby5rZXkpO1xuICAgICAgICBsZXQgeyByZXVzZVR5cGU6IHJldXNlVHlwZSB9ID0gdGhpcy5fZ2V0UmV1c2VUeXBlKGxheW91dEluZm8sIGNvbnRlbnQpO1xuICAgICAgICBpZiAoIXRoaXMuX3JldXNhYmxlVmlld3NbcmV1c2VUeXBlXSkgdGhpcy5fcmV1c2FibGVWaWV3c1tyZXVzZVR5cGVdID0gW107XG4gICAgICAgIGxldCByZXVzYWJsZSA9IHRoaXMuX3JldXNhYmxlVmlld3NbcmV1c2VUeXBlXTtcbiAgICAgICAgbGV0IHZpZXcgPSByZXVzYWJsZS5sZW5ndGggPiAwID8gcmV1c2FibGUucG9wKCkgOiBuZXcgKDAsICRhZDFkOThhYThmMGMzMWI0JGV4cG9ydCQxYTUyMjM4ODdjNTYwNDQxKSh0aGlzKTtcbiAgICAgICAgdmlldy52aWV3VHlwZSA9IHJldXNlVHlwZTtcbiAgICAgICAgaWYgKCF0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQuaXNPcmlnaW4oKSkge1xuICAgICAgICAgICAgbGF5b3V0SW5mbyA9IGxheW91dEluZm8uY29weSgpO1xuICAgICAgICAgICAgbGF5b3V0SW5mby5yZWN0LnggKz0gdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0Lng7XG4gICAgICAgICAgICBsYXlvdXRJbmZvLnJlY3QueSArPSB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmxheW91dEluZm8gPSBsYXlvdXRJbmZvO1xuICAgICAgICB0aGlzLl9yZW5kZXJWaWV3KHZpZXcpO1xuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9XG4gICAgX3JlbmRlclZpZXcocmV1c2FibGVWaWV3KSB7XG4gICAgICAgIGxldCB7IHR5cGU6IHR5cGUsIGtleToga2V5IH0gPSByZXVzYWJsZVZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgcmV1c2FibGVWaWV3LmNvbnRlbnQgPSB0aGlzLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgcmV1c2FibGVWaWV3LnJlbmRlcmVkID0gdGhpcy5fcmVuZGVyQ29udGVudCh0eXBlLCByZXVzYWJsZVZpZXcuY29udGVudCk7XG4gICAgfVxuICAgIF9yZW5kZXJDb250ZW50KHR5cGUsIGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX3JlbmRlcmVkQ29udGVudC5nZXQoY29udGVudCk7XG4gICAgICAgIGlmIChjYWNoZWQgIT0gbnVsbCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgbGV0IHJlbmRlcmVkID0gdGhpcy5kZWxlZ2F0ZS5yZW5kZXJWaWV3KHR5cGUsIGNvbnRlbnQpO1xuICAgICAgICBpZiAoY29udGVudCkgdGhpcy5fcmVuZGVyZWRDb250ZW50LnNldChjb250ZW50LCByZW5kZXJlZCk7XG4gICAgICAgIHJldHVybiByZW5kZXJlZDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGN1cnJlbnRseSB2aXNpYmxlIHZpZXdzLCBpbmNsdWRpbmcgYm90aFxuICAgKiBpdGVtIHZpZXdzIGFuZCBzdXBwbGVtZW50YXJ5IHZpZXdzLlxuICAgKi8gZ2V0IHZpc2libGVWaWV3cygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fdmlzaWJsZVZpZXdzLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdldHMgdGhlIHZpc2libGUgdmlldyBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIGtleS4gUmV0dXJucyBudWxsIGlmXG4gICAqIHRoZSB2aWV3IGlzIG5vdCBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSB2aWV3IHRvIHJldHJpZXZlLlxuICAgKi8gZ2V0VmlldyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVWaWV3cy5nZXQoa2V5KSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB2aXNpYmxlIHZpZXdzIG1hdGNoaW5nIHRoZSBnaXZlbiB0eXBlLlxuICAgKiBAcGFyYW0gdHlwZSBUaGUgdmlldyB0eXBlIHRvIGZpbmQuXG4gICAqLyBnZXRWaWV3c09mVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVWaWV3cy5maWx0ZXIoKHYpPT52LmxheW91dEluZm8gJiYgdi5sYXlvdXRJbmZvLnR5cGUgPT09IHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5IGZvciB0aGUgZ2l2ZW4gdmlldy4gUmV0dXJucyBudWxsXG4gICAqIGlmIHRoZSB2aWV3IGlzIG5vdCBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICovIGtleUZvclZpZXcodmlldykge1xuICAgICAgICBpZiAodmlldyAmJiB2aWV3LmxheW91dEluZm8pIHJldHVybiB2aWV3LmxheW91dEluZm8ua2V5O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFJldHVybnMgdGhlIGtleSBmb3IgdGhlIGl0ZW0gdmlldyBjdXJyZW50bHkgYXQgdGhlIGdpdmVuIHBvaW50LlxuICAgKi8ga2V5QXRQb2ludChwb2ludCkge1xuICAgICAgICBsZXQgcmVjdCA9IG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKHBvaW50LngsIHBvaW50LnksIDEsIDEpO1xuICAgICAgICBsZXQgbGF5b3V0SW5mb3MgPSB0aGlzLmxheW91dC5nZXRWaXNpYmxlTGF5b3V0SW5mb3MocmVjdCk7XG4gICAgICAgIC8vIExheW91dCBtYXkgcmV0dXJuIG11bHRpcGxlIGxheW91dCBpbmZvcyBpbiB0aGUgY2FzZSBvZlxuICAgICAgICAvLyBwZXJzaXN0ZWQga2V5cywgc28gZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgYWN0dWFsbHkgaW50ZXJzZWN0cy5cbiAgICAgICAgZm9yIChsZXQgbGF5b3V0SW5mbyBvZiBsYXlvdXRJbmZvcyl7XG4gICAgICAgICAgICBpZiAobGF5b3V0SW5mby5yZWN0LmludGVyc2VjdHMocmVjdCkpIHJldHVybiBsYXlvdXRJbmZvLmtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAqIENsZWFudXAgZm9yIHdoZW4gdGhlIFZpcnR1YWxpemVyIHdpbGwgYmUgdW5tb3VudGVkLlxuICAgKi8gd2lsbFVubW91bnQoKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbGF5b3V0UmFmKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFRyaWdnZXJzIGEgbGF5b3V0IGludmFsaWRhdGlvbiwgYW5kIHVwZGF0ZXMgdGhlIHZpc2libGUgc3Vidmlld3MuXG4gICAqLyByZWxheW91dChjb250ZXh0ID0ge30pIHtcbiAgICAgICAgLy8gSWdub3JlIHJlbGF5b3V0cyB3aGlsZSBhbmltYXRpbmcgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsQW5pbWF0aW9uIHx8IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBzY2hlZHVsZWQgYSByZWxheW91dCwgZXh0ZW5kIHRoZSBpbnZhbGlkYXRpb25cbiAgICAgICAgLy8gY29udGV4dCBzbyB3ZSBjb2FsZXNjZSBtdWx0aXBsZSByZWxheW91dHMgaW4gdGhlIHNhbWUgZnJhbWUuXG4gICAgICAgIGlmICh0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGlvbkNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSByZWxheW91dCBpbW1lZGlhdGVseS4gUHJlZmVyIHtAbGluayByZWxheW91dH0gb3ZlciB0aGlzIG1ldGhvZFxuICAgKiB3aGVyZSBwb3NzaWJsZSwgc2luY2UgaXQgY29hbGVzY2VzIG11bHRpcGxlIGxheW91dCBwYXNzZXMgaW4gdGhlIHNhbWUgdGljay5cbiAgICovIHJlbGF5b3V0Tm93KGNvbnRleHQgPSB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0IHx8IHt9KSB7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgc2NoZWR1bGVkIHJlbGF5b3V0LCBzaW5jZSB3ZSdyZSBkb2luZyBpdCBub3cuXG4gICAgICAgIGlmICh0aGlzLl9yZWxheW91dFJhZikge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVsYXlvdXRSYWYpO1xuICAgICAgICAgICAgdGhpcy5fcmVsYXlvdXRSYWYgPSBudWxsO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcm92aWRlZCBjb250ZXh0IHdpdGggdGhlIGN1cnJlbnQgaW52YWxpZGF0aW9uQ29udGV4dCBzaW5jZSB3ZSBhcmUgY2FuY2VsbGluZ1xuICAgICAgICAgICAgLy8gYSBzY2hlZHVsZWQgcmVsYXlvdXROb3cgY2FsbCB0aGF0IGhhcyB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0IHNldCBhcyBpdHMgZGVmYXVsdCBjb250ZXh0IGFyZyAocmVsYXlvdXROb3coKSBpbiByZWxheW91dClcbiAgICAgICAgICAgIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCxcbiAgICAgICAgICAgICAgICAuLi5jb250ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IHRoZSBpbnZhbGlkYXRpb24gY29udGV4dFxuICAgICAgICB0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0ID0gbnVsbDtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB3ZSBkb24ndCBoYXZlIGEgbGF5b3V0IG9yIGNvbnRlbnQsIG9yIHdlIGFyZVxuICAgICAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIGFuIGFuaW1hdGVkIHNjcm9sbCB0cmFuc2l0aW9uLlxuICAgICAgICBpZiAoIXRoaXMubGF5b3V0IHx8ICF0aGlzLl9jb2xsZWN0aW9uIHx8IHRoaXMuX3Njcm9sbEFuaW1hdGlvbikgcmV0dXJuO1xuICAgICAgICBsZXQgc2Nyb2xsQW5jaG9yID0gdGhpcy5fZ2V0U2Nyb2xsQW5jaG9yKCk7XG4gICAgICAgIC8vIFRyaWdnZXIgdGhlIGJlZm9yZUxheW91dCBob29rLCBpZiBwcm92aWRlZFxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuYmVmb3JlTGF5b3V0ID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHQuYmVmb3JlTGF5b3V0KCk7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBsYXlvdXRcbiAgICAgICAgdGhpcy5sYXlvdXQudmFsaWRhdGUoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX3NldENvbnRlbnRTaXplKHRoaXMubGF5b3V0LmdldENvbnRlbnRTaXplKCkpO1xuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBhZnRlckxheW91dCBob29rLCBpZiBwcm92aWRlZFxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuYWZ0ZXJMYXlvdXQgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dC5hZnRlckxheW91dCgpO1xuICAgICAgICAvLyBBZGp1c3Qgc2Nyb2xsIHBvc2l0aW9uIGJhc2VkIG9uIHNjcm9sbCBhbmNob3IsIGFuZCBjb25zdHJhaW4uXG4gICAgICAgIC8vIElmIHRoZSBjb250ZW50IGNoYW5nZWQsIHNjcm9sbCB0byB0aGUgdG9wLlxuICAgICAgICBsZXQgdmlzaWJsZVJlY3QgPSB0aGlzLmdldFZpc2libGVSZWN0KCk7XG4gICAgICAgIGxldCByZXN0b3JlZFNjcm9sbEFuY2hvciA9IHRoaXMuX3Jlc3RvcmVTY3JvbGxBbmNob3Ioc2Nyb2xsQW5jaG9yLCBjb250ZXh0KTtcbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXRYID0gY29udGV4dC5jb250ZW50Q2hhbmdlZCA/IDAgOiByZXN0b3JlZFNjcm9sbEFuY2hvci54O1xuICAgICAgICBsZXQgY29udGVudE9mZnNldFkgPSBjb250ZXh0LmNvbnRlbnRDaGFuZ2VkID8gMCA6IHJlc3RvcmVkU2Nyb2xsQW5jaG9yLnk7XG4gICAgICAgIGNvbnRlbnRPZmZzZXRYID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5jb250ZW50U2l6ZS53aWR0aCAtIHZpc2libGVSZWN0LndpZHRoLCBjb250ZW50T2Zmc2V0WCkpO1xuICAgICAgICBjb250ZW50T2Zmc2V0WSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuY29udGVudFNpemUuaGVpZ2h0IC0gdmlzaWJsZVJlY3QuaGVpZ2h0LCBjb250ZW50T2Zmc2V0WSkpO1xuICAgICAgICBsZXQgaGFzTGF5b3V0VXBkYXRlcyA9IGZhbHNlO1xuICAgICAgICBpZiAoY29udGVudE9mZnNldFggIT09IHZpc2libGVSZWN0LnggfHwgY29udGVudE9mZnNldFkgIT09IHZpc2libGVSZWN0LnkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYW4gYW5pbWF0ZWQgcmVsYXlvdXQsIHdlIGRvIG5vdCBpbW1lZGlhdGVseSBzY3JvbGwgYmVjYXVzZSBpdCB3b3VsZCBiZSBqaXR0ZXJ5LlxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCBuZXcgY29udGVudCBvZmZzZXRzLCBhbmQgYXBwbHkgaXQgdG8gdGhlXG4gICAgICAgICAgICAvLyBpbmRpdmlkdWFsIGNvbnRlbnQgaXRlbXMgaW5zdGVhZC4gQXQgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uLCB3ZSdsbCByZXNldCBhbmQgc2V0IHRoZVxuICAgICAgICAgICAgLy8gc2Nyb2xsIG9mZnNldCBmb3IgcmVhbC4gVGhpcyBlbnN1cmVzIGppdHRlci1mcmVlIGFuaW1hdGlvbiBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIHN5bmNcbiAgICAgICAgICAgIC8vIHRoZSBzY3JvbGwgYW5pbWF0aW9uIGFuZCB0aGUgY29udGVudCBhbmltYXRpb24uXG4gICAgICAgICAgICBpZiAoY29udGV4dC5hbmltYXRlZCB8fCAhdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LmlzT3JpZ2luKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlZENvbnRlbnRPZmZzZXQueCArPSB2aXNpYmxlUmVjdC54IC0gY29udGVudE9mZnNldFg7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LnkgKz0gdmlzaWJsZVJlY3QueSAtIGNvbnRlbnRPZmZzZXRZO1xuICAgICAgICAgICAgICAgIGhhc0xheW91dFVwZGF0ZXMgPSB0aGlzLnVwZGF0ZVN1YnZpZXdzKGNvbnRleHQuY29udGVudENoYW5nZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHRoaXMuX3NldENvbnRlbnRPZmZzZXQobmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoY29udGVudE9mZnNldFgsIGNvbnRlbnRPZmZzZXRZKSk7XG4gICAgICAgIH0gZWxzZSBoYXNMYXlvdXRVcGRhdGVzID0gdGhpcy51cGRhdGVTdWJ2aWV3cyhjb250ZXh0LmNvbnRlbnRDaGFuZ2VkKTtcbiAgICAgICAgLy8gQXBwbHkgbGF5b3V0IGluZm9zLCB1bmxlc3MgdGhpcyBpcyBjb21pbmcgZnJvbSBhbiBhbmltYXRlZCB0cmFuc2FjdGlvblxuICAgICAgICBpZiAoIShjb250ZXh0LnRyYW5zYWN0aW9uICYmIGNvbnRleHQuYW5pbWF0ZWQpKSB0aGlzLl9hcHBseUxheW91dEluZm9zKCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIGFuaW1hdGlvbnMsIGFuZCBhcHBseSB0aGUgYWZ0ZXJBbmltYXRpb24gaG9vaywgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKGNvbnRleHQuYW5pbWF0ZWQgJiYgaGFzTGF5b3V0VXBkYXRlcykge1xuICAgICAgICAgICAgdGhpcy5fZW5hYmxlVHJhbnNpdGlvbnMoKTtcbiAgICAgICAgICAgIGxldCBkb25lID0gKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlVHJhbnNpdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBzY3JvbGwgcG9zaXRpb24gYWZ0ZXIgYW5pbWF0aW9ucyAoc2VlIGFib3ZlIGNvbW1lbnQpLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LmlzT3JpZ2luKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjb250ZW50IG9mZnNldCB0byBzY3JvbGwgdG8sIHRha2luZyBfYW5pbWF0ZWRDb250ZW50T2Zmc2V0IGludG8gYWNjb3VudC5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgeDogeCwgeTogeSB9ID0gdGhpcy5nZXRWaXNpYmxlUmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldEFuaW1hdGVkQ29udGVudE9mZnNldCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50T2Zmc2V0KG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKHgsIHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmFmdGVyQW5pbWF0aW9uID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHQuYWZ0ZXJBbmltYXRpb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgdGhlIGFuaW1hdGlvbiB0YWtlcyBzbGlnaHRseSBsb25nZXIgdGhhbiBleHBlY3RlZC5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZG9uZSwgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24gKyAxMDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0LmFmdGVyQW5pbWF0aW9uID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHQuYWZ0ZXJBbmltYXRpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENvcnJlY3RzIERPTSBvcmRlciBvZiB2aXNpYmxlIHZpZXdzIHRvIG1hdGNoIGl0ZW0gb3JkZXIgb2YgY29sbGVjdGlvbi5cbiAgICovIF9jb3JyZWN0SXRlbU9yZGVyKCkge1xuICAgICAgICAvLyBEZWZlciB1bnRpbCBhZnRlciBzY3JvbGxpbmcgYW5kIGFuaW1hdGVkIHRyYW5zYWN0aW9ucyBhcmUgY29tcGxldGVcbiAgICAgICAgaWYgKHRoaXMuX2lzU2Nyb2xsaW5nIHx8IHRoaXMuX3RyYW5zYWN0aW9uKSByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLl92aXNpYmxlTGF5b3V0SW5mb3Mua2V5cygpKXtcbiAgICAgICAgICAgIGxldCB2aWV3ID0gdGhpcy5fdmlzaWJsZVZpZXdzLmdldChrZXkpO1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uZGVsZXRlKHZpZXcpO1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uYWRkKHZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lbmFibGVUcmFuc2l0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iZWdpbkFuaW1hdGlvbnMoKTtcbiAgICB9XG4gICAgX2Rpc2FibGVUcmFuc2l0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbmRBbmltYXRpb25zKCk7XG4gICAgfVxuICAgIF9nZXRTY3JvbGxBbmNob3IoKSB7XG4gICAgICAgIGlmICghdGhpcy5hbmNob3JTY3JvbGxQb3NpdGlvbikgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB2aXNpYmxlUmVjdCA9IHRoaXMuZ2V0VmlzaWJsZVJlY3QoKTtcbiAgICAgICAgLy8gQXNrIHRoZSBkZWxlZ2F0ZSB0byBwcm92aWRlIGEgc2Nyb2xsIGFuY2hvciwgaWYgcG9zc2libGVcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuZ2V0U2Nyb2xsQW5jaG9yKSB7XG4gICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5kZWxlZ2F0ZS5nZXRTY3JvbGxBbmNob3IodmlzaWJsZVJlY3QpO1xuICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGNvcm5lciA9IGxheW91dEluZm8ucmVjdC5nZXRDb3JuZXJJblJlY3QodmlzaWJsZVJlY3QpO1xuICAgICAgICAgICAgICAgIGlmIChjb3JuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGtleSA9IGxheW91dEluZm8ua2V5O1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gbGF5b3V0SW5mby5yZWN0W2Nvcm5lcl0ueSAtIHZpc2libGVSZWN0Lnk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEluZm86IGxheW91dEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JuZXI6IGNvcm5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gYW5jaG9yIHRoZSBzY3JvbGwgcG9zaXRpb24gaWYgaXQgaXMgYXQgdGhlIHRvcFxuICAgICAgICBpZiAodmlzaWJsZVJlY3QueSA9PT0gMCAmJiAhdGhpcy5hbmNob3JTY3JvbGxQb3NpdGlvbkF0VG9wKSByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gRmluZCBhIHZpZXcgd2l0aCBhIHZpc2libGUgY29ybmVyIHRoYXQgaGFzIHRoZSBzbWFsbGVzdCBkaXN0YW5jZSB0byB0aGUgdG9wIG9mIHRoZSBjb2xsZWN0aW9uIHZpZXdcbiAgICAgICAgbGV0IGNvcm5lckFuY2hvciA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZpZXddIG9mIHRoaXMuX3Zpc2libGVWaWV3cyl7XG4gICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgICAgIGlmIChsYXlvdXRJbmZvICYmIGxheW91dEluZm8ucmVjdC5hcmVhID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBjb3JuZXIgPSBsYXlvdXRJbmZvLnJlY3QuZ2V0Q29ybmVySW5SZWN0KHZpc2libGVSZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29ybmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBsYXlvdXRJbmZvLnJlY3RbY29ybmVyXS55IC0gdmlzaWJsZVJlY3QueTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3JuZXJBbmNob3IgfHwgb2Zmc2V0IDwgY29ybmVyQW5jaG9yLm9mZnNldCkgY29ybmVyQW5jaG9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ybmVyOiBjb3JuZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ybmVyQW5jaG9yO1xuICAgIH1cbiAgICBfcmVzdG9yZVNjcm9sbEFuY2hvcihzY3JvbGxBbmNob3IsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSB0aGlzLmdldFZpc2libGVSZWN0KCk7XG4gICAgICAgIGlmIChzY3JvbGxBbmNob3IpIHtcbiAgICAgICAgICAgIHZhciBfY29udGV4dF90cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGxldCBmaW5hbEFuY2hvciA9ICgoX2NvbnRleHRfdHJhbnNhY3Rpb24gPSBjb250ZXh0LnRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfY29udGV4dF90cmFuc2FjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbnRleHRfdHJhbnNhY3Rpb24uYW5pbWF0ZWQpID8gY29udGV4dC50cmFuc2FjdGlvbi5maW5hbE1hcC5nZXQoc2Nyb2xsQW5jaG9yLmtleSkgOiB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKHNjcm9sbEFuY2hvci5sYXlvdXRJbmZvLmtleSk7XG4gICAgICAgICAgICBpZiAoZmluYWxBbmNob3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRqdXN0bWVudCA9IGZpbmFsQW5jaG9yLnJlY3Rbc2Nyb2xsQW5jaG9yLmNvcm5lcl0ueSAtIGNvbnRlbnRPZmZzZXQueSAtIHNjcm9sbEFuY2hvci5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29udGVudE9mZnNldC55ICs9IGFkanVzdG1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnRPZmZzZXQ7XG4gICAgfVxuICAgIGdldFZpc2libGVSZWN0KCkge1xuICAgICAgICBsZXQgdiA9IHRoaXMudmlzaWJsZVJlY3Q7XG4gICAgICAgIGxldCB4ID0gdi54IC0gdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0Lng7XG4gICAgICAgIGxldCB5ID0gdi55IC0gdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0Lnk7XG4gICAgICAgIHJldHVybiBuZXcgKDAsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkKSh4LCB5LCB2LndpZHRoLCB2LmhlaWdodCk7XG4gICAgfVxuICAgIGdldFZpc2libGVMYXlvdXRJbmZvcygpIHtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLnNob3VsZE92ZXJzY2FuID8gdGhpcy5fb3ZlcnNjYW5NYW5hZ2VyLmdldE92ZXJzY2FubmVkUmVjdCgpIDogdGhpcy5nZXRWaXNpYmxlUmVjdCgpO1xuICAgICAgICB0aGlzLl92aXNpYmxlTGF5b3V0SW5mb3MgPSB0aGlzLl9nZXRMYXlvdXRJbmZvTWFwKHJlY3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZUxheW91dEluZm9zO1xuICAgIH1cbiAgICBfZ2V0TGF5b3V0SW5mb01hcChyZWN0LCBjb3B5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGxheW91dEluZm9zID0gdGhpcy5sYXlvdXQuZ2V0VmlzaWJsZUxheW91dEluZm9zKHJlY3QpO1xuICAgICAgICBsZXQgbWFwID0gbmV3IE1hcDtcbiAgICAgICAgZm9yIChsZXQgbGF5b3V0SW5mbyBvZiBsYXlvdXRJbmZvcyl7XG4gICAgICAgICAgICBpZiAoY29weSkgbGF5b3V0SW5mbyA9IGxheW91dEluZm8uY29weSgpO1xuICAgICAgICAgICAgbWFwLnNldChsYXlvdXRJbmZvLmtleSwgbGF5b3V0SW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgdXBkYXRlU3Vidmlld3MoZm9yY2VVcGRhdGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbGxlY3Rpb24pIHJldHVybjtcbiAgICAgICAgbGV0IHZpc2libGVMYXlvdXRJbmZvcyA9IHRoaXMuZ2V0VmlzaWJsZUxheW91dEluZm9zKCk7XG4gICAgICAgIGxldCBjdXJyZW50bHlWaXNpYmxlID0gdGhpcy5fdmlzaWJsZVZpZXdzO1xuICAgICAgICBsZXQgdG9BZGQsIHRvUmVtb3ZlLCB0b1VwZGF0ZTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGZvcmNlIHVwZGF0ZSwgcmVtb3ZlIGFuZCByZS1hZGQgYWxsIHZpZXdzLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGZpbmQgYW5kIHVwZGF0ZSB0aGUgZGlmZi5cbiAgICAgICAgaWYgKGZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgICB0b0FkZCA9IHZpc2libGVMYXlvdXRJbmZvcztcbiAgICAgICAgICAgIHRvUmVtb3ZlID0gY3VycmVudGx5VmlzaWJsZTtcbiAgICAgICAgICAgIHRvVXBkYXRlID0gbmV3IFNldCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKHsgdG9BZGQ6IHRvQWRkLCB0b1JlbW92ZTogdG9SZW1vdmUsIHRvVXBkYXRlOiB0b1VwZGF0ZSB9ID0gKDAsICRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCRhY2FmOTZhMjc0MzgyNDZiKShjdXJyZW50bHlWaXNpYmxlLCB2aXNpYmxlTGF5b3V0SW5mb3MpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiB0b1VwZGF0ZSl7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXcgPSBjdXJyZW50bHlWaXNpYmxlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICghdmlldyB8fCAhdmlldy5sYXlvdXRJbmZvKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuZ2V0SXRlbSh2aXNpYmxlTGF5b3V0SW5mb3MuZ2V0KGtleSkua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodmlldy5jb250ZW50ID09PSBpdGVtKSB0b1VwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZpZXcgdHlwZSBjaGFuZ2VzLCBkZWxldGUgYW5kIHJlY3JlYXRlIHRoZSB2aWV3IGluc3RlYWQgb2YgdXBkYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgcmV1c2VUeXBlOiByZXVzZVR5cGUgfSA9IHRoaXMuX2dldFJldXNlVHlwZSh2aWV3LmxheW91dEluZm8sIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldy52aWV3VHlwZSAhPT0gcmV1c2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1VwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQWRkLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9SZW1vdmUuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBpZiB0aGUgc2V0cyBhcmUgZXF1YWxcbiAgICAgICAgICAgIGlmICh0b0FkZC5zaXplID09PSAwICYmIHRvUmVtb3ZlLnNpemUgPT09IDAgJiYgdG9VcGRhdGUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbikgdGhpcy5fYXBwbHlMYXlvdXRJbmZvcygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcmFjayB2aWV3cyB0aGF0IHNob3VsZCBiZSByZW1vdmVkLiBUaGV5IGFyZSBub3QgcmVtb3ZlZCBmcm9tXG4gICAgICAgIC8vIHRoZSBET00gaW1tZWRpYXRlbHksIHNpbmNlIHdlIG1heSByZXVzZSBhbmQgbmVlZCB0byByZS1pbnNlcnRcbiAgICAgICAgLy8gdGhlbSBiYWNrIGludG8gdGhlIERPTSBhbnl3YXkuXG4gICAgICAgIGxldCByZW1vdmVkID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdG9SZW1vdmUua2V5cygpKXtcbiAgICAgICAgICAgIGxldCB2aWV3ID0gdGhpcy5fdmlzaWJsZVZpZXdzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkLmFkZCh2aWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlVmlld3MuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSB0cmFuc2FjdGlvbiwgd2FpdCB1bnRpbCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIGFuaW1hdGlvbnMgdG8gcmVtb3ZlIHRoZSB2aWV3cyBmcm9tIHRoZSBET00uIEFsc28gbWVhbnNcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCByZXVzZSB0aG9zZSB2aWV3cyBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb24pIHRoaXMuX3RyYW5zYWN0aW9uLnRvUmVtb3ZlLnNldChrZXksIHZpZXcpO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5yZXVzZVZpZXcodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRvQWRkLmtleXMoKSl7XG4gICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHZpc2libGVMYXlvdXRJbmZvcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGxldCB2aWV3O1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgaW4gYSB0cmFuc2FjdGlvbiwgYW5kIGEgbGF5b3V0IGNoYW5nZSBoYXBwZW5zXG4gICAgICAgICAgICAvLyBkdXJpbmcgdGhlIGFuaW1hdGlvbnMgc3VjaCB0aGF0IGEgdmlldyB0aGF0IHdhcyBnb2luZ1xuICAgICAgICAgICAgLy8gdG8gYmUgcmVtb3ZlZCBpcyBub3cgbm90LCB3ZSBkb24ndCBjcmVhdGUgYSBuZXcgdmlld1xuICAgICAgICAgICAgLy8gc2luY2UgdGhlIG9sZCBvbmUgaXMgc3RpbGwgaW4gdGhlIERPTSwgbWFya2VkIGFzIHRvUmVtb3ZlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdHJhbnNhY3Rpb24sIGdldCBpbml0aWFsIGxheW91dCBhdHRyaWJ1dGVzIGZvciB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uLmluaXRpYWxMYXlvdXRJbmZvLmhhcyhrZXkpKSBsYXlvdXRJbmZvID0gdGhpcy5fdHJhbnNhY3Rpb24uaW5pdGlhbExheW91dEluZm8uZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgdmlldyA9IHRoaXMuX3RyYW5zYWN0aW9uLnRvUmVtb3ZlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uLnRvUmVtb3ZlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG9yIHJldXNlIGEgdmlldyBmb3IgdGhpcyByb3dcbiAgICAgICAgICAgICAgICB2aWV3ID0gdGhpcy5nZXRSZXVzYWJsZVZpZXcobGF5b3V0SW5mbyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSB2aWV3IHRvIHRoZSBET00gaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKCFyZW1vdmVkLmhhcyh2aWV3KSkgdGhpcy5fY2hpbGRyZW4uYWRkKHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVZpZXdzLnNldChrZXksIHZpZXcpO1xuICAgICAgICAgICAgcmVtb3ZlZC5kZWxldGUodmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IG9mIHRvVXBkYXRlKXtcbiAgICAgICAgICAgIGxldCB2aWV3ID0gY3VycmVudGx5VmlzaWJsZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkQ29udGVudC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclZpZXcodmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSByZW1haW5pbmcgcm93cyB0byBkZWxldGUgZnJvbSB0aGUgRE9NXG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNhY3Rpb24pIHRoaXMucmVtb3ZlVmlld3MocmVtb3ZlZCk7XG4gICAgICAgIHRoaXMuX2NvcnJlY3RJdGVtT3JkZXIoKTtcbiAgICAgICAgdGhpcy5fZmx1c2hWaXNpYmxlVmlld3MoKTtcbiAgICAgICAgbGV0IGhhc0xheW91dFVwZGF0ZXMgPSB0aGlzLl90cmFuc2FjdGlvbiAmJiAodG9BZGQuc2l6ZSA+IDAgfHwgdG9SZW1vdmUuc2l6ZSA+IDAgfHwgdGhpcy5faGFzTGF5b3V0VXBkYXRlcygpKTtcbiAgICAgICAgaWYgKGhhc0xheW91dFVwZGF0ZXMpIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgaW4gYSB0cmFuc2FjdGlvbiwgYXBwbHkgYW5pbWF0aW9ucyB0byB2aXNpYmxlIHZpZXdzXG4gICAgICAgICAgICAvLyBhbmQgXCJ0byBiZSByZW1vdmVkXCIgdmlld3MsIHdoaWNoIGFuaW1hdGUgb2ZmIHNjcmVlbi5cbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbikgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT50aGlzLl9hcHBseUxheW91dEluZm9zKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhc0xheW91dFVwZGF0ZXM7XG4gICAgfVxuICAgIGFmdGVyUmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb25RdWV1ZS5sZW5ndGggPiAwKSB0aGlzLl9wcm9jZXNzVHJhbnNhY3Rpb25RdWV1ZSgpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLl9pbnZhbGlkYXRpb25Db250ZXh0KSB0aGlzLnJlbGF5b3V0Tm93KCk7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZE92ZXJzY2FuKSB0aGlzLl9vdmVyc2Nhbk1hbmFnZXIuY29sbGVjdE1ldHJpY3MoKTtcbiAgICB9XG4gICAgX2ZsdXNoVmlzaWJsZVZpZXdzKCkge1xuICAgICAgICAvLyBDb2xsZWN0aW9uVmlydHVhbGl6ZXIgZGVhbHMgd2l0aCBhIGZsYXR0ZW5lZCBzZXQgb2YgTGF5b3V0SW5mb3MsIGJ1dCB0aGV5IGNhbiByZXByZXNlbnQgaGVpcmFyY2h5XG4gICAgICAgIC8vIGJ5IHJlZmVyZW5jaW5nIGEgcGFyZW50S2V5LiBKdXN0IGJlZm9yZSByZW5kZXJpbmcgdGhlIHZpc2libGUgdmlld3MsIHdlIHJlYnVpbGQgdGhpcyBoZWlyYXJjaHlcbiAgICAgICAgLy8gYnkgY3JlYXRpbmcgYSBtYXBwaW5nIG9mIHZpZXdzIGJ5IHBhcmVudCBrZXkgYW5kIHJlY3Vyc2l2ZWx5IGNhbGxpbmcgdGhlIGRlbGVnYXRlJ3MgcmVuZGVyV3JhcHBlclxuICAgICAgICAvLyBtZXRob2QgdG8gYnVpbGQgdGhlIGZpbmFsIHRyZWUuXG4gICAgICAgIGxldCB2aWV3c0J5UGFyZW50S2V5ID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBbXVxuICAgICAgICAgICAgXVxuICAgICAgICBdKTtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLl9jaGlsZHJlbil7XG4gICAgICAgICAgICB2YXIgX3ZpZXdfbGF5b3V0SW5mbywgX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0LCBfdmlld19sYXlvdXRJbmZvMSwgX3ZpZXdfbGF5b3V0SW5mbzIsIF92aWV3X2xheW91dEluZm8zO1xuICAgICAgICAgICAgaWYgKCgoX3ZpZXdfbGF5b3V0SW5mbyA9IHZpZXcubGF5b3V0SW5mbykgPT09IG51bGwgfHwgX3ZpZXdfbGF5b3V0SW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdfbGF5b3V0SW5mby5wYXJlbnRLZXkpICE9IG51bGwgJiYgIXZpZXdzQnlQYXJlbnRLZXkuaGFzKHZpZXcubGF5b3V0SW5mby5wYXJlbnRLZXkpKSB2aWV3c0J5UGFyZW50S2V5LnNldCh2aWV3LmxheW91dEluZm8ucGFyZW50S2V5LCBbXSk7XG4gICAgICAgICAgICAoX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0ID0gdmlld3NCeVBhcmVudEtleS5nZXQoKF92aWV3X2xheW91dEluZm8xID0gdmlldy5sYXlvdXRJbmZvKSA9PT0gbnVsbCB8fCBfdmlld19sYXlvdXRJbmZvMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdfbGF5b3V0SW5mbzEucGFyZW50S2V5KSkgPT09IG51bGwgfHwgX3ZpZXdzQnlQYXJlbnRLZXlfZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmlld3NCeVBhcmVudEtleV9nZXQucHVzaCh2aWV3KTtcbiAgICAgICAgICAgIGlmICghdmlld3NCeVBhcmVudEtleS5oYXMoKF92aWV3X2xheW91dEluZm8yID0gdmlldy5sYXlvdXRJbmZvKSA9PT0gbnVsbCB8fCBfdmlld19sYXlvdXRJbmZvMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdfbGF5b3V0SW5mbzIua2V5KSkgdmlld3NCeVBhcmVudEtleS5zZXQoKF92aWV3X2xheW91dEluZm8zID0gdmlldy5sYXlvdXRJbmZvKSA9PT0gbnVsbCB8fCBfdmlld19sYXlvdXRJbmZvMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZpZXdfbGF5b3V0SW5mbzMua2V5LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ1aWxkVHJlZSA9IChwYXJlbnQsIHZpZXdzKT0+dmlld3MubWFwKCh2aWV3KT0+e1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IHZpZXdzQnlQYXJlbnRLZXkuZ2V0KHZpZXcubGF5b3V0SW5mby5rZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnJlbmRlcldyYXBwZXIocGFyZW50LCB2aWV3LCBjaGlsZHJlbiwgKGNoaWxkVmlld3MpPT5idWlsZFRyZWUodmlldywgY2hpbGRWaWV3cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IGJ1aWxkVHJlZShudWxsLCB2aWV3c0J5UGFyZW50S2V5LmdldChudWxsKSk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0VmlzaWJsZVZpZXdzKGNoaWxkcmVuKTtcbiAgICB9XG4gICAgX2FwcGx5TGF5b3V0SW5mbyh2aWV3LCBsYXlvdXRJbmZvKSB7XG4gICAgICAgIGlmICh2aWV3LmxheW91dEluZm8gPT09IGxheW91dEluZm8pIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmlldy5sYXlvdXRJbmZvID0gbGF5b3V0SW5mbztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9hcHBseUxheW91dEluZm9zKCkge1xuICAgICAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBBcHBseSBsYXlvdXQgaW5mb3MgdG8gdmlzaWJsZSB2aWV3c1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuX3Zpc2libGVWaWV3cy52YWx1ZXMoKSl7XG4gICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgaWYgKChjdXIgPT09IG51bGwgfHwgY3VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXIua2V5KSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGN1ci5rZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbykpIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFwcGx5IGZpbmFsIGxheW91dCBpbmZvcyBmb3Igdmlld3MgdGhhdCB3aWxsIGJlIHJlbW92ZWRcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuX3RyYW5zYWN0aW9uLnRvUmVtb3ZlLnZhbHVlcygpKXtcbiAgICAgICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgICAgIGlmICgoY3VyID09PSBudWxsIHx8IGN1ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VyLmtleSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oY3VyLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbykpIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5fdHJhbnNhY3Rpb24ucmVtb3ZlZC52YWx1ZXMoKSl7XG4gICAgICAgICAgICAgICAgbGV0IGN1ciA9IHZpZXcubGF5b3V0SW5mbztcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMuX3RyYW5zYWN0aW9uLmZpbmFsTGF5b3V0SW5mby5nZXQoY3VyLmtleSkgfHwgY3VyO1xuICAgICAgICAgICAgICAgIGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRGaW5hbExheW91dEluZm8obGF5b3V0SW5mby5jb3B5KCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hcHBseUxheW91dEluZm8odmlldywgbGF5b3V0SW5mbykpIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkKSB0aGlzLl9mbHVzaFZpc2libGVWaWV3cygpO1xuICAgIH1cbiAgICBfaGFzTGF5b3V0VXBkYXRlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc2FjdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMuX3Zpc2libGVWaWV3cy52YWx1ZXMoKSl7XG4gICAgICAgICAgICBsZXQgY3VyID0gdmlldy5sYXlvdXRJbmZvO1xuICAgICAgICAgICAgaWYgKCFjdXIpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgbGV0IGxheW91dEluZm8gPSB0aGlzLmxheW91dC5nZXRMYXlvdXRJbmZvKGN1ci5rZXkpO1xuICAgICAgICAgICAgaWYgKC8vIFVzZXMgZXF1YWxzIHJhdGhlciB0aGFuIHBvaW50RXF1YWxzIHNvIHRoYXQgd2lkdGgvaGVpZ2h0IGNoYW5nZXMgYXJlIHRha2VuIGludG8gYWNjb3VudFxuICAgICAgICAgICAgIWN1ci5yZWN0LmVxdWFscyhsYXlvdXRJbmZvLnJlY3QpIHx8IGN1ci5vcGFjaXR5ICE9PSBsYXlvdXRJbmZvLm9wYWNpdHkgfHwgY3VyLnRyYW5zZm9ybSAhPT0gbGF5b3V0SW5mby50cmFuc2Zvcm0pIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV1c2VWaWV3KHZpZXcpIHtcbiAgICAgICAgdmlldy5wcmVwYXJlRm9yUmV1c2UoKTtcbiAgICAgICAgdGhpcy5fcmV1c2FibGVWaWV3c1t2aWV3LnZpZXdUeXBlXS5wdXNoKHZpZXcpO1xuICAgIH1cbiAgICByZW1vdmVWaWV3cyh0b1JlbW92ZSkge1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRvUmVtb3ZlKXRoaXMuX2NoaWxkcmVuLmRlbGV0ZSh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlSXRlbVNpemUoa2V5LCBzaXplKSB7XG4gICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBiZSBhYmxlIHRvIGludmFsaWRhdGUgYSBzaW5nbGUgaW5kZXggcGF0aFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICghdGhpcy5sYXlvdXQudXBkYXRlSXRlbVNpemUpIHJldHVybjtcbiAgICAgICAgLy8gSWYgdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyBjdXJyZW50bHkgYW5pbWF0aW5nLCBhZGQgdGhlIHVwZGF0ZVxuICAgICAgICAvLyB0byBhIHF1ZXVlIHRvIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zaXplVXBkYXRlUXVldWUuc2V0KGtleSwgc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMubGF5b3V0LnVwZGF0ZUl0ZW1TaXplKGtleSwgc2l6ZSk7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB0aGlzLnJlbGF5b3V0KCk7XG4gICAgfVxuICAgIHN0YXJ0U2Nyb2xsaW5nKCkge1xuICAgICAgICB0aGlzLl9pc1Njcm9sbGluZyA9IHRydWU7XG4gICAgfVxuICAgIGVuZFNjcm9sbGluZygpIHtcbiAgICAgICAgdGhpcy5faXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29ycmVjdEl0ZW1PcmRlcigpO1xuICAgICAgICB0aGlzLl9mbHVzaFZpc2libGVWaWV3cygpO1xuICAgIH1cbiAgICBfcmVzZXRBbmltYXRlZENvbnRlbnRPZmZzZXQoKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBhbmltYXRlZCBjb250ZW50IG9mZnNldCBvZiBzdWJ2aWV3cy4gU2VlIGNvbW1lbnQgaW4gcmVsYXlvdXROb3cgZm9yIGRldGFpbHMuXG4gICAgICAgIGlmICghdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0LmlzT3JpZ2luKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVkQ29udGVudE9mZnNldCA9IG5ldyAoMCwgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEpKDAsIDApO1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlMYXlvdXRJbmZvcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBTY3JvbGxzIHRoZSBpdGVtIHdpdGggdGhlIGdpdmVuIGtleSBpbnRvIHZpZXcsIG9wdGlvbmFsbHkgd2l0aCBhbiBhbmltYXRpb24uXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byBzY3JvbGwgaW50byB2aWV3LlxuICAgKiBAcGFyYW0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBzY3JvbGwgYW5pbWF0aW9uLlxuICAgKi8gc2Nyb2xsVG9JdGVtKGtleSwgb3B0aW9ucykge1xuICAgICAgICAvLyBrZXkgY2FuIGJlIDAsIHNvIGNoZWNrIGlmIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBsZXQgbGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldExheW91dEluZm8oa2V5KTtcbiAgICAgICAgaWYgKCFsYXlvdXRJbmZvKSByZXR1cm47XG4gICAgICAgIGxldCB7IGR1cmF0aW9uOiBkdXJhdGlvbiA9IDMwMCwgc2hvdWxkU2Nyb2xsWDogc2hvdWxkU2Nyb2xsWCA9IHRydWUsIHNob3VsZFNjcm9sbFk6IHNob3VsZFNjcm9sbFkgPSB0cnVlLCBvZmZzZXRYOiBvZmZzZXRYID0gMCwgb2Zmc2V0WTogb2Zmc2V0WSA9IDAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCB4ID0gdGhpcy52aXNpYmxlUmVjdC54O1xuICAgICAgICBsZXQgeSA9IHRoaXMudmlzaWJsZVJlY3QueTtcbiAgICAgICAgbGV0IG1pblggPSBsYXlvdXRJbmZvLnJlY3QueCAtIG9mZnNldFg7XG4gICAgICAgIGxldCBtaW5ZID0gbGF5b3V0SW5mby5yZWN0LnkgLSBvZmZzZXRZO1xuICAgICAgICBsZXQgbWF4WCA9IHggKyB0aGlzLnZpc2libGVSZWN0LndpZHRoO1xuICAgICAgICBsZXQgbWF4WSA9IHkgKyB0aGlzLnZpc2libGVSZWN0LmhlaWdodDtcbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbFgpIHtcbiAgICAgICAgICAgIGlmIChtaW5YIDw9IHggfHwgbWF4WCA9PT0gMCkgeCA9IG1pblg7XG4gICAgICAgICAgICBlbHNlIGlmIChsYXlvdXRJbmZvLnJlY3QubWF4WCA+IG1heFgpIHggKz0gbGF5b3V0SW5mby5yZWN0Lm1heFggLSBtYXhYO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRTY3JvbGxZKSB7XG4gICAgICAgICAgICBpZiAobWluWSA8PSB5IHx8IG1heFkgPT09IDApIHkgPSBtaW5ZO1xuICAgICAgICAgICAgZWxzZSBpZiAobGF5b3V0SW5mby5yZWN0Lm1heFkgPiBtYXhZKSB5ICs9IGxheW91dEluZm8ucmVjdC5tYXhZIC0gbWF4WTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxUbyhuZXcgKDAsICQzMDQxZGIzMjk2OTQ1ZTZlJGV4cG9ydCRiYWYyNjE0NmE0MTRmMjRhKSh4LCB5KSwgZHVyYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYW4gYW5pbWF0ZWQgc2Nyb2xsIHRvIHRoZSBnaXZlbiBvZmZzZXQuXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHRvIHNjcm9sbCB0by5cbiAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUuXG4gICAqLyBzY3JvbGxUbyhvZmZzZXQsIGR1cmF0aW9uID0gMzAwKSB7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgY3VycmVudCBzY3JvbGwgYW5pbWF0aW9uXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSBjb250ZW50IG9mZnNldCBzeW5jaHJvbm91c2x5IGlmIHRoZSBkdXJhdGlvbiBpcyB6ZXJvXG4gICAgICAgIGlmIChkdXJhdGlvbiA8PSAwIHx8IHRoaXMudmlzaWJsZVJlY3QucG9pbnRFcXVhbHMob2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0Q29udGVudE9mZnNldChvZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRTY3JvbGxpbmcoKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uID0gKDAsICQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCRkYzBiNjM3MjA3ODgwOTBjKSh0aGlzLnZpc2libGVSZWN0LCBvZmZzZXQsIGR1cmF0aW9uLCAoMCwgJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JDU3NjM2YmI0M2IxY2NiYjApLCAob2Zmc2V0KT0+e1xuICAgICAgICAgICAgdGhpcy5fc2V0Q29udGVudE9mZnNldChvZmZzZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsQW5pbWF0aW9uLnRoZW4oKCk9PntcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHZpZXcgc2l6ZSB1cGRhdGVzIHRoYXQgb2NjdXJyZWQgZHVyaW5nIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAgICAvLyBPbmx5IHZpZXdzIHRoYXQgYXJlIHN0aWxsIHZpc2libGUgd2lsbCBiZSBhY3R1YWxseSB1cGRhdGVkLlxuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgc2l6ZV0gb2YgdGhpcy5fc2l6ZVVwZGF0ZVF1ZXVlKXRoaXMudXBkYXRlSXRlbVNpemUoa2V5LCBzaXplKTtcbiAgICAgICAgICAgIHRoaXMuX3NpemVVcGRhdGVRdWV1ZS5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5yZWxheW91dCgpO1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1RyYW5zYWN0aW9uUXVldWUoKTtcbiAgICAgICAgICAgIHRoaXMuZW5kU2Nyb2xsaW5nKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsQW5pbWF0aW9uO1xuICAgIH1cbiAgICBfcnVuVHJhbnNhY3Rpb24oYWN0aW9uLCBhbmltYXRlZCkge1xuICAgICAgICB0aGlzLl9zdGFydFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9uZXh0VHJhbnNhY3Rpb24pIHRoaXMuX25leHRUcmFuc2FjdGlvbi5hY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgdGhpcy5fZW5kVHJhbnNhY3Rpb24oYW5pbWF0ZWQpO1xuICAgIH1cbiAgICBfc3RhcnRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9uZXh0VHJhbnNhY3Rpb24pIHRoaXMuX25leHRUcmFuc2FjdGlvbiA9IG5ldyAoMCwgJDhlMTM1ZTUzMWQ4ZGNiNjYkZXhwb3J0JGZlYmM1NTczYzc1Y2VmYjApO1xuICAgICAgICB0aGlzLl9uZXh0VHJhbnNhY3Rpb24ubGV2ZWwrKztcbiAgICB9XG4gICAgX2VuZFRyYW5zYWN0aW9uKGFuaW1hdGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5fbmV4dFRyYW5zYWN0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFNhdmUgd2hldGhlciB0aGUgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGFuaW1hdGVkLlxuICAgICAgICBpZiAoYW5pbWF0ZWQgIT0gbnVsbCkgdGhpcy5fbmV4dFRyYW5zYWN0aW9uLmFuaW1hdGVkID0gYW5pbWF0ZWQ7XG4gICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgcmVhY2hlZCBsZXZlbCAwLCB3ZSBhcmUgc3RpbGwgaW4gYVxuICAgICAgICAvLyBuZXN0ZWQgdHJhbnNhY3Rpb24uIFdhaXQgZm9yIHRoZSBwYXJlbnQgdG8gZW5kLlxuICAgICAgICBpZiAoLS10aGlzLl9uZXh0VHJhbnNhY3Rpb24ubGV2ZWwgPiAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgZm9yIGVtcHR5IHRyYW5zYWN0aW9uc1xuICAgICAgICBpZiAodGhpcy5fbmV4dFRyYW5zYWN0aW9uLmFjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQgYW5pbWF0aW9ucyB0byB0cnVlXG4gICAgICAgIGlmICh0aGlzLl9uZXh0VHJhbnNhY3Rpb24uYW5pbWF0ZWQgPT0gbnVsbCkgdGhpcy5fbmV4dFRyYW5zYWN0aW9uLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gRW5xdWV1ZSB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25RdWV1ZS5wdXNoKHRoaXMuX25leHRUcmFuc2FjdGlvbik7XG4gICAgICAgIHRoaXMuX25leHRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfcHJvY2Vzc1RyYW5zYWN0aW9uUXVldWUoKSB7XG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGlzIGFuaW1hdGluZywgd2FpdCB1bnRpbCB0aGUgZW5kXG4gICAgICAgIC8vIHRvIHByb2Nlc3MgdGhlIG5leHQgdHJhbnNhY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbiB8fCB0aGlzLl9zY3JvbGxBbmltYXRpb24pIHJldHVybjtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLl90cmFuc2FjdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmIChuZXh0KSB0aGlzLl9wZXJmb3JtVHJhbnNhY3Rpb24obmV4dCk7XG4gICAgfVxuICAgIF9nZXRDb250ZW50UmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpKDAsIDAsIHRoaXMuY29udGVudFNpemUud2lkdGgsIHRoaXMuY29udGVudFNpemUuaGVpZ2h0KTtcbiAgICB9XG4gICAgX3BlcmZvcm1UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICB0aGlzLnJlbGF5b3V0Tm93KHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIGFuaW1hdGVkOiB0cmFuc2FjdGlvbi5hbmltYXRlZCxcbiAgICAgICAgICAgIGJlZm9yZUxheW91dDogKCk9PntcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluaXRpYWwgbGF5b3V0IGluZm9zIGZvciBhbGwgdmlld3MgYmVmb3JlIHRoZSB1cGRhdGVzXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgY2FuIGZpZ3VyZSBvdXQgd2hpY2ggdmlld3MgdG8gYWRkIGFuZCByZW1vdmUuXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmFuaW1hdGVkKSB0cmFuc2FjdGlvbi5pbml0aWFsTWFwID0gdGhpcy5fZ2V0TGF5b3V0SW5mb01hcCh0aGlzLl9nZXRDb250ZW50UmVjdCgpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSB0aGUgYWN0aW9ucyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aW9uIG9mIHRyYW5zYWN0aW9uLmFjdGlvbnMpYWN0aW9uKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWZ0ZXJMYXlvdXQ6ICgpPT57XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBmaW5hbCBsYXlvdXQgaW5mb3MgYWZ0ZXIgdGhlIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uYW5pbWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uZmluYWxNYXAgPSB0aGlzLl9nZXRMYXlvdXRJbmZvTWFwKHRoaXMuX2dldENvbnRlbnRSZWN0KCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXR1cFRyYW5zYWN0aW9uQW5pbWF0aW9ucyh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuX3RyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZnRlckFuaW1hdGlvbjogKCk9PntcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW5kIHJldXNlIHZpZXdzIHdoZW4gYW5pbWF0aW9ucyBhcmUgZG9uZVxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi50b1JlbW92ZS5zaXplID4gMCB8fCB0cmFuc2FjdGlvbi5yZW1vdmVkLnNpemUgPiAwKSBmb3IgKGxldCB2aWV3IG9mICgwLCAkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkY2ZjMTQwODhkZmVmY2U1ZikodHJhbnNhY3Rpb24udG9SZW1vdmUudmFsdWVzKCksIHRyYW5zYWN0aW9uLnJlbW92ZWQudmFsdWVzKCkpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uZGVsZXRlKHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJldXNlVmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBET00gb3JkZXIgaXMgY29ycmVjdCBmb3IgYWNjZXNzaWJpbGl0eSBhZnRlciBhbmltYXRpb25zIGFyZSBjb21wbGV0ZVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvcnJlY3RJdGVtT3JkZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mbHVzaFZpc2libGVWaWV3cygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NUcmFuc2FjdGlvblF1ZXVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2V0dXBUcmFuc2FjdGlvbkFuaW1hdGlvbnModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgbGV0IHsgaW5pdGlhbE1hcDogaW5pdGlhbE1hcCwgZmluYWxNYXA6IGZpbmFsTWFwIH0gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBhbmQgZmluYWwgbGF5b3V0IGluZm9zIGZvciBhbmltYXRpb25zXG4gICAgICAgIGZvciAobGV0IFtrZXksIGxheW91dEluZm9dIG9mIGluaXRpYWxNYXApaWYgKGZpbmFsTWFwLmhhcyhrZXkpKSAvLyBTdG9yZSB0aGUgaW5pdGlhbCBsYXlvdXQgaW5mbyBmb3IgdXNlIGR1cmluZyBhbmltYXRpb25zLlxuICAgICAgICB0cmFuc2FjdGlvbi5pbml0aWFsTGF5b3V0SW5mby5zZXQoa2V5LCBsYXlvdXRJbmZvKTtcbiAgICAgICAgZWxzZSAvLyBUaGlzIHZpZXcgd2FzIHJlbW92ZWQuIFN0b3JlIHRoZSBsYXlvdXQgaW5mbyBmb3IgdXNlXG4gICAgICAgIC8vIGluIExheW91dCNnZXRGaW5hbExheW91dEluZm8gZHVyaW5nIGFuaW1hdGlvbnMuXG4gICAgICAgIHRyYW5zYWN0aW9uLmZpbmFsTGF5b3V0SW5mby5zZXQobGF5b3V0SW5mby5rZXksIGxheW91dEluZm8pO1xuICAgICAgICAvLyBHZXQgaW5pdGlhbCBsYXlvdXQgaW5mb3MgZm9yIHZpZXdzIHRoYXQgd2VyZSBhZGRlZFxuICAgICAgICBmb3IgKGxldCBba2V5LCBsYXlvdXRJbmZvXSBvZiBmaW5hbE1hcClpZiAoIWluaXRpYWxNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGxldCBpbml0aWFsTGF5b3V0SW5mbyA9IHRoaXMubGF5b3V0LmdldEluaXRpYWxMYXlvdXRJbmZvKGxheW91dEluZm8uY29weSgpKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmluaXRpYWxMYXlvdXRJbmZvLnNldChrZXksIGluaXRpYWxMYXlvdXRJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIHZpZXdzIHdlcmUgcmVtb3ZlZC5cbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmlld10gb2YgdGhpcy5fdmlzaWJsZVZpZXdzKS8vIElmIGFuIGl0ZW0gaGFzIGEgd2lkdGggb2YgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byByZW1vdmUgaXQgZnJvbSB0aGUgX3Zpc2libGVWaWV3cy5cbiAgICAgICAgLy8gUmVtb3ZpbmcgYW4gaXRlbSB3aXRoICB3aWR0aCBvZiAwIGNhbiBjYXVzZSBhIGxvb3Agd2hlcmUgdGhlIGl0ZW0gZ2V0cyBhZGRlZCwgcmVtb3ZlZCxcbiAgICAgICAgLy8gYWRkZWQsIHJlbW92ZWQuLi4gZXRjIGluIGEgbG9vcC5cbiAgICAgICAgaWYgKCFmaW5hbE1hcC5oYXMoa2V5KSAmJiB2aWV3LmxheW91dEluZm8ucmVjdC53aWR0aCA+IDApIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnJlbW92ZWQuc2V0KGtleSwgdmlldyk7XG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlVmlld3MuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIHNvbWV0aGluZyB3ZWlyZCBoYXBwZW5lZCwgd2hlcmUgd2UgaGF2ZSBhIHZpZXcgYnV0IG5vXG4gICAgICAgICAgICAvLyBpbml0aWFsIGxheW91dCBpbmZvLCB1c2UgdGhlIG9uZSBhdHRhY2hlZCB0byB0aGUgdmlldy5cbiAgICAgICAgICAgIGlmICh2aWV3LmxheW91dEluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLmZpbmFsTGF5b3V0SW5mby5oYXModmlldy5sYXlvdXRJbmZvLmtleSkpIHRyYW5zYWN0aW9uLmZpbmFsTGF5b3V0SW5mby5zZXQodmlldy5sYXlvdXRJbmZvLmtleSwgdmlldy5sYXlvdXRJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pe1xuICAgICAgICB0aGlzLl9jb250ZW50U2l6ZSA9IG5ldyAoMCwgJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWMpO1xuICAgICAgICB0aGlzLl92aXNpYmxlUmVjdCA9IG5ldyAoMCwgJDYwNDIzZjkyYzdmOWFkODckZXhwb3J0JGM3OWZjNjQ5MmYzYWYxM2QpO1xuICAgICAgICB0aGlzLl9yZXVzYWJsZVZpZXdzID0ge307XG4gICAgICAgIHRoaXMuX3Zpc2libGVMYXlvdXRJbmZvcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZVZpZXdzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlZENvbnRlbnQgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0aW9uQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX292ZXJzY2FuTWFuYWdlciA9IG5ldyAoMCwgJDM2NDE5MWIzZGVjZjM2OTckZXhwb3J0JDQ0NTVlZTZhZmIzOGRjYmIpKCk7XG4gICAgICAgIHRoaXMuX3BlcnNpc3RlZEtleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX3Njcm9sbEFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NpemVVcGRhdGVRdWV1ZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZWRDb250ZW50T2Zmc2V0ID0gbmV3ICgwLCAkMzA0MWRiMzI5Njk0NWU2ZSRleHBvcnQkYmFmMjYxNDZhNDE0ZjI0YSkoMCwgMCk7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbmV4dFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICAgICAvLyBTZXQgb3B0aW9ucyBmcm9tIHBhc3NlZCBvYmplY3QgaWYgZ2l2ZW5cbiAgICAgICAgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24gPSAoX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uID0gb3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb24pICE9PSBudWxsICYmIF9vcHRpb25zX3RyYW5zaXRpb25EdXJhdGlvbiAhPT0gdm9pZCAwID8gX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uIDogNTAwO1xuICAgICAgICB0aGlzLmFuY2hvclNjcm9sbFBvc2l0aW9uID0gb3B0aW9ucy5hbmNob3JTY3JvbGxQb3NpdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmNob3JTY3JvbGxQb3NpdGlvbkF0VG9wID0gb3B0aW9ucy5hbmNob3JTY3JvbGxQb3NpdGlvbkF0VG9wIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3VsZE92ZXJzY2FuID0gb3B0aW9ucy5zaG91bGRPdmVyc2NhbiAhPT0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiBbXG4gICAgICAgICAgICBcImRlbGVnYXRlXCIsXG4gICAgICAgICAgICBcInNpemVcIixcbiAgICAgICAgICAgIFwibGF5b3V0XCIsXG4gICAgICAgICAgICBcImNvbGxlY3Rpb25cIlxuICAgICAgICBdKWlmIChvcHRpb25zW2tleV0pIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gJGZjMGIxM2I0ODRhYzExOTQkZXhwb3J0JDE1MDVkYjgyZmUzNTdlNjUob3B0cykge1xuICAgIGxldCBbdmlzaWJsZVZpZXdzLCBzZXRWaXNpYmxlVmlld3NdID0gKDAsICQ4RDNuciR1c2VTdGF0ZSkoW10pO1xuICAgIGxldCBbY29udGVudFNpemUsIHNldENvbnRlbnRTaXplXSA9ICgwLCAkOEQzbnIkdXNlU3RhdGUpKG5ldyAoMCwgJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWMpKCkpO1xuICAgIGxldCBbaXNBbmltYXRpbmcsIHNldEFuaW1hdGluZ10gPSAoMCwgJDhEM25yJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IFtpc1Njcm9sbGluZywgc2V0U2Nyb2xsaW5nXSA9ICgwLCAkOEQzbnIkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgdmlydHVhbGl6ZXIgPSAoMCwgJDhEM25yJHVzZU1lbW8pKCgpPT5uZXcgKDAsICQzOGI5NDkwYzFjY2E4ZmM0JGV4cG9ydCQ4OWJlNWEyNDNlNTljNGIyKSgpLCBbXSk7XG4gICAgdmlydHVhbGl6ZXIuZGVsZWdhdGUgPSB7XG4gICAgICAgIHNldFZpc2libGVWaWV3czogc2V0VmlzaWJsZVZpZXdzLFxuICAgICAgICBzZXRWaXNpYmxlUmVjdCAocmVjdCkge1xuICAgICAgICAgICAgdmlydHVhbGl6ZXIudmlzaWJsZVJlY3QgPSByZWN0O1xuICAgICAgICAgICAgb3B0cy5vblZpc2libGVSZWN0Q2hhbmdlKHJlY3QpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRDb250ZW50U2l6ZTogc2V0Q29udGVudFNpemUsXG4gICAgICAgIHJlbmRlclZpZXc6IG9wdHMucmVuZGVyVmlldyxcbiAgICAgICAgcmVuZGVyV3JhcHBlcjogb3B0cy5yZW5kZXJXcmFwcGVyLFxuICAgICAgICBiZWdpbkFuaW1hdGlvbnM6ICgpPT5zZXRBbmltYXRpbmcodHJ1ZSksXG4gICAgICAgIGVuZEFuaW1hdGlvbnM6ICgpPT5zZXRBbmltYXRpbmcoZmFsc2UpLFxuICAgICAgICBnZXRTY3JvbGxBbmNob3I6IG9wdHMuZ2V0U2Nyb2xsQW5jaG9yXG4gICAgfTtcbiAgICB2aXJ0dWFsaXplci5sYXlvdXQgPSBvcHRzLmxheW91dDtcbiAgICB2aXJ0dWFsaXplci5jb2xsZWN0aW9uID0gb3B0cy5jb2xsZWN0aW9uO1xuICAgIHZpcnR1YWxpemVyLnRyYW5zaXRpb25EdXJhdGlvbiA9IG9wdHMudHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgICgwLCAkOEQzbnIkdXNlTGF5b3V0RWZmZWN0KSgoKT0+e1xuICAgICAgICB2aXJ0dWFsaXplci5hZnRlclJlbmRlcigpO1xuICAgIH0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJvdy1ib2R5LXN0eWxlXG4gICAgKDAsICQ4RDNuciR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIHJldHVybiAoKT0+dmlydHVhbGl6ZXIud2lsbFVubW91bnQoKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW10pO1xuICAgIGxldCBzZXRWaXNpYmxlUmVjdCA9ICgwLCAkOEQzbnIkdXNlQ2FsbGJhY2spKChyZWN0KT0+e1xuICAgICAgICB2aXJ0dWFsaXplci52aXNpYmxlUmVjdCA9IHJlY3Q7XG4gICAgfSwgW1xuICAgICAgICB2aXJ0dWFsaXplclxuICAgIF0pO1xuICAgIGxldCBzdGFydFNjcm9sbGluZyA9ICgwLCAkOEQzbnIkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHZpcnR1YWxpemVyLnN0YXJ0U2Nyb2xsaW5nKCk7XG4gICAgICAgIHNldFNjcm9sbGluZyh0cnVlKTtcbiAgICB9LCBbXG4gICAgICAgIHZpcnR1YWxpemVyXG4gICAgXSk7XG4gICAgbGV0IGVuZFNjcm9sbGluZyA9ICgwLCAkOEQzbnIkdXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHZpcnR1YWxpemVyLmVuZFNjcm9sbGluZygpO1xuICAgICAgICBzZXRTY3JvbGxpbmcoZmFsc2UpO1xuICAgIH0sIFtcbiAgICAgICAgdmlydHVhbGl6ZXJcbiAgICBdKTtcbiAgICBsZXQgc3RhdGUgPSAoMCwgJDhEM25yJHVzZU1lbW8pKCgpPT4oe1xuICAgICAgICAgICAgdmlydHVhbGl6ZXI6IHZpcnR1YWxpemVyLFxuICAgICAgICAgICAgdmlzaWJsZVZpZXdzOiB2aXNpYmxlVmlld3MsXG4gICAgICAgICAgICBzZXRWaXNpYmxlUmVjdDogc2V0VmlzaWJsZVJlY3QsXG4gICAgICAgICAgICBjb250ZW50U2l6ZTogY29udGVudFNpemUsXG4gICAgICAgICAgICBpc0FuaW1hdGluZzogaXNBbmltYXRpbmcsXG4gICAgICAgICAgICBpc1Njcm9sbGluZzogaXNTY3JvbGxpbmcsXG4gICAgICAgICAgICBzdGFydFNjcm9sbGluZzogc3RhcnRTY3JvbGxpbmcsXG4gICAgICAgICAgICBlbmRTY3JvbGxpbmc6IGVuZFNjcm9sbGluZ1xuICAgICAgICB9KSwgW1xuICAgICAgICB2aXJ0dWFsaXplcixcbiAgICAgICAgdmlzaWJsZVZpZXdzLFxuICAgICAgICBzZXRWaXNpYmxlUmVjdCxcbiAgICAgICAgY29udGVudFNpemUsXG4gICAgICAgIGlzQW5pbWF0aW5nLFxuICAgICAgICBpc1Njcm9sbGluZyxcbiAgICAgICAgc3RhcnRTY3JvbGxpbmcsXG4gICAgICAgIGVuZFNjcm9sbGluZ1xuICAgIF0pO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cblxuXG5cblxuZXhwb3J0IHskYzc0Y2RhN2QzMWFmMTI1MyRleHBvcnQkYzg0NjcxZjQ2ZDZhMWNhIGFzIExheW91dCwgJGQ3ZmQ2MTAwOWMyMWQwYmIkZXhwb3J0JDdlMGVlYjlkYTcwMmEwODUgYXMgTGF5b3V0SW5mbywgJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEgYXMgUG9pbnQsICQ2MDQyM2Y5MmM3ZjlhZDg3JGV4cG9ydCRjNzlmYzY0OTJmM2FmMTNkIGFzIFJlY3QsICRlZTFiZmE5MGE5NTdmYjhhJGV4cG9ydCRjYjZkYTg5YzZhZjFhOGVjIGFzIFNpemUsICRhZDFkOThhYThmMGMzMWI0JGV4cG9ydCQxYTUyMjM4ODdjNTYwNDQxIGFzIFJldXNhYmxlVmlldywgJGZjMGIxM2I0ODRhYzExOTQkZXhwb3J0JDE1MDVkYjgyZmUzNTdlNjUgYXMgdXNlVmlydHVhbGl6ZXJTdGF0ZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCIkOEQzbnIkdXNlU3RhdGUiLCJ1c2VNZW1vIiwiJDhEM25yJHVzZU1lbW8iLCJ1c2VFZmZlY3QiLCIkOEQzbnIkdXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCIkOEQzbnIkdXNlQ2FsbGJhY2siLCJ1c2VMYXlvdXRFZmZlY3QiLCIkOEQzbnIkdXNlTGF5b3V0RWZmZWN0IiwiJGM3NGNkYTdkMzFhZjEyNTMkZXhwb3J0JGM4NDY3MWY0NmQ2YTFjYSIsInNob3VsZEludmFsaWRhdGUiLCJuZXdSZWN0Iiwib2xkUmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwidmFsaWRhdGUiLCJpbnZhbGlkYXRpb25Db250ZXh0IiwiZ2V0SW5pdGlhbExheW91dEluZm8iLCJsYXlvdXRJbmZvIiwiZ2V0RmluYWxMYXlvdXRJbmZvIiwiJGQ3ZmQ2MTAwOWMyMWQwYmIkZXhwb3J0JDdlMGVlYjlkYTcwMmEwODUiLCJjb3B5IiwicmVzIiwidHlwZSIsImtleSIsInJlY3QiLCJlc3RpbWF0ZWRTaXplIiwib3BhY2l0eSIsInRyYW5zZm9ybSIsInBhcmVudEtleSIsImlzU3RpY2t5IiwiekluZGV4IiwiYWxsb3dPdmVyZmxvdyIsImNvbnN0cnVjdG9yIiwiJDMwNDFkYjMyOTY5NDVlNmUkZXhwb3J0JGJhZjI2MTQ2YTQxNGYyNGEiLCJ4IiwieSIsImVxdWFscyIsInBvaW50IiwiaXNPcmlnaW4iLCIkNjA0MjNmOTJjN2Y5YWQ4NyRleHBvcnQkYzc5ZmM2NDkyZjNhZjEzZCIsIm1heFgiLCJtYXhZIiwiYXJlYSIsInRvcExlZnQiLCJ0b3BSaWdodCIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsImludGVyc2VjdHMiLCJjb250YWluc1JlY3QiLCJjb250YWluc1BvaW50IiwiZ2V0Q29ybmVySW5SZWN0IiwicG9pbnRFcXVhbHMiLCJzaXplRXF1YWxzIiwic2l6ZSIsInVuaW9uIiwib3RoZXIiLCJNYXRoIiwibWluIiwibWF4IiwiaW50ZXJzZWN0aW9uIiwiJGVlMWJmYTkwYTk1N2ZiOGEkZXhwb3J0JGNiNmRhODljNmFmMWE4ZWMiLCIkYWQxZDk4YWE4ZjBjMzFiNCR2YXIkS0VZIiwiJGFkMWQ5OGFhOGYwYzMxYjQkZXhwb3J0JDFhNTIyMzg4N2M1NjA0NDEiLCJwcmVwYXJlRm9yUmV1c2UiLCJjb250ZW50IiwicmVuZGVyZWQiLCJ2aXJ0dWFsaXplciIsIiQzZWIxMzFkY2YzN2FkNWY4JHZhciRwZXJmIiwid2luZG93IiwicGVyZm9ybWFuY2UiLCIkM2ViMTMxZGNmMzdhZDVmOCR2YXIkcGVyZk5vdyIsIm5vdyIsIndlYmtpdE5vdyIsIm1zTm93IiwibW96Tm93IiwiJDNlYjEzMWRjZjM3YWQ1ZjgkdmFyJGdldFRpbWUiLCJiaW5kIiwiRGF0ZSIsImdldFRpbWUiLCIkM2ViMTMxZGNmMzdhZDVmOCR2YXIkZml4VHMiLCIkM2ViMTMxZGNmMzdhZDVmOCRleHBvcnQkZGMwYjYzNzIwNzg4MDkwYyIsImJlZ2luIiwiZW5kIiwiZHVyYXRpb24iLCJlYXNlIiwiZm4iLCJjYW5jZWxlZCIsInJhZl9pZCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInN0YXJ0IiwiZGlmZlgiLCJkaWZmWSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJ1biIsInQiLCJkZWx0YSIsInByb2NlZWQiLCJjYW5jZWwiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIiQzZWIxMzFkY2YzN2FkNWY4JGV4cG9ydCQ3Nzg2MGMxMDZiNGE2YTJlIiwiJDNlYjEzMWRjZjM3YWQ1ZjgkZXhwb3J0JDU3NjM2YmI0M2IxY2NiYjAiLCJzaW4iLCJQSSIsIiRmYzM2ZjlhMDQ2YTljZTc5JGV4cG9ydCQzN2EyNmIyODNmZDc3NDBlIiwiYSIsImIiLCJTZXQiLCJrZXlzIiwiaGFzIiwiYWRkIiwiJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JGFjYWY5NmEyNzQzODI0NmIiLCJ0b1JlbW92ZSIsInRvQWRkIiwidG9VcGRhdGUiLCIkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkY2ZjMTQwODhkZmVmY2U1ZiIsIml0ZXJhdG9ycyIsIml0ZXJhdG9yIiwiJGZjMzZmOWEwNDZhOWNlNzkkZXhwb3J0JDY4OTdjMjg0YjZmOWY0ZGMiLCJvYmplY3QiLCIkZmMzNmY5YTA0NmE5Y2U3OSRleHBvcnQkYThkMGQwYzhkMWM1ZGY2NCIsIiQzNjQxOTFiM2RlY2YzNjk3JHZhciRSb2xsaW5nQXZlcmFnZSIsImFkZFNhbXBsZSIsInNhbXBsZSIsImNvdW50IiwidmFsdWUiLCIkMzY0MTkxYjNkZWNmMzY5NyRleHBvcnQkNDQ1NWVlNmFmYjM4ZGNiYiIsInNldFZpc2libGVSZWN0IiwidGltZSIsInN0YXJ0VGltZSIsImF2ZXJhZ2VUaW1lIiwidmlzaWJsZVJlY3QiLCJ2ZWxvY2l0eSIsImNvbGxlY3RNZXRyaWNzIiwiYXZlcmFnZVBlcmYiLCJvIiwiYWJzIiwib3ZlcnNjYW5ZIiwib3ZlcnNjYW5YIiwiZ2V0T3ZlcnNjYW5uZWRSZWN0Iiwib3ZlcnNjYW5uZWQiLCJyb3VuZCIsIiQ4ZTEzNWU1MzFkOGRjYjY2JGV4cG9ydCRmZWJjNTU3M2M3NWNlZmIwIiwibGV2ZWwiLCJhY3Rpb25zIiwiYW5pbWF0ZWQiLCJpbml0aWFsTWFwIiwiTWFwIiwiZmluYWxNYXAiLCJpbml0aWFsTGF5b3V0SW5mbyIsImZpbmFsTGF5b3V0SW5mbyIsInJlbW92ZWQiLCIkMzhiOTQ5MGMxY2NhOGZjNCRleHBvcnQkODliZTVhMjQzZTU5YzRiMiIsIl9zZXRDb250ZW50U2l6ZSIsIl9jb250ZW50U2l6ZSIsImRlbGVnYXRlIiwic2V0Q29udGVudFNpemUiLCJfc2V0Q29udGVudE9mZnNldCIsIm9mZnNldCIsIl92aXNpYmxlUmVjdCIsImNvbnRlbnRTaXplIiwiX3NldFZpc2libGVSZWN0IiwiZm9yY2VVcGRhdGUiLCJjdXJyZW50Iiwic2hvdWxkT3ZlcnNjYW4iLCJfb3ZlcnNjYW5NYW5hZ2VyIiwibGF5b3V0IiwiX3Jlc2V0QW5pbWF0ZWRDb250ZW50T2Zmc2V0IiwicmVsYXlvdXROb3ciLCJvZmZzZXRDaGFuZ2VkIiwic2l6ZUNoYW5nZWQiLCJ1cGRhdGVTdWJ2aWV3cyIsImNvbGxlY3Rpb24iLCJfY29sbGVjdGlvbiIsImRhdGEiLCJfc2V0RGF0YSIsIl9ydW5UcmFuc2FjdGlvbiIsInRyYW5zaXRpb25EdXJhdGlvbiIsInJlbG9hZERhdGEiLCJyZWxheW91dCIsImNvbnRlbnRDaGFuZ2VkIiwiZ2V0SXRlbSIsInBlcnNpc3RlZEtleXMiLCJfcGVyc2lzdGVkS2V5cyIsImlzUGVyc2lzdGVkS2V5IiwiayIsImdldExheW91dEluZm8iLCJfbGF5b3V0Iiwic2V0TGF5b3V0IiwiYXBwbHlMYXlvdXQiLCJfZ2V0UmV1c2VUeXBlIiwiZ2V0VHlwZSIsInJldXNlVHlwZSIsImdldFJldXNhYmxlVmlldyIsIl9yZXVzYWJsZVZpZXdzIiwicmV1c2FibGUiLCJ2aWV3IiwibGVuZ3RoIiwicG9wIiwidmlld1R5cGUiLCJfYW5pbWF0ZWRDb250ZW50T2Zmc2V0IiwiX3JlbmRlclZpZXciLCJyZXVzYWJsZVZpZXciLCJfcmVuZGVyQ29udGVudCIsImNhY2hlZCIsIl9yZW5kZXJlZENvbnRlbnQiLCJnZXQiLCJyZW5kZXJWaWV3Iiwic2V0IiwidmlzaWJsZVZpZXdzIiwiQXJyYXkiLCJmcm9tIiwiX3Zpc2libGVWaWV3cyIsInZhbHVlcyIsImdldFZpZXciLCJnZXRWaWV3c09mVHlwZSIsImZpbHRlciIsInYiLCJrZXlGb3JWaWV3Iiwia2V5QXRQb2ludCIsImxheW91dEluZm9zIiwiZ2V0VmlzaWJsZUxheW91dEluZm9zIiwid2lsbFVubW91bnQiLCJfcmVsYXlvdXRSYWYiLCJjb250ZXh0IiwiX3Njcm9sbEFuaW1hdGlvbiIsIl9pbnZhbGlkYXRpb25Db250ZXh0IiwiT2JqZWN0IiwiYXNzaWduIiwic2Nyb2xsQW5jaG9yIiwiX2dldFNjcm9sbEFuY2hvciIsImJlZm9yZUxheW91dCIsImdldENvbnRlbnRTaXplIiwiYWZ0ZXJMYXlvdXQiLCJnZXRWaXNpYmxlUmVjdCIsInJlc3RvcmVkU2Nyb2xsQW5jaG9yIiwiX3Jlc3RvcmVTY3JvbGxBbmNob3IiLCJjb250ZW50T2Zmc2V0WCIsImNvbnRlbnRPZmZzZXRZIiwiaGFzTGF5b3V0VXBkYXRlcyIsInRyYW5zYWN0aW9uIiwiX2FwcGx5TGF5b3V0SW5mb3MiLCJfZW5hYmxlVHJhbnNpdGlvbnMiLCJkb25lIiwiX2Rpc2FibGVUcmFuc2l0aW9ucyIsImFmdGVyQW5pbWF0aW9uIiwic2V0VGltZW91dCIsIl9jb3JyZWN0SXRlbU9yZGVyIiwiX2lzU2Nyb2xsaW5nIiwiX3RyYW5zYWN0aW9uIiwiX3Zpc2libGVMYXlvdXRJbmZvcyIsIl9jaGlsZHJlbiIsImRlbGV0ZSIsImJlZ2luQW5pbWF0aW9ucyIsImVuZEFuaW1hdGlvbnMiLCJhbmNob3JTY3JvbGxQb3NpdGlvbiIsImdldFNjcm9sbEFuY2hvciIsImNvcm5lciIsImFuY2hvclNjcm9sbFBvc2l0aW9uQXRUb3AiLCJjb3JuZXJBbmNob3IiLCJjb250ZW50T2Zmc2V0IiwiX2NvbnRleHRfdHJhbnNhY3Rpb24iLCJmaW5hbEFuY2hvciIsImFkanVzdG1lbnQiLCJfZ2V0TGF5b3V0SW5mb01hcCIsIm1hcCIsInZpc2libGVMYXlvdXRJbmZvcyIsImN1cnJlbnRseVZpc2libGUiLCJpdGVtIiwicmV1c2VWaWV3IiwiX2FwcGx5TGF5b3V0SW5mbyIsInJlbW92ZVZpZXdzIiwiX2ZsdXNoVmlzaWJsZVZpZXdzIiwiX2hhc0xheW91dFVwZGF0ZXMiLCJhZnRlclJlbmRlciIsIl90cmFuc2FjdGlvblF1ZXVlIiwiX3Byb2Nlc3NUcmFuc2FjdGlvblF1ZXVlIiwidmlld3NCeVBhcmVudEtleSIsIl92aWV3X2xheW91dEluZm8iLCJfdmlld3NCeVBhcmVudEtleV9nZXQiLCJfdmlld19sYXlvdXRJbmZvMSIsIl92aWV3X2xheW91dEluZm8yIiwiX3ZpZXdfbGF5b3V0SW5mbzMiLCJwdXNoIiwiYnVpbGRUcmVlIiwicGFyZW50Iiwidmlld3MiLCJjaGlsZHJlbiIsInJlbmRlcldyYXBwZXIiLCJjaGlsZFZpZXdzIiwic2V0VmlzaWJsZVZpZXdzIiwidXBkYXRlZCIsImN1ciIsInVwZGF0ZUl0ZW1TaXplIiwiX3NpemVVcGRhdGVRdWV1ZSIsImNoYW5nZWQiLCJzdGFydFNjcm9sbGluZyIsImVuZFNjcm9sbGluZyIsInNjcm9sbFRvSXRlbSIsIm9wdGlvbnMiLCJzaG91bGRTY3JvbGxYIiwic2hvdWxkU2Nyb2xsWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwibWluWCIsIm1pblkiLCJzY3JvbGxUbyIsInRoZW4iLCJjbGVhciIsImFjdGlvbiIsIl9zdGFydFRyYW5zYWN0aW9uIiwiX25leHRUcmFuc2FjdGlvbiIsIl9lbmRUcmFuc2FjdGlvbiIsIm5leHQiLCJzaGlmdCIsIl9wZXJmb3JtVHJhbnNhY3Rpb24iLCJfZ2V0Q29udGVudFJlY3QiLCJfc2V0dXBUcmFuc2FjdGlvbkFuaW1hdGlvbnMiLCJXZWFrTWFwIiwiX29wdGlvbnNfdHJhbnNpdGlvbkR1cmF0aW9uIiwiJGZjMGIxM2I0ODRhYzExOTQkZXhwb3J0JDE1MDVkYjgyZmUzNTdlNjUiLCJvcHRzIiwiaXNBbmltYXRpbmciLCJzZXRBbmltYXRpbmciLCJpc1Njcm9sbGluZyIsInNldFNjcm9sbGluZyIsIm9uVmlzaWJsZVJlY3RDaGFuZ2UiLCJzdGF0ZSIsIkxheW91dCIsIkxheW91dEluZm8iLCJQb2ludCIsIlJlY3QiLCJTaXplIiwiUmV1c2FibGVWaWV3IiwidXNlVmlydHVhbGl6ZXJTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-stately/virtualizer/dist/import.mjs\n");

/***/ })

};
;